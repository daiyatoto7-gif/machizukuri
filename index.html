<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kingdom Builder 3D</title>
    
    <!-- „Éá„Éê„ÉÉ„Ç∞Áî®„Çπ„Çø„Ç§„É´ -->
    <style>
        #debug-log {
            position: fixed; top: 0; left: 0; width: 100%; height: auto;
            max-height: 100px; overflow-y: scroll;
            background: rgba(0,0,0,0.7); color: lime;
            font-family: monospace; font-size: 10px;
            z-index: 9999; pointer-events: none;
            padding: 5px; box-sizing: border-box;
            display: none;
        }
        .error-msg { color: #ff5555; }
    </style>

    <!-- Three.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    
    <style>
        :root {
            --bg-color: #f0f2f5;
            --panel-bg: #ffffff;
            --accent-color: #3498db;
            --text-color: #2c3e50;
            --xp-color: #f1c40f;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            overflow: hidden;
            user-select: none;
            height: 100vh;
            width: 100vw;
        }

        header {
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            padding: 5px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            position: fixed;
            top: 0;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }
        header > * { pointer-events: auto; }

        .status-bar {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .rank-badge {
            background: var(--accent-color);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.9em;
        }
        .xp-container {
            width: 150px;
            height: 10px;
            background: #eee;
            border-radius: 5px;
            overflow: hidden;
        }
        .xp-fill {
            height: 100%;
            background: var(--xp-color);
            width: 0%;
            transition: width 0.5s;
        }
        .resource-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            font-size: 0.9em;
            justify-content: center;
            padding: 0 10px;
            background: rgba(255,255,255,0.8);
            border-radius: 10px;
        }

        #game-container {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 1;
            background: radial-gradient(circle at center, #dcecf5 0%, #b0c4de 100%);
        }

        #ui-overlay-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            overflow: hidden;
        }

        .overlay-item {
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .tile-timer {
            font-size: 10px;
            font-weight: bold;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 2px 4px;
            border-radius: 4px;
            margin-bottom: 2px;
            white-space: nowrap;
        }
        .progress-bar-container {
            width: 40px; height: 4px; background: rgba(255,255,255,0.5); 
            border-radius: 2px; overflow: hidden;
        }
        .progress-fill { height: 100%; background: #2ecc71; width: 0%; transition: width 0.2s linear; }

        .harvest-bubble {
            background: white;
            border: 2px solid #f39c12;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            animation: bounce 1s infinite alternate;
            cursor: pointer;
        }
        @keyframes bounce { from { transform: translateY(0); } to { transform: translateY(-5px); } }

        .lock-icon {
            font-size: 24px;
            opacity: 0.6;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .float-text {
            position: absolute;
            color: #27ae60;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 0 #fff;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
            z-index: 100;
        }
        @keyframes floatUp { 
            0% { transform: translate(-50%, -50%); opacity: 1; } 
            100% { transform: translate(-50%, -150%); opacity: 0; } 
        }

        #control-panel {
            position: absolute;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            width: 90%; max-width: 400px;
            max-height: 40vh;
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            z-index: 30;
            display: none;
            flex-direction: column;
        }
        #control-panel.active { display: flex; }

        #panel-header {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 2px solid var(--bg-color);
            padding-bottom: 10px; margin-bottom: 10px;
        }
        #panel-title { margin: 0; font-size: 1.1em; color: var(--accent-color); }
        .close-btn { cursor: pointer; font-weight: bold; padding: 0 5px; color: #999; }
        #panel-content { flex: 1; overflow-y: auto; padding-right: 5px; }

        .building-item {
            display: flex; justify-content: space-between; align-items: center;
            border: 1px solid #eee; padding: 8px; border-radius: 6px;
            margin-bottom: 8px; font-size: 0.9em;
        }
        .building-info { display: flex; flex-direction: column; gap: 2px; }
        .res-cost { font-size: 0.85em; color: #666; }

        button {
            padding: 8px 12px; border: none; border-radius: 4px;
            background-color: var(--accent-color); color: white;
            font-weight: bold; cursor: pointer; font-size: 0.9em;
        }
        button.action-btn { width: 100%; padding: 12px; font-size: 1em; margin-top: 5px; }
        button.store-btn { background-color: var(--text-color); margin-top: 10px; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }

        .inventory-section {
            margin-top: 15px;
            border-top: 2px dashed #eee;
            padding-top: 10px;
        }
        .inventory-title {
            font-size: 0.9em; font-weight: bold; color: #7f8c8d; margin-bottom: 5px;
        }

        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 100;
        }
        .modal-content {
            background: white; padding: 30px; border-radius: 10px; text-align: center;
            max-width: 400px; box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

    </style>
</head>
<body>

<div id="debug-log"></div>

<header>
    <div class="status-bar">
        <div class="rank-badge">RANK <span id="display-rank">1</span></div>
        <div class="xp-container">
            <div class="xp-fill" id="display-xp-bar"></div>
        </div>
        <div style="font-size:0.8em; color:#7f8c8d;">Next: <span id="display-next-xp">0</span> XP</div>
    </div>
    <div class="resource-bar">
        <div class="res-item">üí∞ <span id="display-money">0</span></div>
        <div class="res-item">üåæ <span id="display-food">0</span></div>
        <div class="res-item">üå≤ <span id="display-wood">0</span></div>
        <div class="res-item">ü™® <span id="display-stone">0</span></div>
        <div class="res-item">üî© <span id="display-iron">0</span></div>
    </div>
</header>

<div id="game-container"></div>
<div id="ui-overlay-layer"></div>

<div id="control-panel">
    <div id="panel-header">
        <h2 id="panel-title">„Çø„Ç§„É´ÈÅ∏Êäû</h2>
        <div class="close-btn" onclick="closePanel()">‚úï</div>
    </div>
    <div id="panel-content"></div>
</div>

<div id="modal-offline" class="modal">
    <div class="modal-content">
        <h3>„Åä„Åã„Åà„Çä„Å™„Åï„ÅÑÔºÅ</h3>
        <p>‰∏çÂú®„ÅÆÈñì„Å´ÁîüÁî£„Åï„Çå„ÅüË≥áÊ∫ê„Åå<br>Ë≤ØËîµÂ∫´„Å´‰øùÁÆ°„Åï„Çå„Åæ„Åó„Åü„ÄÇ</p>
        <div style="text-align:left; background:#f9f9f9; padding:10px; border-radius:5px; margin:10px 0;">
            <div id="offline-report"></div>
        </div>
        <button onclick="closeModal('modal-offline')" class="action-btn">ÂÜçÈñã„Åô„Çã</button>
    </div>
</div>

<div id="modal-levelup" class="modal">
    <div class="modal-content">
        <h3 style="color:var(--accent-color);">üéâ „É©„É≥„ÇØ„Ç¢„ÉÉ„ÉóÔºÅ üéâ</h3>
        <p style="font-size:1.2em; font-weight:bold;">RANK <span id="levelup-rank"></span> „Å´„Å™„Çä„Åæ„Åó„ÅüÔºÅ</p>
        <button onclick="closeModal('modal-levelup')" class="action-btn">Èñâ„Åò„Çã</button>
    </div>
</div>

<script>
    function log(msg, isError = false) {
        const el = document.getElementById('debug-log');
        if (!el) return;
        const line = document.createElement('div');
        line.textContent = `> ${msg}`;
        if (isError) {
            line.className = 'error-msg';
            el.style.display = 'block'; 
            console.error(msg);
        } else {
            console.log(msg);
        }
        el.appendChild(line);
        el.scrollTop = el.scrollHeight;
    }

    window.onerror = function(message, source, lineno, colno, error) {
        log(`Global Error: ${message} at line ${lineno}`, true);
        return false;
    };

    const CONFIG = {
        gridSize: 25, 
        fps: 30, 
        autoSaveInterval: 5000,
        initialUnlocked: [6, 7, 8, 11, 12, 13],
        storageHours: 8,
        collectCooldown: 30000 
    };

    const BUILDINGS = {
        house: { name: "Ê∞ëÂÆ∂", icon: "üè†", prod: { money: 2 }, cost: { money: 20, food: 10 }, baseTime: 2000 },
        farm: { name: "Áïë", icon: "üåæ", prod: { food: 2 }, cost: { money: 30, wood: 10 }, baseTime: 2000 },
        lumber: { name: "‰ºêÊé°ÊâÄ", icon: "üå≤", prod: { wood: 1 }, cost: { money: 50, food: 20 }, baseTime: 3000 },
        quarry: { name: "Êé°Áü≥Â†¥", icon: "ü™®", prod: { stone: 1 }, cost: { money: 100, food: 50, wood: 50 }, baseTime: 4000 },
        mine: { name: "Èâ±Â±±", icon: "üî©", prod: { iron: 1 }, cost: { money: 200, food: 100, wood: 100, stone: 50 }, baseTime: 5000 },
        market: { name: "Â∏ÇÂ†¥", icon: "‚öñÔ∏è", prod: { money: 10 }, cost: { money: 500, food: 200, wood: 200, stone: 50 }, baseTime: 6000 },
        blacksmith: { name: "ÈçõÂÜ∂Â±ã", icon: "‚öîÔ∏è", prod: { money: 5, iron: 2 }, cost: { money: 800, food: 300, wood: 300, stone: 200, iron: 100 }, baseTime: 7000 }
    };
    
    // „Ç≥„Çπ„ÉàË£úÊ≠£ (1.5ÂÄç)
    for(let k in BUILDINGS) {
        const b = BUILDINGS[k];
        for(let r of ['money','food','wood','stone','iron']) {
            if(!b.prod[r]) b.prod[r] = 0;
            if(!b.cost[r]) b.cost[r] = 0;
        }
    }

    let gameState = {
        rank: 1, xp: 0,
        resources: { money: 200, food: 100, wood: 50, stone: 0, iron: 0 },
        tiles: [],
        inventory: [],
        lastSaveTime: Date.now()
    };

    let selectedTileIndex = null;

    let scene, camera, renderer;
    let raycaster, mouse;
    let tileMeshes = []; 
    let pedestrians = []; 
    
    let pointerDownPos = new THREE.Vector2();
    let isDragging = false;

    function init() {
        log("Game initializing...");

        if (typeof THREE === 'undefined') {
            document.body.innerHTML = '<div style="padding:20px;text-align:center;color:red;"><h3>„Ç®„É©„Éº: 3D„É©„Ç§„Éñ„É©„É™„ÅåË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì„ÄÇ</h3><p>ÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p></div>';
            return;
        }

        loadGame();
        
        if (gameState.tiles.length !== CONFIG.gridSize) {
            gameState.tiles = Array(CONFIG.gridSize).fill(null).map((_, i) => ({
                type: null, level: 0, finishTime: null, 
                unlocked: CONFIG.initialUnlocked.includes(i),
                stored: {},
                lastCollectTime: 0
            }));
        } else {
             gameState.tiles.forEach(t => { 
                 if(!t.stored) t.stored = {}; 
                 if(t.lastCollectTime === undefined) t.lastCollectTime = 0;
             });
        }
        if(!gameState.inventory) gameState.inventory = [];

        try {
            init3D();
        } catch (e) {
            log(`3D Init Error: ${e.message}`, true);
            alert("3DË°®Á§∫„ÅÆÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ");
            return;
        }

        updateHeader();
        
        requestAnimationFrame(animate3D);
        setInterval(gameLogicLoop, 1000); 
        setInterval(saveGame, CONFIG.autoSaveInterval);
        setInterval(updatePanelUI, 500);

        log("Game loop started.");
    }

    function init3D() {
        const container = document.getElementById('game-container');
        if(!container) throw new Error("Game container not found");
        
        let width = container.clientWidth;
        let height = container.clientHeight;

        if (width === 0 || height === 0) {
            width = window.innerWidth;
            height = window.innerHeight;
        }

        if (width === 0 || height === 0) {
            setTimeout(init3D, 100);
            return;
        }

        scene = new THREE.Scene();
        
        const aspect = width / height;
        const d = 10;
        
        camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(20, 20, 20); 
        camera.lookAt(scene.position);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        const pixelRatio = Math.max(window.devicePixelRatio, 2.0);
        renderer.setPixelRatio(pixelRatio);
        
        renderer.setSize(width, height);
        renderer.shadowMap.enabled = true;
        renderer.setClearColor( 0x000000, 0 ); 
        container.appendChild(renderer.domElement);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        createTiles();
        initPedestrians();

        window.addEventListener('resize', onWindowResize, false);
        
        renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
        renderer.domElement.addEventListener('pointerup', onPointerUp, false);
        renderer.domElement.addEventListener('pointermove', onPointerMove, false);
        
        setTimeout(onWindowResize, 100);
    }

    function createTiles() {
        const geometry = new THREE.BoxGeometry(1.6, 0.5, 1.6);
        const lockedMat = new THREE.MeshStandardMaterial({ color: 0x95a5a6 });
        const unlockedMat = new THREE.MeshStandardMaterial({ color: 0xecf0f1 });
        
        const groundGeo = new THREE.PlaneGeometry(2.0, 2.0);
        const groundMatBase = new THREE.MeshStandardMaterial({ color: 0x555555 });

        const offset = 2; 
        const start = -offset * 2;

        for (let i = 0; i < 25; i++) {
            const row = Math.floor(i / 5);
            const col = i % 5;
            const x = start + col * offset;
            const z = start + row * offset;

            const ground = new THREE.Mesh(groundGeo, groundMatBase.clone());
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(x, -0.01, z);
            ground.receiveShadow = true;
            scene.add(ground);

            const mesh = new THREE.Mesh(geometry, unlockedMat.clone());
            mesh.position.set(x, 0, z);
            mesh.receiveShadow = true;
            mesh.userData = { index: i, type: 'tile' };
            scene.add(mesh);

            const bGroup = new THREE.Group();
            bGroup.position.set(0, 0.25, 0);
            mesh.add(bGroup);

            const overlay = document.createElement('div');
            overlay.className = 'overlay-item';
            document.getElementById('ui-overlay-layer').appendChild(overlay);

            const particles = new ParticleSystem(mesh.position, scene);

            tileMeshes.push({ 
                mesh: mesh, 
                groundMesh: ground,
                buildingGroup: bGroup,
                overlayEl: overlay,
                particles: particles,
                currentType: null 
            });
        }
        
        sync3DState();
    }

    class Person {
        constructor(scene) {
            this.scene = scene;
            this.mesh = new THREE.Group();
            
            const bodyColor = Math.random() * 0xffffff;
            const bodyGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.25, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.125;
            this.mesh.add(body);
            
            const headGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 0.35;
            this.mesh.add(head);
            
            this.mesh.castShadow = true;
            scene.add(this.mesh);
            
            this.active = false;
            this.mesh.visible = false;
            
            this.reset();
        }
        
        reset() {
            const isVertical = Math.random() < 0.5;
            const lanes = [-5, -3, -1, 1, 3, 5];
            const lane = lanes[Math.floor(Math.random() * lanes.length)];
            
            this.speed = 0.02 + Math.random() * 0.02;
            
            let sx, sz, dx, dz;
            if (isVertical) {
                sx = lane;
                sz = (Math.random() < 0.5 ? -6 : 6);
                dx = 0; dz = sz > 0 ? -1 : 1;
            } else {
                sz = lane;
                sx = (Math.random() < 0.5 ? -6 : 6);
                dx = sx > 0 ? -1 : 1; dz = 0;
            }

            this.mesh.position.set(sx, 0, sz);
            this.direction = new THREE.Vector3(dx, 0, dz);
            
            if (this.isOnGreenRoad(sx, sz, isVertical)) {
                this.active = false;
                this.mesh.visible = false;
            } else {
                this.active = true;
                this.mesh.visible = true;
            }
        }

        isOnGreenRoad(x, z, isVertical) {
            const checkTile = (tx, tz) => {
                const col = Math.round((tx + 4) / 2);
                const row = Math.round((tz + 4) / 2);
                // ÁîªÈù¢Â§ñ„ÅØÈñãÊãìÊ∏à„ÅøÊâ±„ÅÑÔºàÂá∫ÁèæË®±ÂèØÔºâ
                if (col < 0 || col > 4 || row < 0 || row > 4) return true;
                const idx = row * 5 + col;
                return gameState.tiles[idx] && gameState.tiles[idx].unlocked;
            };

            let t1_unlocked = false;
            let t2_unlocked = false;

            if (isVertical) {
                t1_unlocked = checkTile(x - 1, Math.round(z));
                t2_unlocked = checkTile(x + 1, Math.round(z));
            } else {
                t1_unlocked = checkTile(Math.round(x), z - 1);
                t2_unlocked = checkTile(Math.round(x), z + 1);
            }

            // ‰∏°ÂÅ¥„ÅåÊú™ÈñãÊãì„Å™„ÇâÁ∑ë„ÅÆÈÅì -> true
            return (!t1_unlocked && !t2_unlocked);
        }
        
        update() {
            if (!this.active) {
                if (Math.random() < 0.01) this.reset();
                return;
            }

            this.mesh.position.addScaledVector(this.direction, this.speed);
            
            if (Math.abs(this.mesh.position.x) > 7 || Math.abs(this.mesh.position.z) > 7) {
                this.reset();
            }
            
            const isVertical = (this.direction.z !== 0);
            if (this.isOnGreenRoad(this.mesh.position.x, this.mesh.position.z, isVertical)) {
                this.active = false;
                this.mesh.visible = false;
            }
            
            this.mesh.position.y = Math.abs(Math.sin(Date.now() * 0.01)) * 0.05;
        }
    }

    function initPedestrians() {
        for (let i = 0; i < 15; i++) { 
            pedestrians.push(new Person(scene));
        }
    }

    class ParticleSystem {
        constructor(position, scene) {
            this.origin = position.clone().add(new THREE.Vector3(0, 1, 0));
            this.particles = [];
            this.scene = scene;
            this.active = false;
            
            this.geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            this.mat = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true });
        }

        update() {
            if (!this.active && this.particles.length === 0) return;

            if (this.active && Math.random() < 0.2) {
                const mesh = new THREE.Mesh(this.geo, this.mat.clone());
                const offset = new THREE.Vector3((Math.random()-0.5)*1.5, 0, (Math.random()-0.5)*1.5);
                mesh.position.copy(this.origin).add(offset);
                this.scene.add(mesh);
                this.particles.push({ 
                    mesh: mesh, 
                    vel: new THREE.Vector3(0, 0.05 + Math.random()*0.05, 0), 
                    life: 1.0 
                });
            }

            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.mesh.position.add(p.vel);
                p.mesh.rotation.x += 0.1;
                p.mesh.rotation.y += 0.1;
                p.life -= 0.02;
                p.mesh.material.opacity = p.life;

                if (p.life <= 0) {
                    this.scene.remove(p.mesh);
                    this.particles.splice(i, 1);
                }
            }
        }
    }

    function createBuildingMesh(type, level) {
        const group = new THREE.Group();
        const scale = 1 + (level * 0.05);
        group.scale.set(scale, scale, scale);

        const matRoof = new THREE.MeshStandardMaterial({ color: 0xe74c3c }); 
        const matWall = new THREE.MeshStandardMaterial({ color: 0xf39c12 }); 
        const matLeaf = new THREE.MeshStandardMaterial({ color: 0x2ecc71 }); 
        const matStone = new THREE.MeshStandardMaterial({ color: 0x7f8c8d }); 
        const matDark = new THREE.MeshStandardMaterial({ color: 0x34495e }); 
        const matTent = new THREE.MeshStandardMaterial({ color: 0x3498db }); 
        const matGrass = new THREE.MeshStandardMaterial({ color: 0x27ae60 });

        switch(type) {
            case 'wild': // Êú™ÈñãÊãìÂú∞„ÅÆËçâ
                for(let i=0; i<8; i++) {
                    const grass = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.3, 4), matGrass);
                    grass.position.set((Math.random()-0.5)*1.4, 0.15, (Math.random()-0.5)*1.4);
                    grass.rotation.y = Math.random() * Math.PI;
                    group.add(grass);
                }
                // Â∞è„Åï„Å™Êú®„ÇÇËøΩÂä†
                if(Math.random() < 0.5) {
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.3), new THREE.MeshStandardMaterial({color:0x8B4513}));
                    trunk.position.y = 0.15;
                    group.add(trunk);
                    const leaves = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 8), matLeaf);
                    leaves.position.y = 0.4;
                    group.add(leaves);
                }
                break;

            case 'house':
                const wall = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.8), matWall);
                wall.position.y = 0.3;
                wall.castShadow = true;
                group.add(wall);
                const roof = new THREE.Mesh(new THREE.ConeGeometry(0.7, 0.5, 4), matRoof);
                roof.position.y = 0.85;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                group.add(roof);
                // ÁÖôÁ™Å
                const chimney = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), matStone);
                chimney.position.set(0.2, 0.8, 0.2);
                group.add(chimney);
                break;

            case 'farm':
                const soil = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.1, 1.0), new THREE.MeshStandardMaterial({color:0x8B4513}));
                soil.position.y = 0.05;
                soil.receiveShadow = true;
                group.add(soil);
                for(let i=0; i<4; i++) {
                    const crop = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), matLeaf);
                    crop.position.set((i%2 ? 0.3 : -0.3), 0.25, (i<2 ? 0.3 : -0.3));
                    group.add(crop);
                }
                break;

            case 'lumber':
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 0.4), new THREE.MeshStandardMaterial({color:0x8B4513}));
                trunk.position.y = 0.2;
                group.add(trunk);
                const leaves = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 8), matLeaf);
                leaves.position.y = 0.7;
                group.add(leaves);
                const stump = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.2), new THREE.MeshStandardMaterial({color:0x8B4513}));
                stump.position.set(0.4, 0.1, 0.4);
                group.add(stump);
                break;

            case 'quarry':
                const rock1 = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4), matStone);
                rock1.position.y = 0.3;
                group.add(rock1);
                const rock2 = new THREE.Mesh(new THREE.DodecahedronGeometry(0.3), matStone);
                rock2.position.set(0.4, 0.2, 0.3);
                group.add(rock2);
                break;

            case 'mine':
                const frame = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.2), new THREE.MeshStandardMaterial({color:0x5d4037}));
                frame.position.set(0, 0.3, -0.2);
                group.add(frame);
                const hole = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.1), new THREE.MeshStandardMaterial({color:0x000000}));
                hole.position.set(0, 0.25, -0.1);
                group.add(hole);
                break;

            case 'market':
                const post = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.4, 0.8), new THREE.MeshStandardMaterial({color:0xecf0f1}));
                post.position.y = 0.2;
                group.add(post);
                const tent = new THREE.Mesh(new THREE.ConeGeometry(0.7, 0.5, 4), matTent);
                tent.position.y = 0.65;
                tent.rotation.y = Math.PI / 4;
                group.add(tent);
                break;

            case 'blacksmith':
                const houseB = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.5, 0.6), matDark);
                houseB.position.y = 0.25;
                group.add(houseB);
                const chimney2 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), new THREE.MeshStandardMaterial({color:0x2c3e50}));
                chimney2.position.set(0.3, 0.4, 0.2);
                group.add(chimney2);
                break;
        }
        return group;
    }

    function animate3D() {
        requestAnimationFrame(animate3D);
        tileMeshes.forEach(t => t.particles.update());
        pedestrians.forEach(p => p.update()); 
        if(renderer && scene && camera) {
            renderer.render(scene, camera);
        }
        updateOverlayPositions();
    }

    function updateOverlayPositions() {
        if (!camera) return;
        const width = window.innerWidth;
        const height = window.innerHeight;
        const widthHalf = width / 2;
        const heightHalf = height / 2;

        tileMeshes.forEach((t, i) => {
            const tileData = gameState.tiles[i];
            const pos = t.mesh.position.clone();
            if (tileData.unlocked) pos.y += 1.5; 
            else pos.y += 0.5;

            pos.project(camera);

            const x = (pos.x * widthHalf) + widthHalf;
            const y = -(pos.y * heightHalf) + heightHalf;

            if (x < -50 || x > width + 50 || y < -50 || y > height + 50) {
                t.overlayEl.style.display = 'none';
            } else {
                t.overlayEl.style.display = 'flex';
                t.overlayEl.style.left = `${x}px`;
                t.overlayEl.style.top = `${y}px`;
            }
        });
    }

    function sync3DState() {
        const reqRank = getRequiredRankForExpansion();
        
        gameState.tiles.forEach((tile, i) => {
            const tObj = tileMeshes[i];
            const mesh = tObj.mesh;
            const overlay = tObj.overlayEl;
            const ground = tObj.groundMesh;

            if (!tile.unlocked) {
                // Êú™ÈñãÊãìÂú∞: Âú∞Èù¢„ÅØÁ∑ë„ÄÅ„Çø„Ç§„É´„ÇÇÁ∑ë„ÄÅËçâ„É¢„Éá„É´Ë°®Á§∫
                ground.material.color.setHex(0x27ae60);
                mesh.material.color.setHex(0x2ecc71);
                tObj.buildingGroup.visible = true; 
                tObj.particles.active = false;
                
                const stateKey = `wild`;
                if (tObj.currentType !== stateKey) {
                    while(tObj.buildingGroup.children.length > 0){ 
                        tObj.buildingGroup.remove(tObj.buildingGroup.children[0]); 
                    }
                    const newModel = createBuildingMesh('wild', 0);
                    tObj.buildingGroup.add(newModel);
                    tObj.currentType = stateKey;
                }

                const canUnlock = gameState.rank >= reqRank;
                if (canUnlock) {
                     overlay.innerHTML = `<div class="lock-icon">üîí</div>`;
                } else {
                    overlay.innerHTML = "";
                }
                return;
            } else {
                // ÈñãÊãìÂú∞: Âú∞Èù¢„ÅØ„Ç∞„É¨„Éº„ÄÅ„Çø„Ç§„É´„ÅØÁôΩ
                ground.material.color.setHex(0x555555);
                mesh.material.color.setHex(0xecf0f1);
            }
            
            if (selectedTileIndex === i) {
                mesh.material.emissive.setHex(0x3498db);
                mesh.material.emissiveIntensity = 0.3;
            } else {
                mesh.material.emissive.setHex(0x000000);
            }

            if (tile.type) {
                tObj.buildingGroup.visible = true;
                
                // 3D„É¢„Éá„É´Êõ¥Êñ∞
                const stateKey = `${tile.type}_${tile.level}`;
                if (tObj.currentType !== stateKey) {
                    while(tObj.buildingGroup.children.length > 0){ 
                        tObj.buildingGroup.remove(tObj.buildingGroup.children[0]); 
                    }
                    const newModel = createBuildingMesh(tile.type, tile.level);
                    tObj.buildingGroup.add(newModel);
                    tObj.currentType = stateKey;
                }
                
                if (tile.finishTime) {
                    tObj.particles.active = true;
                    const remaining = Math.max(0, (tile.finishTime - Date.now()));
                    const total = getBuildTime(tile.type, tile.level); 
                    const percent = Math.min(100, Math.max(0, 100 - (remaining / total * 100)));
                    
                    overlay.innerHTML = `
                        <div class="tile-timer">${formatTimeShort(remaining/1000)}</div>
                        <div class="progress-bar-container"><div class="progress-fill" style="width:${percent}%"></div></div>
                    `;
                } else {
                    tObj.particles.active = false;
                    
                    let content = "";
                    let hasResource = false;
                    let maxRes = ""; let maxVal = 0;
                    const canCollect = (Date.now() - (tile.lastCollectTime || 0)) >= CONFIG.collectCooldown;

                    if(tile.stored && canCollect) {
                        for(let r in tile.stored) {
                            if(tile.stored[r] >= 1) {
                                hasResource = true;
                                if(tile.stored[r] > maxVal) { maxVal = tile.stored[r]; maxRes = r; }
                            }
                        }
                    }
                    if (hasResource) {
                        const icon = maxRes=='money'?'üí∞':maxRes=='food'?'üåæ':maxRes=='wood'?'üå≤':maxRes=='stone'?'ü™®':'üî©';
                        content = `<div class="harvest-bubble" onclick="collectResourceUI(${i}, event)">${icon}</div>`;
                    }
                    overlay.innerHTML = content;
                }
            } else {
                // Á©∫„ÅçÂú∞ (ÈñãÊãìÊ∏à„Åø„Å†„ÅåÂª∫Áâ©„Å™„Åó)
                tObj.buildingGroup.visible = false;
                tObj.particles.active = false;
                tObj.currentType = null;
                overlay.innerHTML = "";
            }
        });
    }
    
    function gameLogicLoop() {
        const now = Date.now();
        let dirty = false;

        gameState.tiles.forEach(tile => {
            if (tile.unlocked) {
                if (tile.finishTime && now >= tile.finishTime) {
                    tile.level++;
                    tile.finishTime = null;
                    const xp = Math.floor(getBuildTime(tile.type, tile.level-1) / 1000);
                    addXP(xp);
                    dirty = true;
                    if(selectedTileIndex !== null) updatePanelUI();
                }
                
                if (tile.type && tile.level > 0 && !tile.finishTime) {
                    const b = BUILDINGS[tile.type];
                    const caps = getStorageCapacity(tile.type, tile.level);
                    for (let r in b.prod) {
                        if (b.prod[r] > 0) {
                            const amount = (b.prod[r] * tile.level * Math.pow(1.05, tile.level - 1));
                            if (!tile.stored[r]) tile.stored[r] = 0;
                            if (tile.stored[r] < caps[r]) {
                                tile.stored[r] = Math.min(caps[r], tile.stored[r] + amount);
                                if(Math.floor(tile.stored[r]) >= 1) dirty = true;
                            }
                        }
                    }
                }
            }
        });

        if(dirty || (now % 1000 < 100)) { 
            sync3DState();
        }
        updateHeader();
    }

    function onPointerDown(event) {
        pointerDownPos.set(event.clientX, event.clientY);
        isDragging = false;
    }

    function onPointerMove(event) {
        if (Math.abs(event.clientX - pointerDownPos.x) > 5 || Math.abs(event.clientY - pointerDownPos.y) > 5) {
            isDragging = true;
        }
    }

    function onPointerUp(event) {
        if (isDragging) return;

        event.preventDefault();
        
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {
            let target = intersects[0].object;
            while(target && !target.userData.index && target.parent) {
                target = target.parent;
            }

            if (target && target.userData.index !== undefined) {
                const idx = target.userData.index;
                const collected = collectResource(idx);
                if (!collected) {
                     selectTile(idx);
                }
            }
        } else {
            closePanel();
        }
    }
    
    window.collectResourceUI = function(index, e) {
        e.stopPropagation();
        collectResource(index);
    };

    function selectTile(index) {
        selectedTileIndex = index;
        sync3DState(); 
        showPanel(index);
    }
    
    function closePanel() {
        selectedTileIndex = null;
        document.getElementById('control-panel').classList.remove('active');
        sync3DState();
    }

    function formatTimeShort(s){ if(s<60)return`${Math.floor(s)}s`;if(s<3600)return`${Math.floor(s/60)}m`;return`${Math.floor(s/3600)}h`; }
    function formatTime(s){ if(s<60)return`${Math.floor(s)}Áßí`;if(s<3600)return`${Math.floor(s/60)}ÂàÜ${Math.floor(s%60)}Áßí`;return`${Math.floor(s/3600)}ÊôÇÈñì`; }
    
    function getNextRankXP(r){ 
        const base = r * 500;
        if(r >= 10) return base * 4;
        return base; 
    }
    
    function getBuildTime(t,l){ const tl=l+1; if(tl===1)return BUILDINGS[t].baseTime; return Math.floor(BUILDINGS[t].baseTime*Math.pow(tl, 2.8)); }
    
    function getCost(t,l){ const m=Math.pow(1.6,l) * 1.5; const r={}; for(let k in BUILDINGS[t].cost) r[k]=Math.floor(BUILDINGS[t].cost[k]*m); return r; }
    
    function getStorageCapacity(t,l){ const b=BUILDINGS[t], s=CONFIG.storageHours*3600, c={}; for(let r in b.prod) if(b.prod[r]>0) c[r]=b.prod[r]*l*Math.pow(1.05,l-1)*s; return c; }
    
    function getExpandCost(r){ 
        let b=500*Math.pow(1.5,gameState.tiles.filter(t=>t.unlocked).length-4); 
        const reqRank = getRequiredRankForExpansion();
        if(reqRank >= 6) b *= 20;
        
        return {money:Math.floor(b),food:Math.floor(b*0.5),wood:Math.floor(b*0.3),stone:Math.floor(b*0.1),iron:0}; 
    }
    
    function getRequiredRankForExpansion(){ return Math.max(2, gameState.tiles.filter(t=>t.unlocked).length - 2); }
    function checkAfford(c){ for(let k in c) if((gameState.resources[k]||0)<c[k]) return false; return true; }
    function payCost(c){ for(let k in c) gameState.resources[k]-=c[k]; updateHeader(); }
    function addXP(a){ gameState.xp+=a; if(gameState.xp>=getNextRankXP(gameState.rank)){ gameState.xp-=getNextRankXP(gameState.rank); gameState.rank++; document.getElementById('levelup-rank').innerText=gameState.rank; document.getElementById('modal-levelup').style.display='flex'; } }

    function collectResource(index) {
        const t = gameState.tiles[index];
        if(!t || !t.stored) return false;
        
        const now = Date.now();
        if ((now - (t.lastCollectTime || 0)) < CONFIG.collectCooldown) {
            return false;
        }

        let total = 0, txt = "";
        for(let r in t.stored) {
            const val = Math.floor(t.stored[r]);
            if(val > 0) {
                gameState.resources[r] += val;
                t.stored[r] = 0;
                total += val;
                const icon = r=='money'?'üí∞':r=='food'?'üåæ':r=='wood'?'üå≤':r=='stone'?'ü™®':'üî©';
                txt += `${icon}+${val} `;
            }
        }
        if(total > 0) {
            t.lastCollectTime = now;
            updateHeader();
            sync3DState(); 
            const overlay = tileMeshes[index].overlayEl;
            const el = document.createElement('div');
            el.className = 'float-text';
            el.innerText = txt;
            overlay.appendChild(el);
            setTimeout(()=>el.remove(), 1000);
            return true;
        }
        return false;
    }

    function showPanel(index) {
        const tile = gameState.tiles[index];
        const p = document.getElementById('control-panel');
        const content = document.getElementById('panel-content');
        p.classList.add('active');
        updatePanelUI();
    }
    
    function updatePanelUI() {
        if(selectedTileIndex === null) return;
        const tile = gameState.tiles[selectedTileIndex];
        const content = document.getElementById('panel-content');
        if(!content) return;

        if (!tile.unlocked) {
            const req = getRequiredRankForExpansion();
            const cost = getExpandCost(gameState.rank);
            const ok = gameState.rank >= req;
            const afford = checkAfford(cost);
            content.innerHTML = `
                <div style="text-align:center;">
                    <p><strong>Êú™ÈñãÊãì„ÅÆÂúüÂú∞</strong></p>
                    <div style="background:#eee; padding:10px; border-radius:5px; text-align:left; font-size:0.9em;">
                        Êù°‰ª∂: „É©„É≥„ÇØ${req} (${ok?'‚úÖ':'‚ùå'})<br>
                        Ë≤ªÁî®: üí∞${cost.money} üåæ${cost.food} üå≤${cost.wood} ü™®${cost.stone}
                    </div>
                    <button class="action-btn" onclick="actExpand()" ${ok&&afford?'':'disabled'}>Êã°Âºµ</button>
                    ${!ok ? '<p style="color:red;font-size:0.8em">„É©„É≥„ÇØ‰∏çË∂≥</p>' : ''}
                </div>`;
            return;
        }
        
        if (!tile.type) {
            let html = "";
            if (gameState.inventory && gameState.inventory.length > 0) {
                html += `<div class="inventory-section"><div class="inventory-title">üì¶ ‰øùÁÆ°Â∫´„Åã„ÇâÂÜçË®≠ÁΩÆ</div>`;
                gameState.inventory.forEach((item, idx) => {
                    const b = BUILDINGS[item.type];
                    const timeSec = getBuildTime(item.type, item.level - 1) / 1000;
                    html += `
                        <div class="building-item" style="background:#fff8e1;">
                            <div class="building-info">
                                <strong>${b.icon} ${b.name} (Lv.${item.level})</strong>
                                <span class="res-cost">‚è≥${formatTime(timeSec)}</span>
                            </div>
                            <button onclick="actRestore(${idx})" style="background-color:#f39c12;">ÈÖçÁΩÆ</button>
                        </div>
                    `;
                });
                html += `</div><div class="inventory-title" style="margin-top:10px;">‚ú® Êñ∞Ë¶èÂª∫Ë®≠</div>`;
            }

            for(let k in BUILDINGS) {
                const b = BUILDINGS[k];
                const c = getCost(k, 0);
                const afford = checkAfford(c);
                let cs = []; for(let r in c) if(c[r]>0) cs.push((r=='money'?'üí∞':r=='food'?'üåæ':r=='wood'?'üå≤':r=='stone'?'ü™®':'üî©')+c[r]);
                html += `
                    <div class="building-item">
                        <div class="building-info">
                            <strong>${b.icon} ${b.name}</strong>
                            <span class="res-cost">${cs.join(' ')}</span>
                            <span class="res-cost">‚è≥${formatTime(getBuildTime(k,0)/1000)}</span>
                        </div>
                        <button onclick="actBuild('${k}')" ${afford?'':'disabled'}>Âª∫Ë®≠</button>
                    </div>`;
            }
            content.innerHTML = html;
            return;
        }
        
        const b = BUILDINGS[tile.type];
        if (tile.finishTime) {
            const rem = Math.max(0, (tile.finishTime - Date.now()));
            content.innerHTML = `
                <div style="text-align:center;">
                    <h3>${b.name} (Lv.${tile.level} -> ${tile.level+1})</h3>
                    <h2 style="color:var(--accent-color)">${formatTime(rem/1000)}</h2>
                    <p>Â∑•‰∫ã‰∏≠...</p>
                    <button class="action-btn store-btn" onclick="actStore()">üì¶ ÂõûÂèéÔºà‰øùÁÆ°Â∫´„Å∏Ôºâ</button>
                </div>`;
        } else {
            const next = tile.level+1;
            const c = getCost(tile.type, tile.level);
            const afford = checkAfford(c);
            const caps = getStorageCapacity(tile.type, tile.level);
            let cs = []; for(let r in c) if(c[r]>0) cs.push((r=='money'?'üí∞':r=='food'?'üåæ':r=='wood'?'üå≤':r=='stone'?'ü™®':'üî©')+c[r]);
            
            let prodInfo = ""; let storeInfo = "";
            for(let r in b.prod) if(b.prod[r]>0) {
                const val = b.prod[r]*tile.level*Math.pow(1.05, tile.level-1);
                prodInfo += `${(r=='money'?'üí∞':r=='food'?'üåæ':r=='wood'?'üå≤':r=='stone'?'ü™®':'üî©')}${val.toFixed(1)}/s `;
                storeInfo += `<div>${(r=='money'?'üí∞':r=='food'?'üåæ':r=='wood'?'üå≤':r=='stone'?'ü™®':'üî©')} ${Math.floor(tile.stored[r])}/${Math.floor(caps[r])}</div>`;
            }

            content.innerHTML = `
                <div style="text-align:center;">
                    <h3>${b.name} (Lv.${tile.level})</h3>
                    <div style="background:#f0f0f0; padding:5px; border-radius:5px; margin-bottom:5px;">
                        <strong>ÁîüÁî£Âäõ:</strong><br>${prodInfo}
                    </div>
                    <div style="background:#e8f4f8; padding:5px; border-radius:5px; margin-bottom:10px;">
                        <strong>Ë≤ØËîµÂ∫´:</strong><br>${storeInfo}
                    </div>
                    <div style="text-align:left; font-size:0.9em; margin-bottom:5px;">
                         <strong>LvUPË≤ªÁî®:</strong> ${cs.join(' ')}<br>
                         <strong>ÊôÇÈñì:</strong> ${formatTime(getBuildTime(tile.type, tile.level)/1000)}
                    </div>
                    <button class="action-btn" onclick="actBuild('${tile.type}')" ${afford?'':'disabled'}>„É¨„Éô„É´„Ç¢„ÉÉ„Éó</button>
                    <button class="action-btn store-btn" onclick="actStore()">üì¶ ÂõûÂèéÔºà‰øùÁÆ°Â∫´„Å∏Ôºâ</button>
                </div>`;
        }
    }

    window.actBuild = function(type) {
        if(selectedTileIndex===null) return;
        const t = gameState.tiles[selectedTileIndex];
        const lv = t.type===type ? t.level : 0;
        const c = getCost(type, lv);
        if(checkAfford(c)) {
            payCost(c);
            t.type = type;
            t.finishTime = Date.now() + getBuildTime(type, lv);
            t.stored = {};
            saveGame();
            sync3DState();
            updatePanelUI();
        }
    }
    
    window.actStore = function() {
        if(selectedTileIndex===null) return;
        const t = gameState.tiles[selectedTileIndex];
        if(!t.type) return;

        collectResource(selectedTileIndex);

        gameState.inventory.push({ type: t.type, level: t.level });

        t.type = null;
        t.level = 0;
        t.finishTime = null;
        t.stored = {};
        
        saveGame();
        sync3DState();
        updatePanelUI();
    };

    window.actRestore = function(invIndex) {
        if(selectedTileIndex===null) return;
        if(invIndex < 0 || invIndex >= gameState.inventory.length) return;

        const item = gameState.inventory[invIndex];
        const t = gameState.tiles[selectedTileIndex];

        gameState.inventory.splice(invIndex, 1);

        t.type = item.type;
        t.level = Math.max(0, item.level - 1); 
        t.finishTime = Date.now() + getBuildTime(item.type, t.level);
        t.stored = {};

        saveGame();
        sync3DState();
        updatePanelUI();
    };
    
    window.actExpand = function() {
        if(selectedTileIndex===null) return;
        const c = getExpandCost(gameState.rank);
        if(checkAfford(c)) {
            payCost(c);
            gameState.tiles[selectedTileIndex].unlocked = true;
            saveGame();
            sync3DState();
            updatePanelUI();
        }
    }

    function updateHeader() {
        for(let k in gameState.resources) document.getElementById('display-'+k).innerText = Math.floor(gameState.resources[k]).toLocaleString();
        document.getElementById('display-rank').innerText = gameState.rank;
        document.getElementById('display-next-xp').innerText = (getNextRankXP(gameState.rank)-gameState.xp).toLocaleString();
        document.getElementById('display-xp-bar').style.width = Math.min(100, (gameState.xp/getNextRankXP(gameState.rank))*100)+'%';
    }

    function onWindowResize() {
        const c = document.getElementById('game-container');
        if (!c) return;
        const width = c.clientWidth || window.innerWidth;
        const height = c.clientHeight || window.innerHeight;
        const aspect = width / height;
        const d = 10;
        
        if (camera && renderer) {
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }
    }

    function saveGame() {
        try {
            gameState.lastSaveTime = Date.now();
            localStorage.setItem('kingdomBuilder3DSave', JSON.stringify(gameState));
        } catch (e) {}
    }

    function loadGame() {
        try {
            const s = localStorage.getItem('kingdomBuilder3DSave');
            if(s) {
                const d = JSON.parse(s);
                gameState = { ...gameState, ...d };
                const now = Date.now();
                const sec = (now - gameState.lastSaveTime)/1000;
                if(sec > 10) {
                    let rep = ""; let built = 0; let earn = {};
                    gameState.tiles.forEach(t => {
                        if(t.finishTime && t.finishTime <= now) { t.level++; t.finishTime=null; built++; gameState.xp+=Math.floor(getBuildTime(t.type,t.level-1)/1000); }
                        if(t.type && t.level>0 && !t.finishTime) {
                            const b=BUILDINGS[t.type]; const caps=getStorageCapacity(t.type,t.level);
                            for(let r in b.prod) if(b.prod[r]>0) {
                                if(!earn[r]) earn[r]=0;
                                const add = Math.min(caps[r]-(t.stored[r]||0), b.prod[r]*t.level*Math.pow(1.05,t.level-1)*sec);
                                if(add>0) { t.stored[r]=(t.stored[r]||0)+add; earn[r]+=add; }
                            }
                        }
                    });
                    if(built>0) rep+=`<div>üèóÔ∏è ${built}‰ª∂ÂÆå‰∫Ü</div>`;
                    for(let r in earn) if(earn[r]>1) rep+=`<div>+${Math.floor(earn[r]).toLocaleString()} ${r}</div>`;
                    if(rep) { document.getElementById('offline-report').innerHTML=rep; document.getElementById('modal-offline').style.display='flex'; }
                }
                gameState.lastSaveTime = now;
            }
        } catch (e) {}
    }
    
    window.closeModal = function(id) { document.getElementById(id).style.display='none'; }

    window.onload = function() {
        log("Window onload");
        setTimeout(init, 100);
    };

</script>
</body>
</html>
