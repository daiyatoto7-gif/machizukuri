<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kingdom Builder 3D</title>
    
    <!-- ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¹ã‚¿ã‚¤ãƒ« -->
    <style>
        #debug-log {
            position: fixed; top: 0; left: 0; width: 100%; height: auto;
            max-height: 100px; overflow-y: scroll;
            background: rgba(0,0,0,0.7); color: lime;
            font-family: monospace; font-size: 10px;
            z-index: 9999; pointer-events: none;
            padding: 5px; box-sizing: border-box;
            display: none; /* é€šå¸¸ã¯éè¡¨ç¤º */
        }
        .error-msg { color: #ff5555; }
    </style>

    <!-- Three.js CDN (unpkgã«å¤‰æ›´) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    
    <style>
        :root {
            --bg-color: #f0f2f5;
            --panel-bg: #ffffff;
            --accent-color: #3498db;
            --text-color: #2c3e50;
            --xp-color: #f1c40f;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            overflow: hidden; /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç¦æ­¢ */
            user-select: none;
            height: 100vh;
            width: 100vw;
        }

        /* ãƒ˜ãƒƒãƒ€ãƒ¼ */
        header {
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            padding: 5px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            position: fixed;
            top: 0;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }
        header > * { pointer-events: auto; }

        .status-bar {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .rank-badge {
            background: var(--accent-color);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.9em;
        }
        .xp-container {
            width: 150px;
            height: 10px;
            background: #eee;
            border-radius: 5px;
            overflow: hidden;
        }
        .xp-fill {
            height: 100%;
            background: var(--xp-color);
            width: 0%;
            transition: width 0.5s;
        }
        .resource-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            font-size: 0.9em;
            justify-content: center;
            padding: 0 10px;
            background: rgba(255,255,255,0.8);
            border-radius: 10px;
        }

        /* 3Dã‚­ãƒ£ãƒ³ãƒã‚¹ã‚³ãƒ³ãƒ†ãƒŠ */
        #game-container {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 1;
            background: radial-gradient(circle at center, #dcecf5 0%, #b0c4de 100%);
        }

        /* UIã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ãƒ¬ã‚¤ãƒ¤ãƒ¼ */
        #ui-overlay-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            overflow: hidden;
        }

        /* è¿½å¾“UIãƒ‘ãƒ¼ãƒ„ */
        .overlay-item {
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* å»ºè¨­ã‚¿ã‚¤ãƒãƒ¼ */
        .tile-timer {
            font-size: 10px;
            font-weight: bold;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 2px 4px;
            border-radius: 4px;
            margin-bottom: 2px;
            white-space: nowrap;
        }
        .progress-bar-container {
            width: 40px; height: 4px; background: rgba(255,255,255,0.5); 
            border-radius: 2px; overflow: hidden;
        }
        .progress-fill { height: 100%; background: #2ecc71; width: 0%; transition: width 0.2s linear; }

        /* è³‡æºå›åãƒãƒ–ãƒ« */
        .harvest-bubble {
            background: white;
            border: 2px solid #f39c12;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            animation: bounce 1s infinite alternate;
            cursor: pointer;
        }
        @keyframes bounce { from { transform: translateY(0); } to { transform: translateY(-5px); } }

        /* ãƒ­ãƒƒã‚¯ã‚¢ã‚¤ã‚³ãƒ³ */
        .lock-icon {
            font-size: 24px;
            opacity: 0.6;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ†ã‚­ã‚¹ãƒˆ */
        .float-text {
            position: absolute;
            color: #27ae60;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 0 #fff;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
            z-index: 100;
        }
        @keyframes floatUp { 
            0% { transform: translate(-50%, -50%); opacity: 1; } 
            100% { transform: translate(-50%, -150%); opacity: 0; } 
        }

        /* æ“ä½œãƒ‘ãƒãƒ« */
        #control-panel {
            position: absolute;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            width: 90%; max-width: 400px;
            max-height: 40vh;
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            z-index: 30;
            display: none;
            flex-direction: column;
        }
        #control-panel.active { display: flex; }

        #panel-header {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 2px solid var(--bg-color);
            padding-bottom: 10px; margin-bottom: 10px;
        }
        #panel-title { margin: 0; font-size: 1.1em; color: var(--accent-color); }
        .close-btn { cursor: pointer; font-weight: bold; padding: 0 5px; color: #999; }
        #panel-content { flex: 1; overflow-y: auto; padding-right: 5px; }

        .building-item {
            display: flex; justify-content: space-between; align-items: center;
            border: 1px solid #eee; padding: 8px; border-radius: 6px;
            margin-bottom: 8px; font-size: 0.9em;
        }
        .building-info { display: flex; flex-direction: column; gap: 2px; }
        .res-cost { font-size: 0.85em; color: #666; }

        button {
            padding: 8px 12px; border: none; border-radius: 4px;
            background-color: var(--accent-color); color: white;
            font-weight: bold; cursor: pointer; font-size: 0.9em;
        }
        button.action-btn { width: 100%; padding: 12px; font-size: 1em; margin-top: 5px; }
        button.store-btn { background-color: var(--text-color); margin-top: 10px; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }

        /* ä¿ç®¡åº«ãƒªã‚¹ãƒˆ */
        .inventory-section {
            margin-top: 15px;
            border-top: 2px dashed #eee;
            padding-top: 10px;
        }
        .inventory-title {
            font-size: 0.9em; font-weight: bold; color: #7f8c8d; margin-bottom: 5px;
        }

        /* ãƒ¢ãƒ¼ãƒ€ãƒ« */
        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 100;
        }
        .modal-content {
            background: white; padding: 30px; border-radius: 10px; text-align: center;
            max-width: 400px; box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

    </style>
</head>
<body>

<!-- ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°è¡¨ç¤ºç”¨ï¼ˆé€šå¸¸éè¡¨ç¤ºã€ã‚¨ãƒ©ãƒ¼æ™‚è¡¨ç¤ºï¼‰ -->
<div id="debug-log"></div>

<header>
    <div class="status-bar">
        <div class="rank-badge">RANK <span id="display-rank">1</span></div>
        <div class="xp-container">
            <div class="xp-fill" id="display-xp-bar"></div>
        </div>
        <div style="font-size:0.8em; color:#7f8c8d;">Next: <span id="display-next-xp">0</span> XP</div>
    </div>
    <div class="resource-bar">
        <div class="res-item">ğŸ’° <span id="display-money">0</span></div>
        <div class="res-item">ğŸŒ¾ <span id="display-food">0</span></div>
        <div class="res-item">ğŸŒ² <span id="display-wood">0</span></div>
        <div class="res-item">ğŸª¨ <span id="display-stone">0</span></div>
        <div class="res-item">ğŸ”© <span id="display-iron">0</span></div>
    </div>
</header>

<div id="game-container"></div>
<div id="ui-overlay-layer"></div>

<div id="control-panel">
    <div id="panel-header">
        <h2 id="panel-title">ã‚¿ã‚¤ãƒ«é¸æŠ</h2>
        <div class="close-btn" onclick="closePanel()">âœ•</div>
    </div>
    <div id="panel-content"></div>
</div>

<div id="modal-offline" class="modal">
    <div class="modal-content">
        <h3>ãŠã‹ãˆã‚Šãªã•ã„ï¼</h3>
        <p>ä¸åœ¨ã®é–“ã«ç”Ÿç”£ã•ã‚ŒãŸè³‡æºãŒ<br>è²¯è”µåº«ã«ä¿ç®¡ã•ã‚Œã¾ã—ãŸã€‚</p>
        <div style="text-align:left; background:#f9f9f9; padding:10px; border-radius:5px; margin:10px 0;">
            <div id="offline-report"></div>
        </div>
        <button onclick="closeModal('modal-offline')" class="action-btn">å†é–‹ã™ã‚‹</button>
    </div>
</div>

<div id="modal-levelup" class="modal">
    <div class="modal-content">
        <h3 style="color:var(--accent-color);">ğŸ‰ ãƒ©ãƒ³ã‚¯ã‚¢ãƒƒãƒ—ï¼ ğŸ‰</h3>
        <p style="font-size:1.2em; font-weight:bold;">RANK <span id="levelup-rank"></span> ã«ãªã‚Šã¾ã—ãŸï¼</p>
        <button onclick="closeModal('modal-levelup')" class="action-btn">é–‰ã˜ã‚‹</button>
    </div>
</div>

<script>
    // --- ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½ ---
    function log(msg, isError = false) {
        const el = document.getElementById('debug-log');
        if (!el) return;
        const line = document.createElement('div');
        line.textContent = `> ${msg}`;
        if (isError) {
            line.className = 'error-msg';
            el.style.display = 'block'; 
            console.error(msg);
        } else {
            console.log(msg);
        }
        el.appendChild(line);
        el.scrollTop = el.scrollHeight;
    }

    window.onerror = function(message, source, lineno, colno, error) {
        log(`Global Error: ${message} at line ${lineno}`, true);
        return false;
    };

    // --- ãƒ‡ãƒ¼ã‚¿ãƒ»è¨­å®š ---
    const CONFIG = {
        gridSize: 25, // 5x5
        fps: 30, // æç”»æ›´æ–°ç”¨
        autoSaveInterval: 5000,
        // åˆæœŸè§£æ”¾ã‚¿ã‚¤ãƒ«: ä¸­å¤®æ¨ªé•·6ãƒã‚¹ (6,7,8, 11,12,13)
        initialUnlocked: [6, 7, 8, 11, 12, 13],
        storageHours: 8,
        collectCooldown: 30000 // 30ç§’
    };

    const BUILDINGS = {
        house: { name: "æ°‘å®¶", icon: "ğŸ ", prod: { money: 2 }, cost: { money: 20, food: 10 }, baseTime: 2000 },
        farm: { name: "ç•‘", icon: "ğŸŒ¾", prod: { food: 2 }, cost: { money: 30, wood: 10 }, baseTime: 2000 },
        lumber: { name: "ä¼æ¡æ‰€", icon: "ğŸŒ²", prod: { wood: 1 }, cost: { money: 50, food: 20 }, baseTime: 3000 },
        quarry: { name: "æ¡çŸ³å ´", icon: "ğŸª¨", prod: { stone: 1 }, cost: { money: 100, food: 50, wood: 50 }, baseTime: 4000 },
        mine: { name: "é‰±å±±", icon: "ğŸ”©", prod: { iron: 1 }, cost: { money: 200, food: 100, wood: 100, stone: 50 }, baseTime: 5000 },
        market: { name: "å¸‚å ´", icon: "âš–ï¸", prod: { money: 10 }, cost: { money: 500, food: 200, wood: 200, stone: 50 }, baseTime: 6000 },
        blacksmith: { name: "é›å†¶å±‹", icon: "âš”ï¸", prod: { money: 5, iron: 2 }, cost: { money: 800, food: 300, wood: 300, stone: 200, iron: 100 }, baseTime: 7000 }
    };
    
    for(let k in BUILDINGS) {
        const b = BUILDINGS[k];
        for(let r of ['money','food','wood','stone','iron']) {
            if(!b.prod[r]) b.prod[r] = 0;
            if(!b.cost[r]) b.cost[r] = 0;
        }
    }

    let gameState = {
        rank: 1, xp: 0,
        resources: { money: 200, food: 100, wood: 50, stone: 0, iron: 0 },
        tiles: [],
        inventory: [], // ä¿ç®¡åº«: { type, level }
        lastSaveTime: Date.now()
    };

    let selectedTileIndex = null;

    // --- 3Dç”¨å¤‰æ•° ---
    let scene, camera, renderer;
    let raycaster, mouse;
    let tileMeshes = []; 
    
    let pointerDownPos = new THREE.Vector2();
    let isDragging = false;

    // --- åˆæœŸåŒ– ---
    function init() {
        log("Game initializing...");

        if (typeof THREE === 'undefined') {
            document.body.innerHTML = '<div style="padding:20px;text-align:center;color:red;"><h3>ã‚¨ãƒ©ãƒ¼: 3Dãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã‚ã¾ã›ã‚“ã€‚</h3><p>å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚</p></div>';
            return;
        }

        loadGame();
        
        if (gameState.tiles.length !== CONFIG.gridSize) {
            gameState.tiles = Array(CONFIG.gridSize).fill(null).map((_, i) => ({
                type: null, level: 0, finishTime: null, 
                unlocked: CONFIG.initialUnlocked.includes(i),
                stored: {},
                lastCollectTime: 0
            }));
        } else {
             gameState.tiles.forEach(t => { 
                 if(!t.stored) t.stored = {}; 
                 if(t.lastCollectTime === undefined) t.lastCollectTime = 0;
             });
        }
        if(!gameState.inventory) gameState.inventory = [];

        try {
            init3D();
        } catch (e) {
            log(`3D Init Error: ${e.message}`, true);
            alert("3Dè¡¨ç¤ºã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
            return;
        }

        updateHeader();
        
        requestAnimationFrame(animate3D);
        setInterval(gameLogicLoop, 1000); 
        setInterval(saveGame, CONFIG.autoSaveInterval);
        setInterval(updatePanelUI, 500);

        log("Game loop started.");
    }

    // --- Three.js ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— ---
    function init3D() {
        const container = document.getElementById('game-container');
        if(!container) throw new Error("Game container not found");
        
        let width = container.clientWidth;
        let height = container.clientHeight;

        if (width === 0 || height === 0) {
            width = window.innerWidth;
            height = window.innerHeight;
        }

        if (width === 0 || height === 0) {
            setTimeout(init3D, 100);
            return;
        }

        scene = new THREE.Scene();
        
        const aspect = width / height;
        const d = 10;
        
        camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(20, 20, 20); 
        camera.lookAt(scene.position);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        const pixelRatio = Math.max(window.devicePixelRatio, 2.0);
        renderer.setPixelRatio(pixelRatio);
        
        renderer.setSize(width, height);
        renderer.shadowMap.enabled = true;
        renderer.setClearColor( 0x000000, 0 ); 
        container.appendChild(renderer.domElement);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        createTiles();

        window.addEventListener('resize', onWindowResize, false);
        
        renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
        renderer.domElement.addEventListener('pointerup', onPointerUp, false);
        renderer.domElement.addEventListener('pointermove', onPointerMove, false);
        
        setTimeout(onWindowResize, 100);
    }

    function createTiles() {
        const geometry = new THREE.BoxGeometry(1.8, 0.5, 1.8);
        const lockedMat = new THREE.MeshStandardMaterial({ color: 0x95a5a6 });
        const unlockedMat = new THREE.MeshStandardMaterial({ color: 0xecf0f1 });
        
        const offset = 2; 
        const start = -offset * 2;

        for (let i = 0; i < 25; i++) {
            const row = Math.floor(i / 5);
            const col = i % 5;
            const x = start + col * offset;
            const z = start + row * offset;

            const mesh = new THREE.Mesh(geometry, unlockedMat.clone());
            mesh.position.set(x, 0, z);
            mesh.receiveShadow = true;
            mesh.userData = { index: i, type: 'tile' };
            scene.add(mesh);

            // å»ºç‰©ç”¨ã‚°ãƒ«ãƒ¼ãƒ— (ä¸­èº«ã‚’å…¥ã‚Œæ›¿ãˆã‚‹)
            const bGroup = new THREE.Group();
            bGroup.position.set(0, 0.25, 0); // åœ°é¢ã‚ˆã‚Šå°‘ã—ä¸Š
            mesh.add(bGroup);

            const overlay = document.createElement('div');
            overlay.className = 'overlay-item';
            document.getElementById('ui-overlay-layer').appendChild(overlay);

            const particles = new ParticleSystem(mesh.position, scene);

            tileMeshes.push({ 
                mesh: mesh, 
                buildingGroup: bGroup, 
                overlayEl: overlay,
                particles: particles,
                currentType: null // çŠ¶æ…‹ç®¡ç†ç”¨
            });
        }
        
        sync3DState();
    }

    class ParticleSystem {
        constructor(position, scene) {
            this.origin = position.clone().add(new THREE.Vector3(0, 1, 0));
            this.particles = [];
            this.scene = scene;
            this.active = false;
            
            this.geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            this.mat = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true });
        }

        update() {
            if (!this.active && this.particles.length === 0) return;

            if (this.active && Math.random() < 0.2) {
                const mesh = new THREE.Mesh(this.geo, this.mat.clone());
                const offset = new THREE.Vector3((Math.random()-0.5)*1.5, 0, (Math.random()-0.5)*1.5);
                mesh.position.copy(this.origin).add(offset);
                this.scene.add(mesh);
                this.particles.push({ 
                    mesh: mesh, 
                    vel: new THREE.Vector3(0, 0.05 + Math.random()*0.05, 0), 
                    life: 1.0 
                });
            }

            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.mesh.position.add(p.vel);
                p.mesh.rotation.x += 0.1;
                p.mesh.rotation.y += 0.1;
                p.life -= 0.02;
                p.mesh.material.opacity = p.life;

                if (p.life <= 0) {
                    this.scene.remove(p.mesh);
                    this.particles.splice(i, 1);
                }
            }
        }
    }

    // --- ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£ãƒ«ãªå»ºç‰©ç”Ÿæˆ ---
    function createBuildingMesh(type, level) {
        const group = new THREE.Group();
        const scale = 1 + (level * 0.05); // ãƒ¬ãƒ™ãƒ«ã§å°‘ã—å¤§ãã
        group.scale.set(scale, scale, scale);

        const matRoof = new THREE.MeshStandardMaterial({ color: 0xe74c3c }); // èµ¤
        const matWall = new THREE.MeshStandardMaterial({ color: 0xf39c12 }); // ã‚ªãƒ¬ãƒ³ã‚¸å£
        const matWood = new THREE.MeshStandardMaterial({ color: 0x8e44ad }); // ç´«(å¹¹) -> èŒ¶è‰²ã£ã½ãä¿®æ­£ã—ãŸã„ãŒã‚¢ã‚¯ã‚»ãƒ³ãƒˆã‚«ãƒ©ãƒ¼ä½¿ç”¨
        const matLeaf = new THREE.MeshStandardMaterial({ color: 0x2ecc71 }); // ç·‘
        const matStone = new THREE.MeshStandardMaterial({ color: 0x7f8c8d }); // ã‚°ãƒ¬ãƒ¼
        const matDark = new THREE.MeshStandardMaterial({ color: 0x34495e }); // æ¿ƒã„ã‚°ãƒ¬ãƒ¼
        const matTent = new THREE.MeshStandardMaterial({ color: 0x3498db }); // é’

        switch(type) {
            case 'house':
                // å£
                const wall = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.8), matWall);
                wall.position.y = 0.3;
                wall.castShadow = true;
                group.add(wall);
                // å±‹æ ¹
                const roof = new THREE.Mesh(new THREE.ConeGeometry(0.7, 0.5, 4), matRoof);
                roof.position.y = 0.85;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                group.add(roof);
                break;

            case 'farm':
                // åœŸå°
                const soil = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.1, 1.0), new THREE.MeshStandardMaterial({color:0x8B4513}));
                soil.position.y = 0.05;
                soil.receiveShadow = true;
                group.add(soil);
                // ä½œç‰©
                for(let i=0; i<4; i++) {
                    const crop = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), matLeaf);
                    crop.position.set((i%2 ? 0.3 : -0.3), 0.25, (i<2 ? 0.3 : -0.3));
                    group.add(crop);
                }
                break;

            case 'lumber':
                // æœ¨1
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 0.4), new THREE.MeshStandardMaterial({color:0x8B4513}));
                trunk.position.y = 0.2;
                group.add(trunk);
                const leaves = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 8), matLeaf);
                leaves.position.y = 0.7;
                group.add(leaves);
                // åˆ‡ã‚Šæ ª
                const stump = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.2), new THREE.MeshStandardMaterial({color:0x8B4513}));
                stump.position.set(0.4, 0.1, 0.4);
                group.add(stump);
                break;

            case 'quarry':
                // å²©å±± (Dodecahedron)
                const rock1 = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4), matStone);
                rock1.position.y = 0.3;
                group.add(rock1);
                const rock2 = new THREE.Mesh(new THREE.DodecahedronGeometry(0.3), matStone);
                rock2.position.set(0.4, 0.2, 0.3);
                group.add(rock2);
                break;

            case 'mine':
                // æ 
                const frame = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.2), new THREE.MeshStandardMaterial({color:0x5d4037}));
                frame.position.set(0, 0.3, -0.2);
                group.add(frame);
                // ç©´
                const hole = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.1), new THREE.MeshStandardMaterial({color:0x000000}));
                hole.position.set(0, 0.25, -0.1);
                group.add(hole);
                break;

            case 'market':
                // æŸ±
                const post = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.4, 0.8), new THREE.MeshStandardMaterial({color:0xecf0f1}));
                post.position.y = 0.2;
                group.add(post);
                // ãƒ†ãƒ³ãƒˆå±‹æ ¹
                const tent = new THREE.Mesh(new THREE.ConeGeometry(0.7, 0.5, 4), matTent);
                tent.position.y = 0.65;
                tent.rotation.y = Math.PI / 4;
                group.add(tent);
                break;

            case 'blacksmith':
                // å»ºç‰©
                const house = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.5, 0.6), matDark);
                house.position.y = 0.25;
                group.add(house);
                // ç…™çª
                const chimney = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), new THREE.MeshStandardMaterial({color:0x2c3e50}));
                chimney.position.set(0.3, 0.4, 0.2);
                group.add(chimney);
                break;
        }
        return group;
    }

    // --- ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— ---
    function animate3D() {
        requestAnimationFrame(animate3D);
        tileMeshes.forEach(t => t.particles.update());
        if(renderer && scene && camera) {
            renderer.render(scene, camera);
        }
        updateOverlayPositions();
    }

    function updateOverlayPositions() {
        if (!camera) return;
        const width = window.innerWidth;
        const height = window.innerHeight;
        const widthHalf = width / 2;
        const heightHalf = height / 2;

        tileMeshes.forEach((t, i) => {
            const tileData = gameState.tiles[i];
            const pos = t.mesh.position.clone();
            if (tileData.unlocked) pos.y += 1.5; 
            else pos.y += 0.5;

            pos.project(camera);

            const x = (pos.x * widthHalf) + widthHalf;
            const y = -(pos.y * heightHalf) + heightHalf;

            if (x < -50 || x > width + 50 || y < -50 || y > height + 50) {
                t.overlayEl.style.display = 'none';
            } else {
                t.overlayEl.style.display = 'flex';
                t.overlayEl.style.left = `${x}px`;
                t.overlayEl.style.top = `${y}px`;
            }
        });
    }

    // --- çŠ¶æ…‹åŒæœŸ ---
    function sync3DState() {
        const reqRank = getRequiredRankForExpansion();
        const now = Date.now();
        
        gameState.tiles.forEach((tile, i) => {
            const tObj = tileMeshes[i];
            const mesh = tObj.mesh;
            const overlay = tObj.overlayEl;

            // ãƒ­ãƒƒã‚¯/ã‚¢ãƒ³ãƒ­ãƒƒã‚¯
            if (!tile.unlocked) {
                mesh.material.color.setHex(0x95a5a6); 
                tObj.buildingGroup.visible = false;
                tObj.particles.active = false;
                
                const canUnlock = gameState.rank >= reqRank;
                if (canUnlock) {
                     mesh.material.color.setHex(0xdcdde1); 
                     overlay.innerHTML = `<div class="lock-icon">ğŸ”’</div>`;
                } else {
                    overlay.innerHTML = "";
                }
                return;
            } else {
                mesh.material.color.setHex(0xecf0f1); 
            }
            
            if (selectedTileIndex === i) {
                mesh.material.emissive.setHex(0x3498db);
                mesh.material.emissiveIntensity = 0.3;
            } else {
                mesh.material.emissive.setHex(0x000000);
            }

            // æ–½è¨­è¡¨ç¤º
            if (tile.type) {
                tObj.buildingGroup.visible = true;
                
                // â˜…ãƒ¢ãƒ‡ãƒ«æ›´æ–°: ã‚¿ã‚¤ãƒ—ã‚„ãƒ¬ãƒ™ãƒ«ãŒå¤‰ã‚ã£ãŸã¨ãã ã‘å†ç”Ÿæˆ
                const stateKey = `${tile.type}_${tile.level}`;
                if (tObj.currentType !== stateKey) {
                    // å¤ã„ã‚‚ã®ã‚’å‰Šé™¤
                    while(tObj.buildingGroup.children.length > 0){ 
                        tObj.buildingGroup.remove(tObj.buildingGroup.children[0]); 
                    }
                    // æ–°ã—ã„ã‚‚ã®ã‚’è¿½åŠ 
                    const newModel = createBuildingMesh(tile.type, tile.level);
                    tObj.buildingGroup.add(newModel);
                    tObj.currentType = stateKey;
                }
                
                // å»ºè¨­ä¸­ã‹ã©ã†ã‹
                if (tile.finishTime) {
                    tObj.particles.active = true;
                    const remaining = Math.max(0, (tile.finishTime - Date.now()));
                    const total = getBuildTime(tile.type, tile.level); 
                    const percent = Math.min(100, Math.max(0, 100 - (remaining / total * 100)));
                    
                    overlay.innerHTML = `
                        <div class="tile-timer">${formatTimeShort(remaining/1000)}</div>
                        <div class="progress-bar-container"><div class="progress-fill" style="width:${percent}%"></div></div>
                    `;
                } else {
                    tObj.particles.active = false;
                    
                    // å›åãƒã‚§ãƒƒã‚¯ (30ç§’ãƒ«ãƒ¼ãƒ«)
                    let content = "";
                    let hasResource = false;
                    let maxRes = ""; let maxVal = 0;
                    const canCollect = (now - (tile.lastCollectTime || 0)) >= CONFIG.collectCooldown;

                    if(tile.stored && canCollect) {
                        for(let r in tile.stored) {
                            if(tile.stored[r] >= 1) {
                                hasResource = true;
                                if(tile.stored[r] > maxVal) { maxVal = tile.stored[r]; maxRes = r; }
                            }
                        }
                    }
                    if (hasResource) {
                        const icon = maxRes=='money'?'ğŸ’°':maxRes=='food'?'ğŸŒ¾':maxRes=='wood'?'ğŸŒ²':maxRes=='stone'?'ğŸª¨':'ğŸ”©';
                        content = `<div class="harvest-bubble" onclick="collectResourceUI(${i}, event)">${icon}</div>`;
                    }
                    overlay.innerHTML = content;
                }
            } else {
                tObj.buildingGroup.visible = false;
                tObj.particles.active = false;
                tObj.currentType = null; // ãƒªã‚»ãƒƒãƒˆ
                overlay.innerHTML = "";
            }
        });
    }
    
    // --- ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ ---
    function gameLogicLoop() {
        const now = Date.now();
        let dirty = false;

        gameState.tiles.forEach(tile => {
            if (tile.unlocked) {
                if (tile.finishTime && now >= tile.finishTime) {
                    tile.level++;
                    tile.finishTime = null;
                    const xp = Math.floor(getBuildTime(tile.type, tile.level-1) / 1000);
                    addXP(xp);
                    dirty = true;
                    if(selectedTileIndex !== null) updatePanelUI();
                }
                
                if (tile.type && tile.level > 0 && !tile.finishTime) {
                    const b = BUILDINGS[tile.type];
                    const caps = getStorageCapacity(tile.type, tile.level);
                    for (let r in b.prod) {
                        if (b.prod[r] > 0) {
                            const amount = (b.prod[r] * tile.level * Math.pow(1.05, tile.level - 1));
                            if (!tile.stored[r]) tile.stored[r] = 0;
                            if (tile.stored[r] < caps[r]) {
                                tile.stored[r] = Math.min(caps[r], tile.stored[r] + amount);
                                if(Math.floor(tile.stored[r]) >= 1) dirty = true;
                            }
                        }
                    }
                }
            }
        });

        if(dirty || (now % 1000 < 100)) { 
            sync3DState();
        }
        updateHeader();
    }

    // --- ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ ---
    function onPointerDown(event) {
        pointerDownPos.set(event.clientX, event.clientY);
        isDragging = false;
    }

    function onPointerMove(event) {
        if (Math.abs(event.clientX - pointerDownPos.x) > 5 || Math.abs(event.clientY - pointerDownPos.y) > 5) {
            isDragging = true;
        }
    }

    function onPointerUp(event) {
        if (isDragging) return; // ãƒ‰ãƒ©ãƒƒã‚°ãªã‚‰ç„¡è¦–

        event.preventDefault();
        
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {
            let target = intersects[0].object;
            while(target && !target.userData.index && target.parent) {
                target = target.parent;
            }

            if (target && target.userData.index !== undefined) {
                const idx = target.userData.index;
                const collected = collectResource(idx);
                
                // å›åã—ãªã‹ã£ãŸ(ã§ããªã‹ã£ãŸ)å ´åˆã®ã¿é¸æŠ
                if (!collected) {
                     selectTile(idx);
                }
            }
        } else {
            closePanel();
        }
    }
    
    window.collectResourceUI = function(index, e) {
        e.stopPropagation();
        collectResource(index);
    };

    function selectTile(index) {
        selectedTileIndex = index;
        sync3DState(); 
        showPanel(index);
    }
    
    function closePanel() {
        selectedTileIndex = null;
        document.getElementById('control-panel').classList.remove('active');
        sync3DState();
    }

    // --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ç³» ---
    function formatTimeShort(s){ if(s<60)return`${Math.floor(s)}s`;if(s<3600)return`${Math.floor(s/60)}m`;return`${Math.floor(s/3600)}h`; }
    function formatTime(s){ if(s<60)return`${Math.floor(s)}ç§’`;if(s<3600)return`${Math.floor(s/60)}åˆ†${Math.floor(s%60)}ç§’`;return`${Math.floor(s/3600)}æ™‚é–“`; }
    function getNextRankXP(r){ return r*500; }
    function getBuildTime(t,l){ const tl=l+1; if(tl===1)return BUILDINGS[t].baseTime; return Math.floor(BUILDINGS[t].baseTime*Math.pow(tl, 2.8)); }
    function getCost(t,l){ const m=Math.pow(1.6,l) * 1.5; const r={}; for(let k in BUILDINGS[t].cost) r[k]=Math.floor(BUILDINGS[t].cost[k]*m); return r; }
    function getStorageCapacity(t,l){ const b=BUILDINGS[t], s=CONFIG.storageHours*3600, c={}; for(let r in b.prod) if(b.prod[r]>0) c[r]=b.prod[r]*l*Math.pow(1.05,l-1)*s; return c; }
    function getExpandCost(r){ const b=500*Math.pow(1.5,gameState.tiles.filter(t=>t.unlocked).length-4); return {money:Math.floor(b),food:Math.floor(b*0.5),wood:Math.floor(b*0.3),stone:Math.floor(b*0.1),iron:0}; }
    function getRequiredRankForExpansion(){ return Math.max(2, gameState.tiles.filter(t=>t.unlocked).length - 2); }
    function checkAfford(c){ for(let k in c) if((gameState.resources[k]||0)<c[k]) return false; return true; }
    function payCost(c){ for(let k in c) gameState.resources[k]-=c[k]; updateHeader(); }
    function addXP(a){ gameState.xp+=a; if(gameState.xp>=getNextRankXP(gameState.rank)){ gameState.xp-=getNextRankXP(gameState.rank); gameState.rank++; document.getElementById('levelup-rank').innerText=gameState.rank; document.getElementById('modal-levelup').style.display='flex'; } }

    function collectResource(index) {
        const t = gameState.tiles[index];
        if(!t || !t.stored) return false;
        
        // 30ç§’ãƒã‚§ãƒƒã‚¯
        const now = Date.now();
        if ((now - (t.lastCollectTime || 0)) < CONFIG.collectCooldown) {
            return false;
        }

        let total = 0, txt = "";
        for(let r in t.stored) {
            const val = Math.floor(t.stored[r]);
            if(val > 0) {
                gameState.resources[r] += val;
                t.stored[r] = 0;
                total += val;
                const icon = r=='money'?'ğŸ’°':r=='food'?'ğŸŒ¾':r=='wood'?'ğŸŒ²':r=='stone'?'ğŸª¨':'ğŸ”©';
                txt += `${icon}+${val} `;
            }
        }
        if(total > 0) {
            t.lastCollectTime = now;
            updateHeader();
            sync3DState(); 
            // æ¼”å‡º
            const overlay = tileMeshes[index].overlayEl;
            const el = document.createElement('div');
            el.className = 'float-text';
            el.innerText = txt;
            overlay.appendChild(el);
            setTimeout(()=>el.remove(), 1000);
            return true;
        }
        return false;
    }

    // --- ãƒ‘ãƒãƒ«UI ---
    function showPanel(index) {
        const tile = gameState.tiles[index];
        const p = document.getElementById('control-panel');
        const content = document.getElementById('panel-content');
        p.classList.add('active');
        updatePanelUI();
    }
    
    function updatePanelUI() {
        if(selectedTileIndex === null) return;
        const tile = gameState.tiles[selectedTileIndex];
        const content = document.getElementById('panel-content');
        if(!content) return;

        if (!tile.unlocked) {
            const req = getRequiredRankForExpansion();
            const cost = getExpandCost(gameState.rank);
            const ok = gameState.rank >= req;
            const afford = checkAfford(cost);
            content.innerHTML = `
                <div style="text-align:center;">
                    <p><strong>æœªé–‹æ‹“ã®åœŸåœ°</strong></p>
                    <div style="background:#eee; padding:10px; border-radius:5px; text-align:left; font-size:0.9em;">
                        æ¡ä»¶: ãƒ©ãƒ³ã‚¯${req} (${ok?'âœ…':'âŒ'})<br>
                        è²»ç”¨: ğŸ’°${cost.money} ğŸŒ¾${cost.food} ğŸŒ²${cost.wood} ğŸª¨${cost.stone}
                    </div>
                    <button class="action-btn" onclick="actExpand()" ${ok&&afford?'':'disabled'}>æ‹¡å¼µ</button>
                    ${!ok ? '<p style="color:red;font-size:0.8em">ãƒ©ãƒ³ã‚¯ä¸è¶³</p>' : ''}
                </div>`;
            return;
        }
        
        if (!tile.type) {
            // ç©ºãåœ°: æ–°è¦å»ºè¨­ + ä¿ç®¡åº«ã‹ã‚‰ã®è¨­ç½®
            let html = "";
            
            // ä¿ç®¡åº«ã‚»ã‚¯ã‚·ãƒ§ãƒ³
            if (gameState.inventory && gameState.inventory.length > 0) {
                html += `<div class="inventory-section"><div class="inventory-title">ğŸ“¦ ä¿ç®¡åº«ã‹ã‚‰å†è¨­ç½®</div>`;
                gameState.inventory.forEach((item, idx) => {
                    const b = BUILDINGS[item.type];
                    // å†è¨­ç½®æ™‚é–“ã¯ã€Œãã®ãƒ¬ãƒ™ãƒ«ã¸ã®ã‚¢ãƒƒãƒ—ã‚°ãƒ¬ãƒ¼ãƒ‰æ™‚é–“ã€ã¨ã™ã‚‹ï¼ˆgetBuildTime(type, item.level-1)ï¼‰
                    // â€» Lv1ã®å†è¨­ç½®ã®å ´åˆã¯ getBuildTime(type, 0)
                    const timeSec = getBuildTime(item.type, item.level - 1) / 1000;
                    
                    html += `
                        <div class="building-item" style="background:#fff8e1;">
                            <div class="building-info">
                                <strong>${b.icon} ${b.name} (Lv.${item.level})</strong>
                                <span class="res-cost">â³${formatTime(timeSec)}</span>
                            </div>
                            <button onclick="actRestore(${idx})" style="background-color:#f39c12;">é…ç½®</button>
                        </div>
                    `;
                });
                html += `</div><div class="inventory-title" style="margin-top:10px;">âœ¨ æ–°è¦å»ºè¨­</div>`;
            }

            for(let k in BUILDINGS) {
                const b = BUILDINGS[k];
                const c = getCost(k, 0);
                const afford = checkAfford(c);
                let cs = []; for(let r in c) if(c[r]>0) cs.push((r=='money'?'ğŸ’°':r=='food'?'ğŸŒ¾':r=='wood'?'ğŸŒ²':r=='stone'?'ğŸª¨':'ğŸ”©')+c[r]);
                html += `
                    <div class="building-item">
                        <div class="building-info">
                            <strong>${b.icon} ${b.name}</strong>
                            <span class="res-cost">${cs.join(' ')}</span>
                            <span class="res-cost">â³${formatTime(getBuildTime(k,0)/1000)}</span>
                        </div>
                        <button onclick="actBuild('${k}')" ${afford?'':'disabled'}>å»ºè¨­</button>
                    </div>`;
            }
            content.innerHTML = html;
            return;
        }
        
        const b = BUILDINGS[tile.type];
        if (tile.finishTime) {
            const rem = Math.max(0, (tile.finishTime - Date.now()));
            content.innerHTML = `
                <div style="text-align:center;">
                    <h3>${b.name} (Lv.${tile.level} -> ${tile.level+1})</h3>
                    <h2 style="color:var(--accent-color)">${formatTime(rem/1000)}</h2>
                    <p>å·¥äº‹ä¸­...</p>
                    <button class="action-btn store-btn" onclick="actStore()">ğŸ“¦ å›åï¼ˆä¿ç®¡åº«ã¸ï¼‰</button>
                </div>`;
        } else {
            const next = tile.level+1;
            const c = getCost(tile.type, tile.level);
            const afford = checkAfford(c);
            const caps = getStorageCapacity(tile.type, tile.level);
            let cs = []; for(let r in c) if(c[r]>0) cs.push((r=='money'?'ğŸ’°':r=='food'?'ğŸŒ¾':r=='wood'?'ğŸŒ²':r=='stone'?'ğŸª¨':'ğŸ”©')+c[r]);
            
            let prodInfo = ""; let storeInfo = "";
            for(let r in b.prod) if(b.prod[r]>0) {
                const val = b.prod[r]*tile.level*Math.pow(1.05, tile.level-1);
                prodInfo += `${(r=='money'?'ğŸ’°':r=='food'?'ğŸŒ¾':r=='wood'?'ğŸŒ²':r=='stone'?'ğŸª¨':'ğŸ”©')}${val.toFixed(1)}/s `;
                storeInfo += `<div>${(r=='money'?'ğŸ’°':r=='food'?'ğŸŒ¾':r=='wood'?'ğŸŒ²':r=='stone'?'ğŸª¨':'ğŸ”©')} ${Math.floor(tile.stored[r])}/${Math.floor(caps[r])}</div>`;
            }

            content.innerHTML = `
                <div style="text-align:center;">
                    <h3>${b.name} (Lv.${tile.level})</h3>
                    <div style="background:#f0f0f0; padding:5px; border-radius:5px; margin-bottom:5px;">
                        <strong>ç”Ÿç”£åŠ›:</strong><br>${prodInfo}
                    </div>
                    <div style="background:#e8f4f8; padding:5px; border-radius:5px; margin-bottom:10px;">
                        <strong>è²¯è”µåº«:</strong><br>${storeInfo}
                    </div>
                    <div style="text-align:left; font-size:0.9em; margin-bottom:5px;">
                         <strong>LvUPè²»ç”¨:</strong> ${cs.join(' ')}<br>
                         <strong>æ™‚é–“:</strong> ${formatTime(getBuildTime(tile.type, tile.level)/1000)}
                    </div>
                    <button class="action-btn" onclick="actBuild('${tile.type}')" ${afford?'':'disabled'}>ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—</button>
                    <button class="action-btn store-btn" onclick="actStore()">ğŸ“¦ å›åï¼ˆä¿ç®¡åº«ã¸ï¼‰</button>
                </div>`;
        }
    }

    // --- ãƒœã‚¿ãƒ³ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ ---
    window.actBuild = function(type) {
        if(selectedTileIndex===null) return;
        const t = gameState.tiles[selectedTileIndex];
        const lv = t.type===type ? t.level : 0;
        const c = getCost(type, lv);
        if(checkAfford(c)) {
            payCost(c);
            t.type = type;
            t.finishTime = Date.now() + getBuildTime(type, lv);
            t.stored = {};
            saveGame();
            sync3DState();
            updatePanelUI();
        }
    }
    
    // æ–½è¨­å›åï¼ˆä¿ç®¡ï¼‰
    window.actStore = function() {
        if(selectedTileIndex===null) return;
        const t = gameState.tiles[selectedTileIndex];
        if(!t.type) return;

        // è³‡æºå›å
        collectResource(selectedTileIndex);

        // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«è¿½åŠ 
        gameState.inventory.push({ type: t.type, level: t.level });

        // ã‚¿ã‚¤ãƒ«åˆæœŸåŒ–
        t.type = null;
        t.level = 0;
        t.finishTime = null;
        t.stored = {};
        
        saveGame();
        sync3DState();
        updatePanelUI();
    };

    // æ–½è¨­å†è¨­ç½®
    window.actRestore = function(invIndex) {
        if(selectedTileIndex===null) return;
        if(invIndex < 0 || invIndex >= gameState.inventory.length) return;

        const item = gameState.inventory[invIndex];
        const t = gameState.tiles[selectedTileIndex];

        // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰å‰Šé™¤
        gameState.inventory.splice(invIndex, 1);

        // é…ç½®
        t.type = item.type;
        
        // é‡è¦: å»ºè¨­å®Œäº†ãƒ­ã‚¸ãƒƒã‚¯(level++)ã‚’åˆ©ç”¨ã™ã‚‹ãŸã‚ã€ä¸€æ™‚çš„ã«ãƒ¬ãƒ™ãƒ«ã‚’1ä¸‹ã’ã‚‹
        // ä¾‹: Lv5ã‚’å†è¨­ç½® -> level=4ã§é…ç½®ã—ã€å·¥äº‹å®Œäº†æ™‚ã«Lv5ã«ãªã‚‹
        // æ™‚é–“è¨ˆç®—: getBuildTime(type, 4) -> Lv4ã‹ã‚‰Lv5ã¸ã®æ™‚é–“
        t.level = Math.max(0, item.level - 1); 
        
        // æ™‚é–“è¨­å®š
        t.finishTime = Date.now() + getBuildTime(item.type, t.level);
        t.stored = {};

        saveGame();
        sync3DState();
        updatePanelUI();
    };
    
    window.actExpand = function() {
        if(selectedTileIndex===null) return;
        const c = getExpandCost(gameState.rank);
        if(checkAfford(c)) {
            payCost(c);
            gameState.tiles[selectedTileIndex].unlocked = true;
            saveGame();
            sync3DState();
            updatePanelUI();
        }
    }

    function updateHeader() {
        for(let k in gameState.resources) document.getElementById('display-'+k).innerText = Math.floor(gameState.resources[k]).toLocaleString();
        document.getElementById('display-rank').innerText = gameState.rank;
        document.getElementById('display-next-xp').innerText = (getNextRankXP(gameState.rank)-gameState.xp).toLocaleString();
        document.getElementById('display-xp-bar').style.width = Math.min(100, (gameState.xp/getNextRankXP(gameState.rank))*100)+'%';
    }

    function onWindowResize() {
        const c = document.getElementById('game-container');
        if (!c) return;
        const width = c.clientWidth || window.innerWidth;
        const height = c.clientHeight || window.innerHeight;
        const aspect = width / height;
        const d = 10;
        
        if (camera && renderer) {
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }
    }

    function saveGame() {
        try {
            gameState.lastSaveTime = Date.now();
            localStorage.setItem('kingdomBuilder3DSave', JSON.stringify(gameState));
        } catch (e) {}
    }

    function loadGame() {
        try {
            const s = localStorage.getItem('kingdomBuilder3DSave');
            if(s) {
                const d = JSON.parse(s);
                gameState = { ...gameState, ...d };
                const now = Date.now();
                const sec = (now - gameState.lastSaveTime)/1000;
                if(sec > 10) {
                    let rep = ""; let built = 0; let earn = {};
                    gameState.tiles.forEach(t => {
                        if(t.finishTime && t.finishTime <= now) { t.level++; t.finishTime=null; built++; gameState.xp+=Math.floor(getBuildTime(t.type,t.level-1)/1000); }
                        if(t.type && t.level>0 && !t.finishTime) {
                            const b=BUILDINGS[t.type]; const caps=getStorageCapacity(t.type,t.level);
                            for(let r in b.prod) if(b.prod[r]>0) {
                                if(!earn[r]) earn[r]=0;
                                const add = Math.min(caps[r]-(t.stored[r]||0), b.prod[r]*t.level*Math.pow(1.05,t.level-1)*sec);
                                if(add>0) { t.stored[r]=(t.stored[r]||0)+add; earn[r]+=add; }
                            }
                        }
                    });
                    if(built>0) rep+=`<div>ğŸ—ï¸ ${built}ä»¶å®Œäº†</div>`;
                    for(let r in earn) if(earn[r]>1) rep+=`<div>+${Math.floor(earn[r]).toLocaleString()} ${r}</div>`;
                    if(rep) { document.getElementById('offline-report').innerHTML=rep; document.getElementById('modal-offline').style.display='flex'; }
                }
                gameState.lastSaveTime = now;
            }
        } catch (e) {}
    }
    
    window.closeModal = function(id) { document.getElementById(id).style.display='none'; }

    window.onload = function() {
        log("Window onload");
        setTimeout(init, 100);
    };

</script>
</body>
</html>
