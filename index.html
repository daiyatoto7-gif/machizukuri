<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kingdom Builder 3D (Cloud Save & Migration)</title>
    
    <!-- „Éá„Éê„ÉÉ„Ç∞Áî®„Çπ„Çø„Ç§„É´ -->
    <style>
        #debug-log {
            position: fixed; top: 0; left: 0; width: 100%; height: auto;
            max-height: 100px; overflow-y: scroll;
            background: rgba(0,0,0,0.7); color: lime;
            font-family: monospace; font-size: 10px;
            z-index: 9999; pointer-events: none;
            padding: 5px; box-sizing: border-box;
            display: none;
        }
        .error-msg { color: #ff5555; }
    </style>

    <!-- Three.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    
    <style>
        :root {
            --bg-color: #f0f2f5;
            --panel-bg: #ffffff;
            --accent-color: #3498db;
            --text-color: #2c3e50;
            --xp-color: #f1c40f;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            overflow: hidden;
            user-select: none;
            height: 100vh;
            width: 100vw;
        }

        /* „Ç≠„É£„É≥„Éê„Çπ„ÅÆ„Çø„ÉÉ„ÉÅ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÁÑ°ÂäπÂåñ„Åó„Å¶„Éñ„É©„Ç¶„Ç∂„Çπ„ÇØ„É≠„Éº„É´„ÇíÈò≤„Åê */
        canvas {
            touch-action: none;
        }

        header {
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            padding: 5px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            position: fixed;
            top: 0;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }
        header > * { pointer-events: auto; }

        .status-bar {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .rank-badge {
            background: var(--accent-color);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.9em;
        }
        .xp-container {
            width: 150px;
            height: 10px;
            background: #eee;
            border-radius: 5px;
            overflow: hidden;
        }
        .xp-fill {
            height: 100%;
            background: var(--xp-color);
            width: 0%;
            transition: width 0.5s;
        }
        .resource-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 0.85em;
            justify-content: center;
            padding: 0 10px;
            background: rgba(255,255,255,0.8);
            border-radius: 10px;
        }

        #game-container {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 1;
            background: radial-gradient(circle at center, #dcecf5 0%, #b0c4de 100%);
        }

        #ui-overlay-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            overflow: hidden;
        }

        .overlay-item {
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .tile-timer {
            font-size: 10px;
            font-weight: bold;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 2px 4px;
            border-radius: 4px;
            margin-bottom: 2px;
            white-space: nowrap;
        }
        .progress-bar-container {
            width: 40px; height: 4px; background: rgba(255,255,255,0.5); 
            border-radius: 2px; overflow: hidden;
        }
        .progress-fill { height: 100%; background: #2ecc71; width: 0%; transition: width 0.2s linear; }

        .harvest-bubble {
            background: white;
            border: 2px solid #f39c12;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            animation: bounce 1s infinite alternate;
            cursor: pointer;
        }
        @keyframes bounce { from { transform: translateY(0); } to { transform: translateY(-5px); } }

        .lock-icon {
            font-size: 24px;
            opacity: 0.6;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .float-text {
            position: absolute;
            color: #27ae60;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 0 #fff;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
            z-index: 100;
        }
        @keyframes floatUp { 
            0% { transform: translate(-50%, -50%); opacity: 1; } 
            100% { transform: translate(-50%, -150%); opacity: 0; } 
        }

        #control-panel {
            position: absolute;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            width: 90%; max-width: 400px;
            max-height: 40vh;
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            z-index: 30;
            display: none;
            flex-direction: column;
        }
        #control-panel.active { display: flex; }

        #panel-header {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 2px solid var(--bg-color);
            padding-bottom: 10px; margin-bottom: 10px;
        }
        #panel-title { margin: 0; font-size: 1.1em; color: var(--accent-color); }
        
        /* Èñâ„Åò„Çã„Éú„Çø„É≥„ÅÆ„Çø„ÉÉ„ÉóÈ†òÂüü„ÇíÊã°Â§ß */
        .close-btn { 
            cursor: pointer; 
            font-weight: bold; 
            padding: 10px 15px; 
            color: #999; 
            font-size: 1.2em; 
            margin: -10px -10px -10px 0;
        }
        .close-btn:hover { color: #666; }

        #panel-content { flex: 1; overflow-y: auto; padding-right: 5px; }

        .building-item {
            display: flex; justify-content: space-between; align-items: center;
            border: 1px solid #eee; padding: 8px; border-radius: 6px;
            margin-bottom: 8px; font-size: 0.9em;
        }
        .building-info { display: flex; flex-direction: column; gap: 2px; }
        .res-cost { font-size: 0.85em; color: #666; }

        button {
            padding: 8px 12px; border: none; border-radius: 4px;
            background-color: var(--accent-color); color: white;
            font-weight: bold; cursor: pointer; font-size: 0.9em;
        }
        button.action-btn { width: 100%; padding: 12px; font-size: 1em; margin-top: 5px; }
        button.store-btn { background-color: var(--text-color); margin-top: 10px; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }

        .inventory-section {
            margin-top: 15px;
            border-top: 2px dashed #eee;
            padding-top: 10px;
        }
        .inventory-title {
            font-size: 0.9em; font-weight: bold; color: #7f8c8d; margin-bottom: 5px;
        }

        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 100;
        }
        .modal-content {
            background: white; padding: 30px; border-radius: 10px; text-align: center;
            max-width: 400px; box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        /* „É°„Éã„É•„Éº„Éú„Çø„É≥: Âõ∫ÂÆöÈÖçÁΩÆ (Âè≥‰∏ä„Å´Â§âÊõ¥) */
        #menu-btn {
            position: fixed;
            top: 15px;
            right: 15px; /* Âè≥ÂÅ¥„Å´ÈÖçÁΩÆ„Åó„Å¶„É©„É≥„ÇØË°®Á§∫„Å®Ë¢´„Çâ„Å™„ÅÑ„Çà„ÅÜ„Å´ */
            background: white;
            width: 40px; height: 40px;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex; 
            justify-content: center; align-items: center;
            font-size: 24px;
            cursor: pointer;
            z-index: 50;
            pointer-events: auto;
        }
        #menu-btn:hover { background: #f0f0f0; }

        /* „É°„Éã„É•„Éº„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Çπ„Çø„Ç§„É´ */
        .shop-item {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            text-align: left;
        }
        
        #toast-notification {
            position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white; padding: 10px 20px;
            border-radius: 20px; font-weight: bold; z-index: 100;
            display: none; pointer-events: none;
            animation: fadeInOut 3s forwards;
            white-space: nowrap;
        }
        @keyframes fadeInOut { 0% { opacity:0; top:90px; } 10% { opacity:1; top:80px; } 90% { opacity:1; top:80px; } 100% { opacity:0; top:70px; } }

        /* „É≠„Éº„ÉâÁîªÈù¢ */
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #dcecf5 0%, #b0c4de 100%);
            z-index: 9999;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            transition: opacity 0.5s;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--accent-color);
            border-radius: 50%;
            width: 40px; height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="debug-log"></div>
<div id="toast-notification"></div>

<div id="loading-screen">
    <div class="loader"></div>
    <div id="loading-text" style="font-weight:bold; color:#2c3e50;">Connecting to Cloud...</div>
</div>

<div id="menu-btn" onclick="openMenu()">‚â°</div>

<header>
    <div class="status-bar">
        <div class="rank-badge">RANK <span id="display-rank">1</span></div>
        <div class="xp-container">
            <div class="xp-fill" id="display-xp-bar"></div>
        </div>
        <div style="font-size:0.8em; color:#7f8c8d;">Next: <span id="display-next-xp">0</span> XP</div>
    </div>
    <div class="resource-bar">
        <div class="res-item">üí∞ <span id="display-money">0</span></div>
        <div class="res-item">üåæ <span id="display-food">0</span></div>
        <div class="res-item">üå≤ <span id="display-wood">0</span></div>
        <div class="res-item">ü™® <span id="display-stone">0</span></div>
        <div class="res-item">üî© <span id="display-iron">0</span></div>
        <div class="res-item" style="border-left:1px solid #ddd; padding-left:10px; color:#e67e22;">üë∑ <span id="display-builders">0/4</span></div>
    </div>
</header>

<div id="game-container"></div>
<div id="ui-overlay-layer"></div>

<div id="control-panel">
    <div id="panel-header">
        <h2 id="panel-title">„Çø„Ç§„É´ÈÅ∏Êäû</h2>
        <div class="close-btn" onclick="closePanel()">‚úï</div>
    </div>
    <div id="panel-content"></div>
</div>

<div id="modal-offline" class="modal">
    <div class="modal-content">
        <h3>„Åä„Åã„Åà„Çä„Å™„Åï„ÅÑÔºÅ</h3>
        <p>‰∏çÂú®„ÅÆÈñì„Å´ÁîüÁî£„Åï„Çå„ÅüË≥áÊ∫ê„Åå<br>Ë≤ØËîµÂ∫´„Å´‰øùÁÆ°„Åï„Çå„Åæ„Åó„Åü„ÄÇ</p>
        <div style="text-align:left; background:#f9f9f9; padding:10px; border-radius:5px; margin:10px 0;">
            <div id="offline-report"></div>
        </div>
        <button onclick="closeModal('modal-offline')" class="action-btn">ÂÜçÈñã„Åô„Çã</button>
    </div>
</div>

<div id="modal-levelup" class="modal">
    <div class="modal-content">
        <h3 style="color:var(--accent-color);">üéâ „É©„É≥„ÇØ„Ç¢„ÉÉ„ÉóÔºÅ üéâ</h3>
        <p style="font-size:1.2em; font-weight:bold;">RANK <span id="levelup-rank"></span> „Å´„Å™„Çä„Åæ„Åó„ÅüÔºÅ</p>
        <button onclick="closeModal('modal-levelup')" class="action-btn">Èñâ„Åò„Çã</button>
    </div>
</div>

<div id="modal-menu" class="modal">
    <div class="modal-content">
        <h3 style="margin-top:0;">„É°„Éã„É•„Éº</h3>
        <div id="menu-content" style="max-height:60vh; overflow-y:auto;"></div>
        <button onclick="closeModal('modal-menu')" class="action-btn" style="background-color:#95a5a6; margin-top:20px;">Èñâ„Åò„Çã</button>
    </div>
</div>

<!-- ÊñΩË®≠‰∏ÄË¶ßÁî®„É¢„Éº„ÉÄ„É´ -->
<div id="modal-building-list" class="modal">
    <div class="modal-content" style="max-width:500px; max-height:80vh; overflow:hidden; display:flex; flex-direction:column;">
        <h3 style="margin-top:0;">üìã ÊñΩË®≠‰∏ÄË¶ß</h3>
        <div id="building-list-content" style="flex:1; overflow-y:auto; text-align:left;"></div>
        <button onclick="closeModal('modal-building-list')" class="action-btn" style="background-color:#95a5a6; margin-top:10px;">Èñâ„Åò„Çã</button>
    </div>
</div>

<script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
    import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
    import { getFirestore, doc, setDoc, getDoc, collection } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';

    // Global Firebase Variables
    let firebaseConfig;
    let appId;
    let offlineMode = false; // „ÇØ„É©„Ç¶„Éâ„Ç®„É©„ÉºÊôÇ„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Éï„É©„Ç∞

    // Áí∞Â¢ÉÂà§ÂÆöÔºö„Åì„ÅÆ„Éó„É¨„Éì„É•„ÉºÁí∞Â¢É(Canvas)„Åã„ÄÅÂ§ñÈÉ®Áí∞Â¢É(GitHub PagesÁ≠â)„Åã„ÇíÂà§ÂÆö„Åó„Å¶Ë®≠ÂÆö„ÇíÂàá„ÇäÊõø„Åà
    if (typeof __firebase_config !== 'undefined') {
        // CanvasÁí∞Â¢É
        firebaseConfig = JSON.parse(__firebase_config);
        appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    } else {
        // Â§ñÈÉ®Áí∞Â¢É (GitHub PagesÁ≠â): ÂÖÉ„ÅÆ„Éè„Éº„Éâ„Ç≥„Éº„ÉâË®≠ÂÆö„Çí‰ΩøÁî®
        firebaseConfig = {
            apiKey: "AIzaSyBzJkeWGrzm5pFKAuX_Vkk-w1w4tsKHsDo",
            authDomain: "kingdom-builder-cdfb9.firebaseapp.com",
            projectId: "kingdom-builder-cdfb9",
            storageBucket: "kingdom-builder-cdfb9.firebasestorage.app",
            messagingSenderId: "672874506084",
            appId: "1:672874506084:web:573a57495e5a350d4fbc71",
            measurementId: "G-F6JMJJR146"
        };
        appId = firebaseConfig.projectId;
    }

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    let currentUser = null;
    let userDocRef = null;
    let currentDocId = null; // ÂÆüÈöõ„Å´Ë™≠„ÅøÊõ∏„Åç„Åô„ÇãIDÔºàÂÖ±ÊúâID„Åæ„Åü„ÅØËá™ÂàÜ„ÅÆUIDÔºâ

    // --- Firebase Init ---
    async function initFirebase() {
        const loadingText = document.getElementById('loading-text');
        
        try {
            // CanvasÁí∞Â¢É: „Ç´„Çπ„Çø„É†„Éà„Éº„ÇØ„É≥„Çí‰ΩøÁî® (Êé®Â•®)
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                 await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                 // Â§ñÈÉ®Áí∞Â¢É„Åæ„Åü„ÅØ„Éà„Éº„ÇØ„É≥„Åå„Å™„ÅÑÂ†¥Âêà: ÂåøÂêçË™çË®º
                 await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Auth failed:", error);
            
            // „Ç®„É©„Éº„ÅÆÁ®ÆÈ°û„Åå„É™„Éï„Ç°„É©„ÉºÂà∂Èôê„ÅÆÂ†¥Âêà„ÄÅ„Ç™„Éï„É©„Ç§„É≥„É¢„Éº„Éâ„ÅßÁ∂öË°å
            if(error.code === 'auth/requests-from-referer-blocked' || error.message.includes('referer')) {
                console.warn("Domain restricted: Switching to Offline Mode.");
                offlineMode = true;
                loadingText.innerText = "Offline Mode (Cloud Disabled)";
                setTimeout(loadGameFromCloud, 1000); // Áõ¥Êé•„É≠„Éº„Éâ„Å∏
                return;
            }

            // „Åù„ÅÆ‰ªñ„ÅÆ„Ç®„É©„Éº„Åß„ÅÆ„É™„Éà„É©„Ç§
            try {
                await signInAnonymously(auth);
            } catch(e) {
                // „Åì„Åì„Åß„ÇÇ„ÉÄ„É°„Å™„Çâ„Ç™„Éï„É©„Ç§„É≥„É¢„Éº„Éâ„Å∏
                console.error("Retry Auth Failed, using offline", e);
                offlineMode = true;
                loadingText.innerText = "Offline Mode";
                setTimeout(loadGameFromCloud, 1000);
                return;
            }
        }

        // 2. Auth Listener („Ç™„É≥„É©„Ç§„É≥ÊôÇ„ÅÆ„ÅøÁô∫ÁÅ´)
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                
                // ÂÖ±ÊúâË®≠ÂÆö(IDÈÄ£Êê∫)„Åå„ÅÇ„Çã„ÅãÁ¢∫Ë™ç
                const sharedId = localStorage.getItem('kingdomBuilder_sharedId');
                if (sharedId) {
                    currentDocId = sharedId;
                    console.log("Using Shared ID:", currentDocId);
                } else {
                    currentDocId = user.uid;
                }

                // Rule: /artifacts/{appId}/users/{userId}/gameData/saveSlot1
                userDocRef = doc(db, 'artifacts', appId, 'users', currentDocId, 'gameData', 'saveSlot1');
                
                loadingText.innerText = "Loading Kingdom...";
                await loadGameFromCloud();
            }
        });
    }
    
    // --- Cloud Load & Save Logic ---
    async function loadGameFromCloud() {
        try {
            // „Ç™„Éï„É©„Ç§„É≥„É¢„Éº„Éâ „Åæ„Åü„ÅØ CloudË™≠Ëæº
            let data = null;
            let loadedFrom = "";

            if (!offlineMode && userDocRef) {
                try {
                    const snap = await getDoc(userDocRef);
                    if (snap.exists()) {
                        data = snap.data();
                        loadedFrom = "Cloud";
                    }
                } catch(e) {
                    console.warn("Cloud read failed, falling back to local:", e);
                    // CloudË™≠ËæºÂ§±ÊïóÊôÇ„ÇÇ„É≠„Éº„Ç´„É´„Å∏„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
                }
            }

            // „ÇØ„É©„Ç¶„Éâ„Å´„Å™„Åë„Çå„Å∞„É≠„Éº„Ç´„É´(„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó)„ÇíÁ¢∫Ë™ç
            if (!data) {
                const backup = localStorage.getItem('kingdomBuilderSave');
                if (backup) {
                    try {
                        data = JSON.parse(backup);
                        loadedFrom = "Local Backup";
                    } catch(e){}
                }
            }

            // „Åù„Çå„Åß„ÇÇ„Å™„Åë„Çå„Å∞Êóß„Éá„Éº„Çø„Çí„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥Êé¢Á¥¢
            if (!data) {
                const legacyKeys = ['kingdomBuilderSave', 'kb_save_data', 'gameState']; 
                for (const key of legacyKeys) {
                    const localRaw = localStorage.getItem(key);
                    if (localRaw) {
                        try {
                            const localData = JSON.parse(localRaw);
                            if (localData && (localData.resources || localData.tiles)) {
                                data = localData;
                                loadedFrom = "Legacy Migration";
                                showToast("üì¶ Âè§„ÅÑ„Éá„Éº„Çø„ÇíÂºï„ÅçÁ∂ô„Åé„Åæ„Åó„ÅüÔºÅ");
                                break; 
                            }
                        } catch (e) {}
                    }
                }
            }

            if (data) {
                gameState = { ...gameState, ...data };
                processOfflineProgress();
                console.log(`Loaded game from: ${loadedFrom}`);
                // ÂàùÂõû„É≠„Éº„ÉâÊàêÂäüÊôÇ„Å´Âç≥Â∫ß„Å´‰øùÂ≠ò„Åó„Å¶Êï¥ÂêàÊÄß„Çí‰øù„Å§
                saveGameToCloud(true);
            } else {
                console.log("New User: Creating initial state.");
                saveGameToCloud(true);
            }

        } catch (e) {
            console.error("Load failed:", e);
            showToast("„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü");
        }

        // „É≠„Éº„ÉâÂÆå‰∫ÜÂæå„ÄÅ„Ç≤„Éº„É†„ÇíÈñãÂßã
        initGame();
        
        const loader = document.getElementById('loading-screen');
        if(loader) {
            loader.style.opacity = 0;
            setTimeout(() => loader.style.display = 'none', 500);
        }
    }

    async function saveGameToCloud(silent = false) {
        gameState.lastSaveTime = Date.now();
        
        try {
            // „Ç∑„É™„Ç¢„É©„Ç§„Ç∫
            const dataToSave = JSON.parse(JSON.stringify(gameState));
            
            // 1. „É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´Â∏∏„Å´„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó („Ç™„Éï„É©„Ç§„É≥ÊôÇ & Ê¨°ÂõûÈ´òÈÄü„É≠„Éº„ÉâÁî®)
            localStorage.setItem('kingdomBuilderSave', JSON.stringify(dataToSave));

            // 2. „Ç™„É≥„É©„Ç§„É≥„Åã„Å§Ë™çË®ºÊ∏à„Åø„Å™„Çâ„ÇØ„É©„Ç¶„Éâ„Å∏‰øùÂ≠ò
            if (!offlineMode && currentUser && userDocRef) {
                await setDoc(userDocRef, dataToSave);
                if (!silent) showToast("‚òÅÔ∏è ‰øùÂ≠ò„Åó„Åæ„Åó„Åü");
            } else {
                if (!silent) showToast("üíæ ‰øùÂ≠ò„Åó„Åæ„Åó„Åü („Ç™„Éï„É©„Ç§„É≥)");
            }
        } catch (e) {
            console.error("Save failed:", e);
            // Cloud‰øùÂ≠òÂ§±ÊïóÊôÇ„ÇÇ„É≠„Éº„Ç´„É´„Å´„ÅØ‰øùÂ≠ò„Åï„Çå„Å¶„ÅÑ„Çã„ÅÆ„ÅßËá¥ÂëΩÁöÑ„Åß„ÅØ„Å™„ÅÑ
            if (!silent && !offlineMode) showToast("‚ö†Ô∏è „ÇØ„É©„Ç¶„Éâ‰øùÂ≠òÂ§±Êïó(„É≠„Éº„Ç´„É´„Å´‰øùÂ≠ò)");
        }
    }

    window.saveGame = saveGameToCloud;

    window.onload = function() {
        try {
            initFirebase();
        } catch(e) {
            console.error("Firebase init crash:", e);
            document.getElementById('loading-text').innerText = "Offline Mode";
            offlineMode = true;
            setTimeout(() => {
                loadGameFromCloud();
            }, 1000);
        }
    };


    // --- Game Logic ---

    function log(msg, isError = false) {
        const el = document.getElementById('debug-log');
        if (!el) return;
        const line = document.createElement('div');
        line.textContent = `> ${msg}`;
        if (isError) {
            line.className = 'error-msg';
            el.style.display = 'block'; 
            console.error(msg);
        } else {
            console.log(msg);
        }
        el.appendChild(line);
        el.scrollTop = el.scrollHeight;
    }
    
    function showToast(msg) {
        const t = document.getElementById('toast-notification');
        t.innerText = msg;
        t.style.display = 'none';
        void t.offsetWidth; // trigger reflow
        t.style.display = 'block';
    }

    window.onerror = function(message, source, lineno, colno, error) {
        log(`Global Error: ${message} at line ${lineno}`, true);
        return false;
    };

    const CONFIG = {
        initialGridSize: 5, 
        fps: 30, 
        autoSaveInterval: 10000, 
        initialUnlocked: [6, 7, 8, 11, 12, 13],
        storageHours: 8,
        collectCooldown: 30000,
        initialMaxBuilders: 4
    };

    const BUILDINGS = {
        house: { name: "Ê∞ëÂÆ∂", icon: "üè†", desc: "‰ΩèÊ∞ë„Åå‰Ωè„ÇÄÂÆ∂„ÄÇ„ÅäÈáë„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { money: 2 }, cost: { money: 20, food: 10 }, baseTime: 2000 },
        farm: { name: "Áïë", icon: "üåæ", desc: "‰ΩúÁâ©„ÇíËÇ≤„Å¶„Åæ„Åô„ÄÇÈ£üÊñô„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { food: 2 }, cost: { money: 30, wood: 10 }, baseTime: 2000 },
        lumber: { name: "‰ºêÊé°ÊâÄ", icon: "üå≤", desc: "Êú®„ÇíÂàá„ÇäÂá∫„Åó„Åæ„Åô„ÄÇÊú®Êùê„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { wood: 1 }, cost: { money: 50, food: 20 }, baseTime: 3000 },
        quarry: { name: "Êé°Áü≥Â†¥", icon: "ü™®", desc: "Áü≥„ÇíÂàá„ÇäÂá∫„Åó„Åæ„Åô„ÄÇÁü≥Êùê„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { stone: 1 }, cost: { money: 100, food: 50, wood: 50 }, baseTime: 4000 },
        mine: { name: "Èâ±Â±±", icon: "üî©", desc: "Âú∞‰∏ãË≥áÊ∫ê„ÇíÊéò„Çä„Åæ„Åô„ÄÇÈâÑ„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { iron: 1 }, cost: { money: 200, food: 100, wood: 100, stone: 50 }, baseTime: 5000 },
        market: { name: "Â∏ÇÂ†¥", icon: "‚öñÔ∏è", desc: "‰∫§Êòì„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇÂ§ßÈáè„ÅÆ„ÅäÈáë„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { money: 10 }, cost: { money: 500, food: 200, wood: 200, stone: 50 }, baseTime: 6000 },
        blacksmith: { name: "ÈçõÂÜ∂Â±ã", icon: "‚öîÔ∏è", desc: "Ê≠¶ÂÖ∑„Çí‰Ωú„Çä„Åæ„Åô„ÄÇ„ÅäÈáë„Å®ÈâÑ„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { money: 5, iron: 2 }, cost: { money: 800, food: 300, wood: 300, stone: 200, iron: 100 }, baseTime: 7000 }
    };
    
    // ÊñΩË®≠Âà∂Èôê„ÅÆ„Åü„ÇÅ„ÅÆ„Ç≠„ÉºÈÖçÂàó„Å®Âà∂ÈôêÈñãÂßã„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ
    const BUILDING_KEYS = Object.keys(BUILDINGS);
    const LIMIT_START_INDEX = BUILDING_KEYS.indexOf('market'); // market‰ª•Èôç„ÅØÂà∂ÈôêÂØæË±°

    // ÁâπÂÆö„ÅÆÊñΩË®≠„ÅÆÊï∞„Çí„Ç´„Ç¶„É≥„ÉàÔºà„Éû„ÉÉ„Éó‰∏ä + „Ç§„É≥„Éô„É≥„Éà„É™Ôºâ
    function getBuildingCount(type) {
        const onMap = gameState.tiles.filter(t => t.type === type).length;
        const inInventory = gameState.inventory.filter(i => i.type === type).length;
        return onMap + inInventory;
    }

    // Âª∫Ë®≠Âà∂Èôê„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
    function checkBuildingLimit(type) {
        const typeIndex = BUILDING_KEYS.indexOf(type);
        // Â∏ÇÂ†¥‰ª•Èôç„ÅÆÊñΩË®≠„ÄÅ„Åã„Å§4„Å§‰ª•‰∏äÊåÅ„Å£„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØNG
        if (typeIndex >= LIMIT_START_INDEX && typeIndex !== -1) {
            if (getBuildingCount(type) >= 4) {
                return false;
            }
        }
        return true;
    }
    
    for(let k in BUILDINGS) {
        const b = BUILDINGS[k];
        for(let r of ['money','food','wood','stone','iron']) {
            if(!b.prod[r]) b.prod[r] = 0;
            if(!b.cost[r]) b.cost[r] = 0;
        }
    }

    let gameState = {
        rank: 1, xp: 0,
        resources: { money: 200, food: 100, wood: 50, stone: 0, iron: 0 },
        tiles: [],
        inventory: [],
        maxBuilders: CONFIG.initialMaxBuilders,
        gridSize: CONFIG.initialGridSize,
        lastSaveTime: Date.now()
    };

    let selectedTileIndex = null;

    let scene, camera, renderer;
    let raycaster, mouse;
    let tileMeshes = []; 
    let pedestrians = []; 
    
    // „Ç´„É°„É©ÁßªÂãïÁî®Â§âÊï∞
    let pointerDownPos = new THREE.Vector2();
    let lastPointerPos = new THREE.Vector2();
    let isDragging = false;
    let isPanning = false;

    // Called after Firestore load
    function initGame() {
        log("Game initializing...");

        if (typeof THREE === 'undefined') {
            document.body.innerHTML = '<div style="padding:20px;text-align:center;color:red;"><h3>„Ç®„É©„Éº: 3D„É©„Ç§„Éñ„É©„É™„ÅåË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì„ÄÇ</h3><p>ÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p></div>';
            return;
        }
        
        if (!gameState.maxBuilders) gameState.maxBuilders = CONFIG.initialMaxBuilders;
        if (!gameState.gridSize) gameState.gridSize = CONFIG.initialGridSize;

        const totalTiles = gameState.gridSize * gameState.gridSize;
        if (gameState.tiles.length !== totalTiles) {
            if (gameState.tiles.length === 0) {
                gameState.tiles = Array(totalTiles).fill(null).map((_, i) => ({
                    type: null, level: 0, finishTime: null, 
                    unlocked: CONFIG.initialUnlocked.includes(i), 
                    stored: {},
                    lastCollectTime: 0
                }));
            } else {
                const currentLen = gameState.tiles.length;
                for(let i=currentLen; i<totalTiles; i++) {
                      gameState.tiles.push({
                         type: null, level: 0, finishTime: null, 
                         unlocked: false,
                         stored: {},
                         lastCollectTime: 0
                      });
                }
            }
        } else {
             gameState.tiles.forEach(t => { 
                 if(!t.stored) t.stored = {}; 
                 if(t.lastCollectTime === undefined) t.lastCollectTime = 0;
             });
        }
        if(!gameState.inventory) gameState.inventory = [];

        try {
            init3D();
        } catch (e) {
            log(`3D Init Error: ${e.message}`, true);
            showToast("3DË°®Á§∫„ÅÆÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ");
            return;
        }

        updateHeader();
        
        requestAnimationFrame(animate3D);
        setInterval(gameLogicLoop, 1000); 
        setInterval(() => window.saveGame(true), CONFIG.autoSaveInterval);
        setInterval(updatePanelUI, 500);

        log("Game loop started.");
    }

    function init3D() {
        const container = document.getElementById('game-container');
        if(!container) throw new Error("Game container not found");
        
        let width = container.clientWidth;
        let height = container.clientHeight;

        if (width === 0 || height === 0) {
            width = window.innerWidth;
            height = window.innerHeight;
        }

        scene = new THREE.Scene();
        
        const aspect = width / height;
        const d = 10;
        
        camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(20, 20, 20); 
        camera.lookAt(scene.position);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        const pixelRatio = Math.max(window.devicePixelRatio, 2.0);
        renderer.setPixelRatio(pixelRatio);
        
        renderer.setSize(width, height);
        renderer.shadowMap.enabled = true;
        renderer.setClearColor( 0x000000, 0 ); 
        container.innerHTML = ''; 
        container.appendChild(renderer.domElement);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        
        createTiles();
        initPedestrians();

        window.addEventListener('resize', onWindowResize, false);
        
        renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
        renderer.domElement.addEventListener('pointerup', onPointerUp, false);
        renderer.domElement.addEventListener('pointermove', onPointerMove, false);

        renderer.domElement.addEventListener('wheel', onMouseWheel, { passive: false });
        renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
        renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
        renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
        
        setTimeout(onWindowResize, 100);
    }
    
    function createTiles() {
        tileMeshes.forEach(t => {
            scene.remove(t.mesh);
            scene.remove(t.groundMesh);
            t.overlayEl.remove();
        });
        tileMeshes = [];

        const geometry = new THREE.BoxGeometry(1.4, 0.5, 1.4);
        const unlockedMat = new THREE.MeshStandardMaterial({ color: 0xecf0f1 });
        const groundGeo = new THREE.PlaneGeometry(2.0, 2.0);
        const groundMatBase = new THREE.MeshStandardMaterial({ color: 0x555555 });

        const offset = 2; 
        const size = gameState.gridSize;
        const start = -offset * (size - 1) / 2;

        for (let i = 0; i < size * size; i++) {
            const row = Math.floor(i / size);
            const col = i % size;
            const x = start + col * offset;
            const z = start + row * offset;

            const ground = new THREE.Mesh(groundGeo, groundMatBase.clone());
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(x, -0.01, z);
            ground.receiveShadow = true;
            scene.add(ground);

            const mesh = new THREE.Mesh(geometry, unlockedMat.clone());
            mesh.position.set(x, 0, z);
            mesh.receiveShadow = true;
            mesh.userData = { index: i, type: 'tile' };
            scene.add(mesh);

            const bGroup = new THREE.Group();
            bGroup.position.set(0, 0.25, 0);
            mesh.add(bGroup);

            const overlay = document.createElement('div');
            overlay.className = 'overlay-item';
            document.getElementById('ui-overlay-layer').appendChild(overlay);

            const particles = new ParticleSystem(mesh.position, scene);

            tileMeshes.push({ 
                mesh: mesh, 
                groundMesh: ground,
                buildingGroup: bGroup,
                overlayEl: overlay,
                particles: particles,
                currentType: null 
            });
        }
        sync3DState();
    }

    class Person {
        constructor(scene) {
            this.scene = scene;
            this.mesh = new THREE.Group();
            const bodyColor = Math.random() * 0xffffff;
            const bodyGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.25, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.125;
            this.mesh.add(body);
            const headGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 0.35;
            this.mesh.add(head);
            this.mesh.castShadow = true;
            scene.add(this.mesh);
            this.active = false;
            this.mesh.visible = false;
            this.isStopped = false;
            this.stopTimer = 0;
            this.canTurn = true;
            this.reset();
        }
        getNearestRoadCoord(val) {
            const size = gameState.gridSize;
            const offset = 2; 
            const tileStart = -offset * (size - 1) / 2;
            const roadStart = tileStart + 1;
            const index = Math.round((val - roadStart) / offset);
            return roadStart + index * offset;
        }
        reset() {
            const isVertical = Math.random() < 0.5;
            const size = gameState.gridSize;
            const offset = 2; 
            const tileStart = -offset * (size - 1) / 2;
            const roadStart = tileStart + 1;
            const roadCount = Math.max(1, size - 1); 
            const roadIndex = Math.floor(Math.random() * roadCount);
            const laneCenter = roadStart + roadIndex * offset;
            const jitter = (Math.random() - 0.5) * 0.4;
            const lane = laneCenter + jitter;
            this.baseSpeed = (0.02 + Math.random() * 0.02) * 0.25;
            this.speed = this.baseSpeed;
            let sx, sz, dx, dz;
            const spawnDist = size + 5; 
            if (isVertical) {
                sx = lane;
                sz = (Math.random() < 0.5 ? -spawnDist : spawnDist);
                dx = 0; dz = sz > 0 ? -1 : 1;
            } else {
                sz = lane;
                sx = (Math.random() < 0.5 ? -spawnDist : spawnDist);
                dx = sx > 0 ? -1 : 1; dz = 0;
            }
            this.mesh.position.set(sx, 0, sz);
            this.direction = new THREE.Vector3(dx, 0, dz);
            this.active = true;
            this.isStopped = false;
            this.canTurn = true;
            this.updateVisibility();
        }
        isOnGreenRoad(x, z, isVertical) {
            const size = gameState.gridSize;
            const offset = 2;
            const start = -offset * (size - 1) / 2;
            const checkTile = (wx, wz) => {
                const col = Math.round((wx - start) / offset);
                const row = Math.round((wz - start) / offset);
                if (col < 0 || col >= size || row < 0 || row >= size) return false;
                const idx = row * size + col;
                return gameState.tiles[idx] && gameState.tiles[idx].unlocked;
            };
            let t1_unlocked = false;
            let t2_unlocked = false;
            if (isVertical) {
                t1_unlocked = checkTile(x - 1, Math.round(z));
                t2_unlocked = checkTile(x + 1, Math.round(z));
            } else {
                t1_unlocked = checkTile(Math.round(x), z - 1);
                t2_unlocked = checkTile(Math.round(x), z + 1);
            }
            return (!t1_unlocked && !t2_unlocked);
        }
        update() {
            if (!this.active) {
                if (Math.random() < 0.01) this.reset();
                return;
            }
            if (this.isStopped) {
                this.stopTimer--;
                if (this.stopTimer <= 0) {
                    this.isStopped = false;
                }
                this.updateVisibility();
                return;
            }
            if (Math.random() < 0.005) {
                this.isStopped = true;
                this.stopTimer = 30 + Math.random() * 60;
                return;
            }
            const nearestRoadX = this.getNearestRoadCoord(this.mesh.position.x);
            const nearestRoadZ = this.getNearestRoadCoord(this.mesh.position.z);
            const distX = Math.abs(this.mesh.position.x - nearestRoadX);
            const distZ = Math.abs(this.mesh.position.z - nearestRoadZ);
            const intersectionThreshold = 0.1; 
            const isAtIntersection = (distX < intersectionThreshold && distZ < intersectionThreshold);
            if (isAtIntersection) {
                if (this.canTurn) {
                    if(Math.random() < 0.5) {
                        const dirs = [
                            new THREE.Vector3(1, 0, 0),
                            new THREE.Vector3(-1, 0, 0),
                            new THREE.Vector3(0, 0, 1),
                            new THREE.Vector3(0, 0, -1)
                        ];
                        this.direction = dirs[Math.floor(Math.random() * dirs.length)];
                        this.mesh.position.x = nearestRoadX;
                        this.mesh.position.z = nearestRoadZ;
                    }
                    this.canTurn = false; 
                }
            } else {
                if (Math.max(distX, distZ) > 0.4) {
                    this.canTurn = true;
                }
            }
            this.mesh.position.addScaledVector(this.direction, this.speed);
            const limit = gameState.gridSize * 1.5 + 5;
            if (Math.abs(this.mesh.position.x) > limit || Math.abs(this.mesh.position.z) > limit) {
                this.reset();
                return;
            }
            this.updateVisibility();
            this.mesh.position.y = Math.abs(Math.sin(Date.now() * 0.005)) * 0.05;
        }
        updateVisibility() {
            const isVertical = (this.direction.z !== 0);
            if (this.isOnGreenRoad(this.mesh.position.x, this.mesh.position.z, isVertical)) {
                this.mesh.visible = false;
            } else {
                this.mesh.visible = true;
            }
        }
    }

    function initPedestrians() {
        if(pedestrians.length === 0) {
            for (let i = 0; i < 15; i++) { 
                pedestrians.push(new Person(scene));
            }
        } else {
            pedestrians.forEach(p => p.reset());
        }
    }

    class ParticleSystem {
        constructor(position, scene) {
            this.origin = position.clone().add(new THREE.Vector3(0, 1, 0));
            this.particles = [];
            this.scene = scene;
            this.active = false;
            this.geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            this.mat = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true });
        }
        update() {
            if (!this.active && this.particles.length === 0) return;
            if (this.active && Math.random() < 0.2) {
                const mesh = new THREE.Mesh(this.geo, this.mat.clone());
                const offset = new THREE.Vector3((Math.random()-0.5)*1.5, 0, (Math.random()-0.5)*1.5);
                mesh.position.copy(this.origin).add(offset);
                this.scene.add(mesh);
                this.particles.push({ 
                    mesh: mesh, 
                    vel: new THREE.Vector3(0, 0.05 + Math.random()*0.05, 0), 
                    life: 1.0 
                });
            }
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.mesh.position.add(p.vel);
                p.mesh.rotation.x += 0.1;
                p.mesh.rotation.y += 0.1;
                p.life -= 0.02;
                p.mesh.material.opacity = p.life;
                if (p.life <= 0) {
                    this.scene.remove(p.mesh);
                    this.particles.splice(i, 1);
                }
            }
        }
    }

    function createBuildingMesh(type, level) {
        const group = new THREE.Group();
        const scale = 1 + (level * 0.05);
        group.scale.set(scale, scale, scale);
        const matRoof = new THREE.MeshStandardMaterial({ color: 0xe74c3c }); 
        const matWall = new THREE.MeshStandardMaterial({ color: 0xf39c12 }); 
        const matLeaf = new THREE.MeshStandardMaterial({ color: 0x2ecc71 }); 
        const matStone = new THREE.MeshStandardMaterial({ color: 0x7f8c8d }); 
        const matDark = new THREE.MeshStandardMaterial({ color: 0x34495e }); 
        const matTent = new THREE.MeshStandardMaterial({ color: 0x3498db }); 
        const matGrass = new THREE.MeshStandardMaterial({ color: 0x27ae60 });
        switch(type) {
            case 'wild': // Êú™ÈñãÊãìÂú∞„ÅÆËçâ
                for(let i=0; i<8; i++) {
                    const grass = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.3, 4), matGrass);
                    grass.position.set((Math.random()-0.5)*1.4, 0.15, (Math.random()-0.5)*1.4);
                    grass.rotation.y = Math.random() * Math.PI;
                    group.add(grass);
                }
                if(Math.random() < 0.5) {
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.3), new THREE.MeshStandardMaterial({color:0x8B4513}));
                    trunk.position.y = 0.15;
                    group.add(trunk);
                    const leaves = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 8), matLeaf);
                    leaves.position.y = 0.4;
                    group.add(leaves);
                }
                break;
            case 'house':
                const wall = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.8), matWall);
                wall.position.y = 0.3;
                wall.castShadow = true;
                group.add(wall);
                const roof = new THREE.Mesh(new THREE.ConeGeometry(0.7, 0.5, 4), matRoof);
                roof.position.y = 0.85;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                group.add(roof);
                const chimney = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), matStone);
                chimney.position.set(0.2, 0.8, 0.2);
                group.add(chimney);
                break;
            case 'farm':
                const soil = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.1, 1.0), new THREE.MeshStandardMaterial({color:0x8B4513}));
                soil.position.y = 0.05;
                soil.receiveShadow = true;
                group.add(soil);
                for(let i=0; i<4; i++) {
                    const crop = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), matLeaf);
                    crop.position.set((i%2 ? 0.3 : -0.3), 0.25, (i<2 ? 0.3 : -0.3));
                    group.add(crop);
                }
                break;
            case 'lumber':
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 0.4), new THREE.MeshStandardMaterial({color:0x8B4513}));
                trunk.position.y = 0.2;
                group.add(trunk);
                const leaves2 = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 8), matLeaf);
                leaves2.position.y = 0.7;
                group.add(leaves2);
                const stump = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.2), new THREE.MeshStandardMaterial({color:0x8B4513}));
                stump.position.set(0.4, 0.1, 0.4);
                group.add(stump);
                break;
            case 'quarry':
                const rock1 = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4), matStone);
                rock1.position.y = 0.3;
                group.add(rock1);
                const rock2 = new THREE.Mesh(new THREE.DodecahedronGeometry(0.3), matStone);
                rock2.position.set(0.4, 0.2, 0.3);
                group.add(rock2);
                break;
            case 'mine':
                const frame = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.2), new THREE.MeshStandardMaterial({color:0x5d4037}));
                frame.position.set(0, 0.3, -0.2);
                group.add(frame);
                const hole = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.1), new THREE.MeshStandardMaterial({color:0x000000}));
                hole.position.set(0, 0.25, -0.1);
                group.add(hole);
                break;
            case 'market':
                const post = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.4, 0.8), new THREE.MeshStandardMaterial({color:0xecf0f1}));
                post.position.y = 0.2;
                group.add(post);
                const tent = new THREE.Mesh(new THREE.ConeGeometry(0.7, 0.5, 4), matTent);
                tent.position.y = 0.65;
                tent.rotation.y = Math.PI / 4;
                group.add(tent);
                break;
            case 'blacksmith':
                const houseB = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.5, 0.6), matDark);
                houseB.position.y = 0.25;
                group.add(houseB);
                const chimney2 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), new THREE.MeshStandardMaterial({color:0x2c3e50}));
                chimney2.position.set(0.3, 0.4, 0.2);
                group.add(chimney2);
                break;
        }
        return group;
    }

    function animate3D() {
        requestAnimationFrame(animate3D);
        tileMeshes.forEach(t => t.particles.update());
        pedestrians.forEach(p => p.update()); 
        if(renderer && scene && camera) {
            renderer.render(scene, camera);
        }
        updateOverlayPositions();
    }

    function updateOverlayPositions() {
        if (!camera) return;
        const width = window.innerWidth;
        const height = window.innerHeight;
        const widthHalf = width / 2;
        const heightHalf = height / 2;

        tileMeshes.forEach((t, i) => {
            const pos = t.mesh.position.clone();
            
            // ‰øÆÊ≠£: Êú™ÈñãÊãìÂú∞„ÅÆÂ†¥Âêà„ÅØ„Ç¢„Ç§„Ç≥„É≥‰ΩçÁΩÆ„Çí‰Ωé„Åè„Åô„Çã
            if (gameState.tiles[i] && !gameState.tiles[i].unlocked) {
                pos.y += 0.5;
            } else {
                pos.y += 1.5; 
            }

            pos.project(camera);

            const x = (pos.x * widthHalf) + widthHalf;
            const y = -(pos.y * heightHalf) + heightHalf;

            if (x < -100 || x > width + 100 || y < -100 || y > height + 100) {
                t.overlayEl.style.display = 'none';
            } else {
                t.overlayEl.style.display = 'flex';
                t.overlayEl.style.left = `${x}px`;
                t.overlayEl.style.top = `${y}px`;
            }
        });
    }

    function sync3DState() {
        const reqRank = getRequiredRankForExpansion();
        
        gameState.tiles.forEach((tile, i) => {
            const tObj = tileMeshes[i];
            const mesh = tObj.mesh;
            const overlay = tObj.overlayEl;
            const ground = tObj.groundMesh;

            if (!tile.unlocked) {
                // Êú™ÈñãÊãìÂú∞
                ground.material.color.setHex(0x27ae60);
                mesh.material.color.setHex(0x2ecc71);
                tObj.buildingGroup.visible = true; 
                tObj.particles.active = false;
                
                const stateKey = `wild`;
                if (tObj.currentType !== stateKey) {
                    while(tObj.buildingGroup.children.length > 0){ 
                        tObj.buildingGroup.remove(tObj.buildingGroup.children[0]); 
                    }
                    const newModel = createBuildingMesh('wild', 0);
                    tObj.buildingGroup.add(newModel);
                    tObj.currentType = stateKey;
                }

                const canUnlock = gameState.rank >= reqRank;
                if (canUnlock) {
                      overlay.innerHTML = `<div class="lock-icon">üîí</div>`;
                } else {
                    overlay.innerHTML = "";
                }
                return;
            } else {
                // ÈñãÊãìÂú∞
                ground.material.color.setHex(0x555555);
                mesh.material.color.setHex(0xecf0f1);
            }
            
            if (selectedTileIndex === i) {
                mesh.material.emissive.setHex(0x3498db);
                mesh.material.emissiveIntensity = 0.3;
            } else {
                mesh.material.emissive.setHex(0x000000);
            }

            if (tile.type) {
                tObj.buildingGroup.visible = true;
                
                const stateKey = `${tile.type}_${tile.level}`;
                if (tObj.currentType !== stateKey) {
                    while(tObj.buildingGroup.children.length > 0){ 
                        tObj.buildingGroup.remove(tObj.buildingGroup.children[0]); 
                    }
                    const newModel = createBuildingMesh(tile.type, tile.level);
                    tObj.buildingGroup.add(newModel);
                    tObj.currentType = stateKey;
                }
                
                if (tile.finishTime) {
                    tObj.particles.active = true;
                    const remaining = Math.max(0, (tile.finishTime - Date.now()));
                    const total = getBuildTime(tile.type, tile.level); 
                    const percent = Math.min(100, Math.max(0, 100 - (remaining / total * 100)));
                    
                    overlay.innerHTML = `
                        <div class="tile-timer">${formatTimeShort(remaining/1000)}</div>
                        <div class="progress-bar-container"><div class="progress-fill" style="width:${percent}%"></div></div>
                    `;
                } else {
                    tObj.particles.active = false;
                    
                    let content = "";
                    let hasResource = false;
                    let maxRes = ""; let maxVal = 0;
                    const canCollect = (Date.now() - (tile.lastCollectTime || 0)) >= CONFIG.collectCooldown;

                    if(tile.stored && canCollect) {
                        for(let r in tile.stored) {
                            if(tile.stored[r] >= 1) {
                                hasResource = true;
                                if(tile.stored[r] > maxVal) { maxVal = tile.stored[r]; maxRes = r; }
                            }
                        }
                    }
                    if (hasResource) {
                        const icon = maxRes=='money'?'üí∞':maxRes=='food'?'üåæ':maxRes=='wood'?'üå≤':maxRes=='stone'?'ü™®':'üî©';
                        content = `<div class="harvest-bubble" onclick="collectResourceUI(${i}, event)">${icon}</div>`;
                    }
                    overlay.innerHTML = content;
                }
            } else {
                tObj.buildingGroup.visible = false;
                tObj.particles.active = false;
                tObj.currentType = null;
                overlay.innerHTML = "";
            }
        });
    }
    
    function gameLogicLoop() {
        const now = Date.now();
        let dirty = false;

        gameState.tiles.forEach(tile => {
            if (tile.unlocked) {
                if (tile.finishTime && now >= tile.finishTime) {
                    tile.level++;
                    tile.finishTime = null;
                    const xp = Math.floor(getBuildTime(tile.type, tile.level-1) / 1000);
                    addXP(xp);
                    dirty = true;
                    if(selectedTileIndex !== null) updatePanelUI();
                }
                
                if (tile.type && tile.level > 0 && !tile.finishTime) {
                    const b = BUILDINGS[tile.type];
                    const caps = getStorageCapacity(tile.type, tile.level);
                    for (let r in b.prod) {
                        if (b.prod[r] > 0) {
                            const amount = (b.prod[r] * tile.level * Math.pow(1.05, tile.level - 1));
                            if (!tile.stored[r]) tile.stored[r] = 0;
                            if (tile.stored[r] < caps[r]) {
                                tile.stored[r] = Math.min(caps[r], tile.stored[r] + amount);
                                if(Math.floor(tile.stored[r]) >= 1) dirty = true;
                            }
                        }
                    }
                }
            }
        });

        if(dirty || (now % 1000 < 100)) { 
            sync3DState();
        }
        updateHeader();
    }

    function onPointerDown(event) {
        pointerDownPos.set(event.clientX, event.clientY);
        lastPointerPos.set(event.clientX, event.clientY); // „Éë„É≥„Éã„É≥„Ç∞Áî®
        isDragging = false;
        
        // Â∑¶„ÇØ„É™„ÉÉ„ÇØ„Åæ„Åü„ÅØ„Çø„ÉÉ„ÉÅ„ÅÆÂ†¥Âêà„ÅÆ„ÅøÁßªÂãïÈñãÂßã
        if (event.button === 0 || event.pointerType === 'touch') {
            isPanning = true;
        }
    }

    function onPointerMove(event) {
        // „Éâ„É©„ÉÉ„Ç∞Âà§ÂÆöÔºà„ÇØ„É™„ÉÉ„ÇØ„Å®Âå∫Âà•„Åô„Çã„Åü„ÇÅÔºâ
        if (!isDragging && (Math.abs(event.clientX - pointerDownPos.x) > 5 || Math.abs(event.clientY - pointerDownPos.y) > 5)) {
            isDragging = true;
        }

        // „Éë„É≥„Éã„É≥„Ç∞Âá¶ÁêÜ
        if (isPanning) {
            const deltaX = event.clientX - lastPointerPos.x;
            const deltaY = event.clientY - lastPointerPos.y;
            lastPointerPos.set(event.clientX, event.clientY);

            // „Ç∫„Éº„É†‰∏≠Ôºà2Êú¨ÊåáÔºâ„ÅØÁßªÂãï„Åï„Åõ„Å™„ÅÑ
            if (touchStartDist > 0) return; 

            moveCamera(deltaX, deltaY);
        }
    }

    function onPointerUp(event) {
        isPanning = false;
        
        if (isDragging) return;

        event.preventDefault();
        
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        
        // „Éí„ÉÉ„ÉàÂà§ÂÆöÂØæË±°„Çí„Çø„Ç§„É´„ÅÆ„É°„ÉÉ„Ç∑„É•Ôºà„Å®„Å£„Åù„ÅÆÂ≠êË¶ÅÁ¥†Ôºâ„Å´ÈôêÂÆö
        // „Åì„Çå„Å´„Çà„Çä„ÄÅÊ≠©Ë°åËÄÖ„ÇÑÂú∞Èù¢„ÅÆË£èÂÅ¥„Å™„Å©„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„Åó„Åæ„ÅÜ„ÅÆ„ÇíÈò≤„Åê
        const targetObjects = tileMeshes.map(t => t.mesh);
        const intersects = raycaster.intersectObjects(targetObjects, true);

        if (intersects.length > 0) {
            let target = intersects[0].object;
            // Ë¶™„ÇíÈÅ°„Å£„Å¶„Çø„Ç§„É´„É´„Éº„Éà(userData.index„ÇíÊåÅ„Å§)„ÇíÊé¢„Åô
            while(target && target.userData.index === undefined && target.parent) {
                target = target.parent;
            }

            if (target && target.userData.index !== undefined) {
                const idx = target.userData.index;
                const collected = collectResource(idx);
                if (!collected) {
                      selectTile(idx);
                }
            }
        } else {
            closePanel();
        }
    }
    
    // „Ç´„É°„É©ÁßªÂãïÈñ¢Êï∞
    function moveCamera(dx, dy) {
        if (!camera) return;
        
        // „Ç∫„Éº„É†„É¨„Éô„É´„Å´Âøú„Åò„Å¶ÁßªÂãïÈÄüÂ∫¶„ÇíË™øÊï¥
        const speed = 0.05 / camera.zoom; 

        const vec = new THREE.Vector3();
        const quat = camera.quaternion.clone();
        
        // ÁîªÈù¢Âè≥ÊñπÂêëÔºàXËª∏Ôºâ
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(quat);
        right.y = 0; right.normalize();
        
        // ÁîªÈù¢‰∏äÊñπÂêëÔºàYËª∏Ôºâ
        const up = new THREE.Vector3(0, 1, 0).applyQuaternion(quat);
        up.y = 0; up.normalize();

        // „Ç´„É°„É©‰ΩçÁΩÆÊõ¥Êñ∞ (ÈÄÜÊñπÂêë„Å´Âãï„Åã„Åô„Å®Âú∞Èù¢„Çí„Å§„Åã„Çì„ÅßÂãï„Åã„ÅôÊÑüË¶ö„Å´„Å™„Çã)
        camera.position.addScaledVector(right, -dx * speed);
        camera.position.addScaledVector(up, dy * speed);
    }

    function setCameraZoom(val) {
        if (!camera) return;
        const minZoom = 0.5;
        const maxZoom = 2.5;
        camera.zoom = Math.max(minZoom, Math.min(maxZoom, val));
        camera.updateProjectionMatrix();
    }

    function onMouseWheel(event) {
        event.preventDefault();
        const zoomSpeed = 0.001;
        const newZoom = camera.zoom - event.deltaY * zoomSpeed;
        setCameraZoom(newZoom);
    }

    let touchStartDist = 0;
    let touchStartZoom = 1;

    function onTouchStart(event) {
        if (event.touches.length === 2) {
            isPanning = false; // „Ç∫„Éº„É†ÈñãÂßãÊôÇ„ÅØ„Éë„É≥„Éã„É≥„Ç∞ÂÅúÊ≠¢
            const dx = event.touches[0].pageX - event.touches[1].pageX;
            const dy = event.touches[0].pageY - event.touches[1].pageY;
            touchStartDist = Math.sqrt(dx * dx + dy * dy);
            touchStartZoom = camera.zoom;
        }
    }

    function onTouchMove(event) {
        // „Ç≠„É£„É≥„Éê„Çπ‰∏ä„Åß„ÅÆ„Éá„Éï„Ç©„É´„Éà„Çπ„ÇØ„É≠„Éº„É´Èò≤Ê≠¢
        if(event.target === renderer.domElement) {
             event.preventDefault();
        }

        if (event.touches.length === 2) {
            const dx = event.touches[0].pageX - event.touches[1].pageX;
            const dy = event.touches[0].pageY - event.touches[1].pageY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (touchStartDist > 0) {
                const scale = dist / touchStartDist;
                setCameraZoom(touchStartZoom * scale);
            }
        }
    }
    
    function onTouchEnd(event) {
        if (event.touches.length < 2) {
            touchStartDist = 0;
        }
    }
    
    window.collectResourceUI = function(index, e) {
        e.stopPropagation();
        collectResource(index);
    };

    function selectTile(index) {
        selectedTileIndex = index;
        sync3DState(); 
        showPanel(index);
    }
    
    window.closePanel = function() {
        selectedTileIndex = null;
        document.getElementById('control-panel').classList.remove('active');
        sync3DState();
    };

    function formatTimeShort(s){ if(s<60)return`${Math.floor(s)}s`;if(s<3600)return`${Math.floor(s/60)}m`;return`${Math.floor(s/3600)}h`; }
    function formatTime(s){ if(s<60)return`${Math.floor(s)}Áßí`;if(s<3600)return`${Math.floor(s/60)}ÂàÜ${Math.floor(s%60)}Áßí`;return`${Math.floor(s/3600)}ÊôÇÈñì`; }
    
    function getNextRankXP(r){ 
        const base = r * 500;
        if(r >= 10) return base * 4;
        return base; 
    }
    
    function getBuildTime(t,l){ const tl=l+1; if(tl===1)return BUILDINGS[t].baseTime; return Math.floor(BUILDINGS[t].baseTime*Math.pow(tl, 2.8)); }
    
    function getCost(t,l){ 
        let m=Math.pow(1.6,l) * 1.5; 
        if(l >= 10) m *= 10; // Level 11+ Cost Increase
        const r={}; 
        for(let k in BUILDINGS[t].cost) r[k]=Math.floor(BUILDINGS[t].cost[k]*m); 
        return r; 
    }
    
    function getStorageCapacity(t,l){ const b=BUILDINGS[t], s=CONFIG.storageHours*3600, c={}; for(let r in b.prod) if(b.prod[r]>0) c[r]=b.prod[r]*l*Math.pow(1.05,l-1)*s; return c; }
    
    function getExpandCost(r){ 
        // ‰øÆÊ≠£: ÂÆüÈöõ„ÅÆ„Çø„Ç§„É´Êï∞(unlockedCount)„Åß„ÅØ„Å™„Åè„ÄÅ
        // „Äå„Åù„ÅÆ„É©„É≥„ÇØ„ÅßÊú¨Êù•Âà∞ÈÅî„Åó„Å¶„ÅÑ„Çã„ÅØ„Åö„ÅÆÈÄ≤Ë°åÂ∫¶„Äç„ÇíÂü∫Ê∫ñ„Å´„Ç≥„Çπ„Éà„ÇíË®àÁÆó„Åô„Çã„ÄÇ
        // „Åì„Çå„Å´„Çà„Çä„ÄÅ„É©„É≥„ÇØ12„ÅßÊã°Âºµ„Åô„ÇãÈöõ„ÅÆË≤ªÁî®„Çí„ÄåÂÖÉ„ÅÆ„Ç≥„Éº„Éâ„ÅÆ„É©„É≥„ÇØ12„Åß„ÅÆË≤ªÁî®„Äç„Å®‰∏ÄËá¥„Åï„Åõ„Çã„ÄÇ
        const reqRank = getRequiredRankForExpansion();
        
        // ÂÖÉ„ÅÆ‰ªïÊßò„Åß„ÅØ Rank = Count - 2 „Å™„ÅÆ„Åß„ÄÅCount = Rank + 2 „Å®„Å™„Çã
        const virtualUnlockedCount = reqRank + 2;

        let b = 500 * Math.pow(1.5, virtualUnlockedCount - 4); 
        
        if(reqRank >= 6) b *= 20;
        
        let cost = {
            money: Math.floor(b),
            food: Math.floor(b*0.5),
            wood: Math.floor(b*0.3),
            stone: Math.floor(b*0.1),
            iron: 0
        };
        
        // „É©„É≥„ÇØ12‰ª•‰∏ä„ÅÆÂ†¥Âêà„ÄÅ„Åï„Çâ„Å´„Ç≥„Çπ„Éà„ÇíÂ¢óÂä†
        if (reqRank >= 12) {
            cost.money *= 20;
            cost.food *= 20;
            cost.wood *= 5;
            cost.stone *= 5;
        }
        
        return cost; 
    }
    
    function getRequiredRankForExpansion(){ 
        const unlockedCount = gameState.tiles.filter(t=>t.unlocked).length;
        
        // ÂÖÉ„ÅÆË®àÁÆóÂºè: Âü∫Êú¨ÁöÑ„Å´„ÅØ „Çø„Ç§„É´Êï∞ - 2 „ÅåÂøÖË¶Å„É©„É≥„ÇØ
        const baseReq = Math.max(2, unlockedCount - 2); 

        // „É©„É≥„ÇØ10„Åæ„Åß„ÅØ‰ªä„Åæ„ÅßÈÄö„Çä (1„É©„É≥„ÇØ1Êã°Âºµ)
        if (baseReq <= 10) {
            return baseReq;
        } else {
            // „É©„É≥„ÇØ10‰ª•Èôç„ÅØ„Éö„Éº„Çπ„ÇíËêΩ„Å®„Åô (2„É©„É≥„ÇØ1Êã°Âºµ)
            // baseReq„Åå11 (Êú¨Êù•„É©„É≥„ÇØ11„ÅßËß£Êîæ) „ÅÆÂ†¥Âêà -> „É©„É≥„ÇØ12„ÅßËß£Êîæ„Å´„Åô„Çã
            // Ë®àÁÆóÂºè: 10 + (Ë∂ÖÈÅéÂàÜ * 2)
            return 10 + (baseReq - 10) * 2;
        }
    }

    function checkAfford(c){ for(let k in c) if((gameState.resources[k]||0)<c[k]) return false; return true; }
    function payCost(c){ for(let k in c) gameState.resources[k]-=c[k]; updateHeader(); }
    function addXP(a){ gameState.xp+=a; if(gameState.xp>=getNextRankXP(gameState.rank)){ gameState.xp-=getNextRankXP(gameState.rank); gameState.rank++; document.getElementById('levelup-rank').innerText=gameState.rank; document.getElementById('modal-levelup').style.display='flex'; } }

    function getActiveBuilders() {
        return gameState.tiles.filter(t => t.finishTime !== null).length;
    }

    function getBuilderCost() {
        const extra = Math.max(0, gameState.maxBuilders - CONFIG.initialMaxBuilders);
        return Math.floor(200000 * Math.pow(1.5, extra));
    }

    function collectResource(index) {
        const t = gameState.tiles[index];
        if(!t || !t.stored) return false;
        
        const now = Date.now();
        if ((now - (t.lastCollectTime || 0)) < CONFIG.collectCooldown) {
            return false;
        }

        let total = 0, txt = "";
        for(let r in t.stored) {
            const val = Math.floor(t.stored[r]);
            if(val > 0) {
                gameState.resources[r] += val;
                t.stored[r] = 0;
                total += val;
                const icon = r=='money'?'üí∞':r=='food'?'üåæ':r=='wood'?'üå≤':r=='stone'?'ü™®':'üî©';
                txt += `${icon}+${val} `;
            }
        }
        if(total > 0) {
            t.lastCollectTime = now;
            updateHeader();
            sync3DState(); 
            const overlay = tileMeshes[index].overlayEl;
            const el = document.createElement('div');
            el.className = 'float-text';
            el.innerText = txt;
            overlay.appendChild(el);
            setTimeout(()=>el.remove(), 1000);
            return true;
        }
        return false;
    }
    
    // ‰∏ñÁïåÊã°Âºµ„ÉÅ„Çß„ÉÉ„ÇØ
    function checkAndExpandWorld() {
        const allUnlocked = gameState.tiles.every(t => t.unlocked);
        if (allUnlocked) {
            expandWorldSize();
        }
    }

    function expandWorldSize() {
        const oldSize = gameState.gridSize;
        const newSize = oldSize + 1;
        const newTiles = [];
        
        // Êñ∞„Åó„ÅÑ„Ç∞„É™„ÉÉ„Éâ„Çµ„Ç§„Ç∫„Å´Âêà„Çè„Åõ„Å¶„Éá„Éº„Çø„ÇíÂÜçÊßãÁØâ
        for(let i=0; i<newSize*newSize; i++) {
            const row = Math.floor(i / newSize);
            const col = i % newSize;
            
            // Êó¢Â≠ò„Ç®„É™„Ç¢„ÅÆÁØÑÂõ≤ÂÜÖ„Åß„ÅÇ„Çå„Å∞Êóß„Éá„Éº„Çø„Çí„Ç≥„Éî„Éº
            if (row < oldSize && col < oldSize) {
                const oldIdx = row * oldSize + col;
                newTiles.push(gameState.tiles[oldIdx]);
            } else {
                // Êñ∞Ë¶è„Ç®„É™„Ç¢
                newTiles.push({
                    type: null, level: 0, finishTime: null,
                    unlocked: false, 
                    stored: {},
                    lastCollectTime: 0
                });
            }
        }
        
        gameState.tiles = newTiles;
        gameState.gridSize = newSize;
        
        createTiles();
        updateMenuAnchor();
        showToast(`üéâ ‰∏ñÁïå„ÅåÂ∫É„Åå„Çä„Åæ„Åó„ÅüÔºÅ (${newSize}x${newSize})`);
        
        initPedestrians();
        saveGame();
    }

    function showPanel(index) {
        const tile = gameState.tiles[index];
        const p = document.getElementById('control-panel');
        const content = document.getElementById('panel-content');
        p.classList.add('active');
        updatePanelUI();
    }
    
    function updatePanelUI() {
        if(selectedTileIndex === null) return;
        const tile = gameState.tiles[selectedTileIndex];
        const content = document.getElementById('panel-content');
        if(!content) return;

        if (!tile.unlocked) {
            const req = getRequiredRankForExpansion();
            const cost = getExpandCost(gameState.rank);
            const ok = gameState.rank >= req;
            const afford = checkAfford(cost);
            content.innerHTML = `
                <div style="text-align:center;">
                    <p><strong>Êú™ÈñãÊãì„ÅÆÂúüÂú∞</strong></p>
                    <div style="background:#eee; padding:10px; border-radius:5px; text-align:left; font-size:0.9em;">
                        Êù°‰ª∂: „É©„É≥„ÇØ${req} (${ok?'‚úÖ':'‚ùå'})<br>
                        Ë≤ªÁî®: üí∞${cost.money.toLocaleString()} üåæ${cost.food.toLocaleString()} üå≤${cost.wood.toLocaleString()} ü™®${cost.stone.toLocaleString()}
                    </div>
                    <button class="action-btn" onclick="actExpand()" ${ok&&afford?'':'disabled'}>Êã°Âºµ</button>
                    ${!ok ? '<p style="color:red;font-size:0.8em">„É©„É≥„ÇØ‰∏çË∂≥</p>' : ''}
                </div>`;
            return;
        }
        
        if (!tile.type) {
            let html = "";
            if (getActiveBuilders() >= gameState.maxBuilders) {
                html += `<div style="color:var(--danger-color); font-size:0.9em; font-weight:bold; margin-bottom:5px; text-align:center;">‚ö†Ô∏è Â∑•‰∫ã„Åå„ÅÑ„Å£„Å±„ÅÑ„Åß„ÅôÔºÅ</div>`;
            }

            if (gameState.inventory && gameState.inventory.length > 0) {
                html += `<div class="inventory-section"><div class="inventory-title">üì¶ ‰øùÁÆ°Â∫´„Åã„ÇâÂÜçË®≠ÁΩÆ</div>`;
                gameState.inventory.forEach((item, idx) => {
                    const b = BUILDINGS[item.type];
                    const timeSec = getBuildTime(item.type, item.level - 1) / 1000;
                    
                    // Âà∂Èôê„ÉÅ„Çß„ÉÉ„ÇØ
                    const canRestore = checkBuildingLimit(item.type);
                    const disabledAttr = canRestore ? '' : 'disabled';
                    const warnText = canRestore ? '' : '<span style="color:red; font-size:0.8em;">(‰∏äÈôêÂà∞ÈÅî)</span>';

                    html += `
                        <div class="building-item" style="background:#fff8e1;">
                            <div class="building-info">
                                <strong>${b.icon} ${b.name} (Lv.${item.level}) ${warnText}</strong>
                                <span class="res-cost">‚è≥${formatTime(timeSec)}</span>
                            </div>
                            <button onclick="actRestore(${idx})" style="background-color:#f39c12;" ${disabledAttr}>ÈÖçÁΩÆ</button>
                        </div>
                    `;
                });
                html += `</div><div class="inventory-title" style="margin-top:10px;">‚ú® Êñ∞Ë¶èÂª∫Ë®≠</div>`;
            }

            for(let k in BUILDINGS) {
                const b = BUILDINGS[k];
                const c = getCost(k, 0);
                const afford = checkAfford(c);
                let cs = []; for(let r in c) if(c[r]>0) cs.push((r=='money'?'üí∞':r=='food'?'üåæ':r=='wood'?'üå≤':r=='stone'?'ü™®':'üî©')+c[r].toLocaleString());
                
                // Âà∂Èôê„ÉÅ„Çß„ÉÉ„ÇØ
                const canBuild = checkBuildingLimit(k);
                const disabledAttr = (afford && canBuild) ? '' : 'disabled';
                const limitText = canBuild ? '' : '<br><span style="color:red; font-size:0.8em;">‚ö†Ô∏è ‰∏äÈôê(4„Å§)„Å´ÈÅî„Åó„Å¶„ÅÑ„Åæ„Åô</span>';

                html += `
                    <div class="building-item">
                        <div class="building-info">
                            <strong>${b.icon} ${b.name}</strong>
                            <p style="font-size:0.8em; color:#666; margin:2px 0;">${b.desc}</p>
                            <span class="res-cost">${cs.join(' ')}</span>
                            <span class="res-cost">‚è≥${formatTime(getBuildTime(k,0)/1000)}</span>
                            ${limitText}
                        </div>
                        <button onclick="actBuild('${k}')" ${disabledAttr}>Âª∫Ë®≠</button>
                    </div>`;
            }
            content.innerHTML = html;
            return;
        }
        
        const b = BUILDINGS[tile.type];
        if (tile.finishTime) {
            const rem = Math.max(0, (tile.finishTime - Date.now()));
            
            let prodDiff = "";
            for(let r in b.prod) if(b.prod[r]>0) {
                const currentLevel = tile.level;
                const nextLevel = tile.level + 1;
                
                const getVal = (lvl) => {
                    if(lvl === 0) return 0;
                    return b.prod[r] * lvl * Math.pow(1.05, lvl - 1);
                };
                
                const currVal = getVal(currentLevel);
                const nextVal = getVal(nextLevel);
                const icon = (r=='money'?'üí∞':r=='food'?'üåæ':r=='wood'?'üå≤':r=='stone'?'ü™®':'üî©');
                
                prodDiff += `<div>${icon} ${currVal.toFixed(1)}/s <span style="color:#2ecc71; font-weight:bold;">‚ûû ${nextVal.toFixed(1)}/s</span></div>`;
            }

            // Cancel Button Logic
            const c = getCost(tile.type, tile.level);
            let refund = [];
            for(let r in c) if(c[r]>0) refund.push(`${(r=='money'?'üí∞':r=='food'?'üåæ':r=='wood'?'üå≤':r=='stone'?'ü™®':'üî©')}${Math.floor(c[r]*0.5).toLocaleString()}`);

            content.innerHTML = `
                <div style="text-align:center;">
                    <h3>${b.name} (Lv.${tile.level} ‚ûû ${tile.level+1})</h3>
                    <div style="background:#f9f9f9; padding:5px; border-radius:5px; margin:5px 0; font-size:0.9em;">
                        <strong>Â∑•‰∫ãÂæå„ÅÆÊÄßËÉΩ:</strong>
                        ${prodDiff}
                    </div>
                    <h2 style="color:var(--accent-color)">${formatTime(rem/1000)}</h2>
                    <p>Â∑•‰∫ã‰∏≠...</p>
                    <button class="action-btn store-btn" onclick="actStore()">üì¶ ÂõûÂèéÔºà‰øùÁÆ°Â∫´„Å∏Ôºâ</button>
                    <button class="action-btn" style="background-color:var(--danger-color); margin-top:5px;" onclick="actCancelBuild()">üö´ Â∑•‰∫ã‰∏≠Ê≠¢ (ËøîÈÇÑ: ${refund.join(' ')})</button>
                </div>`;
        } else {
            const next = tile.level+1;
            const c = getCost(tile.type, tile.level);
            const afford = checkAfford(c);
            const caps = getStorageCapacity(tile.type, tile.level);
            let cs = []; for(let r in c) if(c[r]>0) cs.push((r=='money'?'üí∞':r=='food'?'üåæ':r=='wood'?'üå≤':r=='stone'?'ü™®':'üî©')+c[r].toLocaleString());
            
            let prodInfo = ""; let storeInfo = "";
            for(let r in b.prod) if(b.prod[r]>0) {
                const val = b.prod[r]*tile.level*Math.pow(1.05, tile.level-1);
                prodInfo += `${(r=='money'?'üí∞':r=='food'?'üåæ':r=='wood'?'üå≤':r=='stone'?'ü™®':'üî©')}${val.toFixed(1)}/s `;
                storeInfo += `<div>${(r=='money'?'üí∞':r=='food'?'üåæ':r=='wood'?'üå≤':r=='stone'?'ü™®':'üî©')} ${Math.floor(tile.stored[r])}/${Math.floor(caps[r])}</div>`;
            }
            
            const buildersBusy = getActiveBuilders() >= gameState.maxBuilders;

            content.innerHTML = `
                <div style="text-align:center;">
                    <h3>${b.name} (Lv.${tile.level})</h3>
                    <p style="font-size:0.85em; color:#666; margin:0 0 10px 0;">${b.desc}</p>
                    <div style="background:#f0f0f0; padding:5px; border-radius:5px; margin-bottom:5px;">
                        <strong>ÁîüÁî£Âäõ:</strong><br>${prodInfo}
                    </div>
                    <div style="background:#e8f4f8; padding:5px; border-radius:5px; margin-bottom:10px;">
                        <strong>Ë≤ØËîµÂ∫´:</strong><br>${storeInfo}
                    </div>
                    <div style="text-align:left; font-size:0.9em; margin-bottom:5px;">
                         <strong>LvUPË≤ªÁî®:</strong> ${cs.join(' ')}<br>
                         <strong>ÊôÇÈñì:</strong> ${formatTime(getBuildTime(tile.type, tile.level)/1000)}
                    </div>
                    ${buildersBusy ? '<p style="color:red; font-size:0.9em;">‚ö†Ô∏è Â∑•‰∫ãÊû†„Åå„ÅÑ„Å£„Å±„ÅÑ„Åß„Åô</p>' : ''}
                    <button class="action-btn" onclick="actBuild('${tile.type}')" ${afford && !buildersBusy ?'':'disabled'}>„É¨„Éô„É´„Ç¢„ÉÉ„Éó</button>
                    <button class="action-btn store-btn" onclick="actStore()">üì¶ ÂõûÂèéÔºà‰øùÁÆ°Â∫´„Å∏Ôºâ</button>
                </div>`;
        }
    }

    window.actCancelBuild = function() {
        if(selectedTileIndex===null) return;
        const t = gameState.tiles[selectedTileIndex];
        if(!t.finishTime) return;
        
        if(!confirm("Â∑•‰∫ã„Çí‰∏≠Ê≠¢„Åó„Åæ„Åô„ÅãÔºü\nË≤ªÁî®„ÅÆ‰∏ÄÈÉ®(50%)„ÅåËøîÈÇÑ„Åï„Çå„Åæ„Åô„ÄÇ")) return;

        const c = getCost(t.type, t.level);
        let refundTxt = "";
        for(let r in c) {
            const amount = Math.floor(c[r] * 0.5);
            if(amount > 0) {
                gameState.resources[r] += amount;
                const icon = (r=='money'?'üí∞':r=='food'?'üåæ':r=='wood'?'üå≤':r=='stone'?'ü™®':'üî©');
                refundTxt += `${icon}+${amount.toLocaleString()} `;
            }
        }
        
        t.finishTime = null;
        if(t.level === 0) {
            t.type = null;
            t.stored = {};
        }
        
        saveGame();
        sync3DState();
        updatePanelUI();
        updateHeader();
        showToast(`Â∑•‰∫ã„Çí‰∏≠Ê≠¢„Åó„Åæ„Åó„Åü ${refundTxt}`);
    }

    window.actBuild = function(type) {
        if(selectedTileIndex===null) return;
        
        if (getActiveBuilders() >= gameState.maxBuilders) {
            showToast("‚ö†Ô∏è Â§ßÂ∑•„ÅåÂÖ®Âì°‰ΩúÊ•≠‰∏≠„Åß„Åô");
            return;
        }

        const t = gameState.tiles[selectedTileIndex];
        const lv = t.type===type ? t.level : 0;
        
        // Êñ∞Ë¶èÂª∫Ë®≠„ÅÆÂ†¥Âêà„ÅÆ„ÅøÊï∞Âà∂Èôê„ÉÅ„Çß„ÉÉ„ÇØ
        if(lv === 0 && !checkBuildingLimit(type)) {
            showToast("‚ö†Ô∏è „Åì„ÅÆÊñΩË®≠„ÅØ„Åì„Çå‰ª•‰∏äÂª∫Ë®≠„Åß„Åç„Åæ„Åõ„Çì");
            return;
        }

        const c = getCost(type, lv);
        if(checkAfford(c)) {
            payCost(c);
            t.type = type;
            t.finishTime = Date.now() + getBuildTime(type, lv);
            t.stored = {};
            saveGame();
            sync3DState();
            updatePanelUI();
            updateHeader();
        }
    }
    
    window.actStore = function() {
        if(selectedTileIndex===null) return;
        const t = gameState.tiles[selectedTileIndex];
        if(!t.type) return;

        collectResource(selectedTileIndex);

        gameState.inventory.push({ type: t.type, level: t.level });

        t.type = null;
        t.level = 0;
        t.finishTime = null;
        t.stored = {};
        
        saveGame();
        sync3DState();
        updatePanelUI();
        updateHeader(); 
    };

    window.actRestore = function(invIndex) {
        if(selectedTileIndex===null) return;
        
        if (getActiveBuilders() >= gameState.maxBuilders) {
            showToast("‚ö†Ô∏è Â§ßÂ∑•„ÅåÂÖ®Âì°‰ΩúÊ•≠‰∏≠„Åß„Åô");
            return;
        }

        if(invIndex < 0 || invIndex >= gameState.inventory.length) return;

        const item = gameState.inventory[invIndex];
        
        // Âæ©ÂÖÉÊôÇ„ÇÇÊï∞Âà∂Èôê„ÉÅ„Çß„ÉÉ„ÇØ
        if (!checkBuildingLimit(item.type)) {
            showToast("‚ö†Ô∏è „Åì„ÅÆÊñΩË®≠„ÅØ„Åì„Çå‰ª•‰∏äÈÖçÁΩÆ„Åß„Åç„Åæ„Åõ„Çì");
            return;
        }

        const t = gameState.tiles[selectedTileIndex];

        gameState.inventory.splice(invIndex, 1);

        t.type = item.type;
        t.level = Math.max(0, item.level - 1); 
        t.finishTime = Date.now() + getBuildTime(item.type, t.level);
        t.stored = {};

        saveGame();
        sync3DState();
        updatePanelUI();
        updateHeader();
    };
    
    window.actExpand = function() {
        if(selectedTileIndex===null) return;
        const c = getExpandCost(gameState.rank);
        if(checkAfford(c)) {
            payCost(c);
            gameState.tiles[selectedTileIndex].unlocked = true;
            saveGame();
            
            // Êã°ÂºµÂæå„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
            checkAndExpandWorld();
            
            sync3DState();
            updatePanelUI();
        }
    }

    window.openMenu = function() {
        const modal = document.getElementById('modal-menu');
        const content = document.getElementById('menu-content');
        
        const builderCost = getBuilderCost();
        const canBuyBuilder = gameState.resources.money >= builderCost;
        const currentUid = currentUser ? currentUser.uid : "Êú™Êé•Á∂ö(„Ç™„Éï„É©„Ç§„É≥)";
        
        // ÂÖ±ÊúâIDË®≠ÂÆö„Åå„ÅÇ„Çå„Å∞„Åù„Å°„Çâ„ÇíË°®Á§∫
        const sharedUid = localStorage.getItem('kingdomBuilder_sharedId');
        const displayUid = sharedUid ? `${sharedUid} (ÈÄ£Êê∫‰∏≠)` : currentUid;

        content.innerHTML = `
            <div class="shop-item">
                <button class="action-btn" onclick="openBuildingList()" style="width:100%; margin-bottom:10px; background-color:#3498db;">
                    üìã ÊñΩË®≠‰∏ÄË¶ß
                </button>
            </div>

            <div class="shop-item">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <div>
                        <strong>üë∑ Â§ßÂ∑•„ÅÆÂ¢óÂì°</strong><br>
                        <span style="font-size:0.9em; color:#666;">ÁèæÂú®„ÅÆ‰∫∫Êï∞: ${gameState.maxBuilders}‰∫∫</span>
                    </div>
                    <div style="text-align:right;">
                        <span style="font-size:1.1em; font-weight:bold; color:#e67e22;">üí∞${builderCost.toLocaleString()}</span>
                    </div>
                </div>
                <button class="action-btn" onclick="actBuyBuilder()" ${canBuyBuilder ? '' : 'disabled'}>
                    Ë≥ºÂÖ•„Åô„Çã
                </button>
            </div>
            
            <div class="shop-item">
                <strong>üîÑ IDÈÄ£Êê∫ (ÂêåÊúü„Éó„É¨„Ç§)</strong>
                <p style="font-size:0.8em; color:#666; margin:5px 0;">
                    ÁèæÂú®„ÅÆID („Åì„ÅÆID„ÇíÂà•Á´ØÊú´„Å´ÂÖ•Âäõ):<br>
                    <input type="text" value="${sharedUid || currentUid}" readonly style="width:100%; padding:5px; background:#eee; border:1px solid #ddd; border-radius:4px;" onclick="this.select();document.execCommand('copy');showToast('ID„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü')">
                </p>
                <div style="margin-top:10px; border-top:1px dashed #ccc; padding-top:10px;">
                    <p style="font-size:0.8em; color:#666; margin:0 0 5px 0;">Âà•Á´ØÊú´„ÅÆID„ÇíÂÖ•Âäõ„Åó„Å¶ÈÄ£Êê∫:</p>
                    <div style="display:flex; gap:5px;">
                        <input type="text" id="restore-uid-input" placeholder="ÈÄ£Êê∫„Åô„ÇãID„ÇíÂÖ•Âäõ" style="flex:1; padding:5px; border:1px solid #ddd; border-radius:4px;">
                        <button onclick="actLinkID()" style="padding:5px 10px; font-size:0.9em;">ÈÄ£Êê∫</button>
                    </div>
                    ${sharedUid ? '<div style="margin-top:5px;"><button onclick="actUnlinkID()" style="width:100%; background-color:#e74c3c;">ÈÄ£Êê∫„ÇíËß£Èô§„Åô„Çã</button></div>' : ''}
                </div>
            </div>

            <div class="shop-item">
                <strong>üìù „Ç≤„Éº„É†„Å´„Å§„ÅÑ„Å¶</strong>
                <p style="font-size:0.9em; color:#666;">
                    ÁèæÂú®„ÅÆ„Éû„ÉÉ„Éó„Çµ„Ç§„Ç∫: ${gameState.gridSize}x${gameState.gridSize}<br>
                    ÂÖ®„Å¶ÈñãÊãì„Åô„Çã„Å®‰∏ñÁïå„ÅåÂ∫É„Åå„Çä„Åæ„ÅôÔºÅ<br>
                    „Éá„Éº„Çø„ÅØ„ÇØ„É©„Ç¶„Éâ„Å´‰øùÂ≠ò„Åï„Çå„Å¶„ÅÑ„Åæ„Åô‚òÅÔ∏è
                </p>
            </div>
        `;
        
        modal.style.display = 'flex';
    };

    window.openBuildingList = function() {
        closeModal('modal-menu');
        const modal = document.getElementById('modal-building-list');
        const content = document.getElementById('building-list-content');
        
        let html = '<div style="font-weight:bold; margin-bottom:5px; color:#2c3e50;">üåç „Éû„ÉÉ„Éó‰∏ä„ÅÆÊñΩË®≠</div>';
        
        let mapBuildings = [];
        gameState.tiles.forEach((t, i) => {
            if(t.type) {
                mapBuildings.push({ tile: t, index: i });
            }
        });
        
        const getResScore = (type) => {
             const b = BUILDINGS[type];
             if(b.prod.money) return 1;
             if(b.prod.food) return 2;
             if(b.prod.wood) return 3;
             if(b.prod.stone) return 4;
             if(b.prod.iron) return 5;
             return 6;
        };
        const sortFn = (a, b) => {
             const typeA = a.tile ? a.tile.type : a.type;
             const lvlA = a.tile ? a.tile.level : a.level;
             const typeB = b.tile ? b.tile.type : b.type;
             const lvlB = b.tile ? b.tile.level : b.level;
             
             const sA = getResScore(typeA);
             const sB = getResScore(typeB);
             
             if(sA !== sB) return sA - sB;
             return lvlB - lvlA;
        };

        mapBuildings.sort(sortFn);
        
        if(mapBuildings.length === 0) {
            html += '<p style="color:#999; font-size:0.9em;">ÊñΩË®≠„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì</p>';
        } else {
            mapBuildings.forEach(item => {
                const b = BUILDINGS[item.tile.type];
                const level = item.tile.level;
                
                let prodStr = "";
                for(let r in b.prod) if(b.prod[r]>0) {
                    const val = b.prod[r] * level * Math.pow(1.05, level - 1);
                    const icon = (r=='money'?'üí∞':r=='food'?'üåæ':r=='wood'?'üå≤':r=='stone'?'ü™®':'üî©');
                    prodStr += `${icon}${val.toFixed(1)}/s `;
                }
                
                html += `
                    <div class="building-item" style="background:white; margin-bottom:5px;">
                        <div class="building-info">
                            <strong>${b.icon} ${b.name} (Lv.${level})</strong>
                            <span style="font-size:0.8em; color:#666;">${prodStr}</span>
                        </div>
                        <button onclick="focusTile(${item.index})" style="padding:5px 10px; font-size:0.8em;">Ë©≥Á¥∞</button>
                    </div>
                `;
            });
        }
        
        html += '<div style="font-weight:bold; margin-top:15px; margin-bottom:5px; color:#7f8c8d; border-top:1px dashed #ccc; padding-top:10px;">üì¶ ‰øùÁÆ°Â∫´„ÅÆÊñΩË®≠</div>';
        
        if(gameState.inventory.length === 0) {
            html += '<p style="color:#999; font-size:0.9em;">‰øùÁÆ°Â∫´„ÅØÁ©∫„Åß„Åô</p>';
        } else {
            // Ë°®Á§∫Áî®„Å´„ÇΩ„Éº„Éà„Åó„Åü„Ç≥„Éî„Éº„Çí‰ΩúÊàêÔºà„Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Çí‰øùÊåÅ„Åó„Å™„ÅÑ„Å®„É™„Çπ„Éà„Ç¢„Åß„Éê„Ç∞„ÇãÂèØËÉΩÊÄß„Åå„ÅÇ„Çã„Åü„ÇÅ„ÄÅË°®Á§∫„ÅÆ„ÅøÔºâ
            // Ê≥®: ‰ªäÂõû„ÅÆÂÆüË£Ö„Åß„ÅØ„Ç§„É≥„Éô„É≥„Éà„É™‰∏ÄË¶ß„Å´Êìç‰Ωú„Éú„Çø„É≥„Åå„Å™„ÅÑ„Åü„ÇÅ„ÄÅË°®Á§∫È†ÜÂ∫è„ÇíÂ§â„Åà„Å¶„ÇÇÂïèÈ°å„Å™„ÅÑ
            let sortedInv = [...gameState.inventory];
            sortedInv.sort(sortFn);

            sortedInv.forEach(item => {
                const b = BUILDINGS[item.type];
                html += `
                    <div class="building-item" style="background:#f5f5f5; color:#666;">
                        <div class="building-info">
                            <strong>${b.icon} ${b.name} (Lv.${item.level})</strong>
                            <span style="font-size:0.8em;">ÂÜçË®≠ÁΩÆÂæÖ„Å°</span>
                        </div>
                        <span style="font-size:0.8em; background:#eee; padding:3px 6px; border-radius:4px;">‰øùÁÆ°‰∏≠</span>
                    </div>
                `;
            });
        }
        
        content.innerHTML = html;
        modal.style.display = 'flex';
    };

    window.focusTile = function(index) {
        closeModal('modal-building-list');
        selectTile(index);
        
        // „Ç´„É°„É©ÁßªÂãï
        const tObj = tileMeshes[index];
        if(tObj && camera) {
            const targetX = tObj.mesh.position.x;
            const targetZ = tObj.mesh.position.z;
            
            // ÁèæÂú®„ÅÆY, Zoom, Rotation„ÇíÁ∂≠ÊåÅ„Åó„Å§„Å§X,Z„Å†„ÅëÁßªÂãï
            // OrthographicCamera„Å™„ÅÆ„Åß„ÄÅX,ZÁßªÂãï„Å†„Åë„ÅßOKÔºàsetCameraZoomÁ≠â„ÅØÁ∂≠ÊåÅÔºâ
            // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Å™„Åó„ÅßÂç≥ÁßªÂãï„Åï„Åõ„Çã
            const offset = 20; // ÂàùÊúü‰ΩçÁΩÆ„ÅÆ„Ç™„Éï„Çª„ÉÉ„Éà (20, 20, 20) „ÇíËÄÉÊÖÆ
            // „Ç´„É°„É©„ÅØ (20, 20, 20) „Åã„Çâ (0,0,0) „ÇíË¶ã„Å¶„ÅÑ„Çã„ÄÇ
            // „Çø„Éº„Ç≤„ÉÉ„Éà„ÇíÁîªÈù¢‰∏≠Â§Æ„Å´„Åô„Çã„Å´„ÅØ„ÄÅ„Ç´„É°„É©‰ΩçÁΩÆ„Çí„Çø„Éº„Ç≤„ÉÉ„ÉàÂ∫ßÊ®ôÂàÜ„Åö„Çâ„Åõ„Å∞„Çà„ÅÑÔºü
            // OrthographicCamera„Åß„ÅÆ„Éë„É≥„Éã„É≥„Ç∞„ÅØ camera.position „ÇíÂãï„Åã„Åô„Åì„Å®„ÅßÂÆüÁèæ„Åó„Å¶„ÅÑ„Çã„ÄÇ
            // moveCameraÈñ¢Êï∞„ÅØÁõ∏ÂØæÁßªÂãï„Å†„Åå„ÄÅ„Åì„Åì„Åß„ÅØÁµ∂ÂØæ‰ΩçÁΩÆ„Å∏Ë°å„Åç„Åü„ÅÑ„ÄÇ
            
            // ÁèæÂú®„ÅÆ„Ç´„É°„É©‰ΩçÁΩÆ„Åã„Çâ„ÄÅLookAt‰∏≠ÂøÉÔºà„Å®‰ªÆÂÆö„Åï„Çå„ÇãÁÇπÔºâ„Å∏„ÅÆ„Ç™„Éï„Çª„ÉÉ„Éà„ÇíÁ∂≠ÊåÅ„Åó„Å¶ÁßªÂãï„Åó„Åü„ÅÑ„Åå„ÄÅ
            // Á∞°ÊòìÁöÑ„Å´„ÄÅ„Çø„Ç§„É´„ÅÆÁúü‰∏ä„Å´„Ç´„É°„É©„ÇíÊåÅ„Å£„Å¶„Åè„Çã„Çà„ÅÜ„Å™ÁßªÂãï„Çí„Åô„Çã„ÄÇ
            // ÂàùÊúü„Ç´„É°„É©: pos(20,20,20), lookAt(0,0,0) -> ÊñπÂêë„Éô„ÇØ„Éà„É´(1,1,1)
            
            // Êó¢Â≠ò„ÅÆ„Éë„É≥„Éã„É≥„Ç∞„É≠„Ç∏„ÉÉ„ÇØ„Å´Âêà„Çè„Åõ„Çã„Åü„ÇÅ„ÄÅ„Ç´„É°„É©‰ΩçÁΩÆ„ÇíÁõ¥Êé•Êìç‰Ωú
            // X„Å®Z„Çí„Çø„Éº„Ç≤„ÉÉ„Éà„Å´Âêà„Çè„Åõ„Å¶ÁßªÂãï
            // „Åü„Å†„ÅóÊñú„ÇÅË¶ñÁÇπ„Å™„ÅÆ„Åß„ÄÅÂçòÁ¥î„Å´ x=targetX „Åß„ÅØ„Åö„Çå„Çã„ÄÇ
            // Êó¢Â≠ò„ÅÆmoveCamera„ÅÆÈÄÜÁÆó„ÅØË§áÈõë„Å™„ÅÆ„Åß„ÄÅ„Éë„É≥„Éã„É≥„Ç∞‰ΩçÁΩÆÂ§âÊï∞„Çí„É™„Çª„ÉÉ„Éà„Åó„Å¶ÂÜçË®àÁÆó„Å™„Å©„ÅåÁêÜÊÉ≥„Å†„Åå...
            
            // „Ç∑„É≥„Éó„É´„Å´: „Ç´„É°„É©„ÅÆX,Z„Çí„ÄÅ„Çø„Éº„Ç≤„ÉÉ„Éà„ÅÆX,Z„Å´„Ç™„Éï„Çª„ÉÉ„Éà„ÇíÂä†„Åà„Åü„ÇÇ„ÅÆ„Å´„Åô„Çã
            camera.position.x = targetX + 20;
            camera.position.z = targetZ + 20;
            // Y„ÅØÂ§â„Åà„Å™„ÅÑ
            camera.updateProjectionMatrix();
        }
    };

    window.actLinkID = function() {
        const input = document.getElementById('restore-uid-input');
        const targetUid = input.value.trim();
        if(!targetUid) return showToast("‚ö†Ô∏è ID„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ");
        
        if(!confirm("‚ö†Ô∏è IDÈÄ£Êê∫„É¢„Éº„Éâ\n\nÂÖ•Âäõ„Åó„ÅüID„ÅÆ„Éá„Éº„Çø„Çí„ÄéÂÖ±Êúâ„Äè„Åó„Å¶„Éó„É¨„Ç§„Åó„Åæ„Åô„ÄÇ\nË§áÊï∞„ÅÆÁ´ØÊú´„ÅßÂêå„Åò„Éá„Éº„Çø„ÇíÂêåÊúü„Åß„Åç„Åæ„Åô„ÄÇ\n(‚ÄªFirebase„ÅÆ„É´„Éº„É´Ë®≠ÂÆö„ÅåÂøÖË¶Å„Åß„Åô)\n\nÂàá„ÇäÊõø„Åà„Åæ„Åô„ÅãÔºü")) return;
        
        localStorage.setItem('kingdomBuilder_sharedId', targetUid);
        location.reload();
    };
    
    window.actUnlinkID = function() {
        if(!confirm("ÈÄ£Êê∫„ÇíËß£Èô§„Åó„ÄÅÊú¨Êù•„ÅÆËá™ÂàÜ„ÅÆID„Å´Êàª„Çä„Åæ„Åô„ÅãÔºü")) return;
        localStorage.removeItem('kingdomBuilder_sharedId');
        location.reload();
    }

    window.actBuyBuilder = function() {
        const cost = getBuilderCost();
        if (gameState.resources.money >= cost) {
            gameState.resources.money -= cost;
            gameState.maxBuilders++;
            saveGame();
            updateHeader();
            openMenu();
        }
    };

    function updateHeader() {
        for(let k in gameState.resources) document.getElementById('display-'+k).innerText = Math.floor(gameState.resources[k]).toLocaleString();
        document.getElementById('display-rank').innerText = gameState.rank;
        document.getElementById('display-next-xp').innerText = (getNextRankXP(gameState.rank)-gameState.xp).toLocaleString();
        document.getElementById('display-xp-bar').style.width = Math.min(100, (gameState.xp/getNextRankXP(gameState.rank))*100)+'%';
        
        const active = getActiveBuilders();
        const max = gameState.maxBuilders;
        const builderEl = document.getElementById('display-builders');
        builderEl.innerText = `${active}/${max}`;
        builderEl.style.color = active >= max ? 'red' : '#2c3e50';
    }

    function onWindowResize() {
        const c = document.getElementById('game-container');
        if (!c) return;
        const width = c.clientWidth || window.innerWidth;
        const height = c.clientHeight || window.innerHeight;
        const aspect = width / height;
        const d = 10;
        
        if (camera && renderer) {
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }
    }

    // Process Offline Income after Cloud Load
    function processOfflineProgress() {
        try {
            const now = Date.now();
            const sec = (now - gameState.lastSaveTime)/1000;
            if(sec > 10) {
                let rep = ""; let built = 0; let earn = {};
                gameState.tiles.forEach(t => {
                    if(t.finishTime && t.finishTime <= now) { t.level++; t.finishTime=null; built++; gameState.xp+=Math.floor(getBuildTime(t.type,t.level-1)/1000); }
                    if(t.type && t.level>0 && !t.finishTime) {
                        const b=BUILDINGS[t.type]; const caps=getStorageCapacity(t.type,t.level);
                        for(let r in b.prod) if(b.prod[r]>0) {
                            if(!earn[r]) earn[r]=0;
                            const add = Math.min(caps[r]-(t.stored[r]||0), b.prod[r]*t.level*Math.pow(1.05,t.level-1)*sec);
                            if(add>0) { t.stored[r]=(t.stored[r]||0)+add; earn[r]+=add; }
                        }
                    }
                });
                if(built>0) rep+=`<div>üèóÔ∏è ${built}‰ª∂ÂÆå‰∫Ü</div>`;
                for(let r in earn) if(earn[r]>1) rep+=`<div>+${Math.floor(earn[r]).toLocaleString()} ${r}</div>`;
                if(rep) { document.getElementById('offline-report').innerHTML=rep; document.getElementById('modal-offline').style.display='flex'; }
            }
            gameState.lastSaveTime = now;
        } catch (e) {
            console.error(e);
        }
    }
    
    window.closeModal = function(id) { document.getElementById(id).style.display='none'; }

</script>
</body>
</html>
