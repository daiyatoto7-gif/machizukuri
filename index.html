<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kingdom Builder 3D (Visual Update)</title>

    <!-- „Éá„Éê„ÉÉ„Ç∞Áî®„Çπ„Çø„Ç§„É´ -->
    <style>
        #debug-log {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: auto;
            max-height: 100px;
            overflow-y: scroll;
            background: rgba(0, 0, 0, 0.7);
            color: lime;
            font-family: monospace;
            font-size: 10px;
            z-index: 9999;
            pointer-events: none;
            padding: 5px;
            box-sizing: border-box;
            display: none;
        }

        .error-msg {
            color: #ff5555;
        }
    </style>

    <!-- Three.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

    <style>
        :root {
            --bg-color: #f0f2f5;
            --panel-bg: #ffffff;
            --accent-color: #3498db;
            --text-color: #2c3e50;
            --xp-color: #f1c40f;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            overflow: hidden;
            user-select: none;
            height: 100vh;
            width: 100vw;
        }

        /* „Ç≠„É£„É≥„Éê„Çπ„ÅÆ„Çø„ÉÉ„ÉÅ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÁÑ°ÂäπÂåñ„Åó„Å¶„Éñ„É©„Ç¶„Ç∂„Çπ„ÇØ„É≠„Éº„É´„ÇíÈò≤„Åê */
        canvas {
            touch-action: none;
        }

        header {
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            padding: 5px 0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            position: fixed;
            top: 0;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }

        header>* {
            pointer-events: auto;
        }

        .status-bar {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .rank-badge {
            background: var(--accent-color);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.9em;
        }

        .xp-container {
            width: 150px;
            height: 10px;
            background: #eee;
            border-radius: 5px;
            overflow: hidden;
        }

        .xp-fill {
            height: 100%;
            background: var(--xp-color);
            width: 0%;
            transition: width 0.5s;
        }

        .resource-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 0.85em;
            justify-content: center;
            padding: 0 10px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            /* ËÉåÊôØ„ÇíÁ©∫„Å®Âú∞Âπ≥Á∑ö„Çí„Ç§„É°„Éº„Ç∏„Åó„Åü„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„Å´Â§âÊõ¥ */
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 60%, #A9DFBF 100%);
        }

        #ui-overlay-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            overflow: hidden;
        }

        .overlay-item {
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .tile-timer {
            font-size: 10px;
            font-weight: bold;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 2px 4px;
            border-radius: 4px;
            margin-bottom: 2px;
            white-space: nowrap;
        }

        .progress-bar-container {
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #2ecc71;
            width: 0%;
            transition: width 0.2s linear;
        }

        .harvest-bubble {
            background: white;
            border: 2px solid #f39c12;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            animation: bounce 1s infinite alternate;
            cursor: pointer;
        }

        @keyframes bounce {
            from {
                transform: translateY(0);
            }

            to {
                transform: translateY(-5px);
            }
        }

        .lock-icon {
            font-size: 24px;
            opacity: 0.6;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .float-text {
            position: absolute;
            color: #27ae60;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 0 #fff;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
            z-index: 100;
        }

        @keyframes floatUp {
            0% {
                transform: translate(-50%, -50%);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -150%);
                opacity: 0;
            }
        }

        #control-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            max-height: 40vh;
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            z-index: 30;
            display: none;
            flex-direction: column;
        }

        #control-panel.active {
            display: flex;
        }

        #panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--bg-color);
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        #panel-title {
            margin: 0;
            font-size: 1.1em;
            color: var(--accent-color);
        }

        /* Èñâ„Åò„Çã„Éú„Çø„É≥„ÅÆ„Çø„ÉÉ„ÉóÈ†òÂüü„ÇíÊã°Â§ß */
        .close-btn {
            cursor: pointer;
            font-weight: bold;
            padding: 10px 15px;
            color: #999;
            font-size: 1.2em;
            margin: -10px -10px -10px 0;
        }

        .close-btn:hover {
            color: #666;
        }

        #panel-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
        }

        .building-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #eee;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .building-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .res-cost {
            font-size: 0.85em;
            color: #666;
        }

        button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            background-color: var(--accent-color);
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 0.9em;
        }

        button.action-btn {
            width: 100%;
            padding: 12px;
            font-size: 1em;
            margin-top: 5px;
        }

        button.store-btn {
            background-color: var(--text-color);
            margin-top: 10px;
        }

        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        .inventory-section {
            margin-top: 15px;
            border-top: 2px dashed #eee;
            padding-top: 10px;
        }

        .inventory-title {
            font-size: 0.9em;
            font-weight: bold;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* „É°„Éã„É•„Éº„Éú„Çø„É≥: Âõ∫ÂÆöÈÖçÁΩÆ (Âè≥‰∏ä„Å´Â§âÊõ¥) */
        #menu-btn {
            position: fixed;
            top: 15px;
            right: 15px;
            /* Âè≥ÂÅ¥„Å´ÈÖçÁΩÆ„Åó„Å¶„É©„É≥„ÇØË°®Á§∫„Å®Ë¢´„Çâ„Å™„ÅÑ„Çà„ÅÜ„Å´ */
            background: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            z-index: 50;
            pointer-events: auto;
        }

        #menu-btn:hover {
            background: #f0f0f0;
        }

        /* „É°„Éã„É•„Éº„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Çπ„Çø„Ç§„É´ */
        .shop-item {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            text-align: left;
        }

        #toast-notification {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 100;
            display: none;
            pointer-events: none;
            animation: fadeInOut 3s forwards;
            white-space: nowrap;
        }

        @keyframes fadeInOut {
            0% {
                opacity: 0;
                top: 90px;
            }

            10% {
                opacity: 1;
                top: 80px;
            }

            90% {
                opacity: 1;
                top: 80px;
            }

            100% {
                opacity: 0;
                top: 70px;
            }
        }

        /* „Ç¢„ÇØ„Ç∑„Éß„É≥„É¢„Éº„Éâ„Éê„Éº (ÁßªÂãï„É¢„Éº„ÉâÁî®) */
        #action-mode-bar {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 25px;
            border-radius: 30px;
            z-index: 100;
            align-items: center;
            gap: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            width: max-content;
        }

        /* „É≠„Éº„ÉâÁîªÈù¢ */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #dcecf5 0%, #b0c4de 100%);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }

        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--accent-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* „Ç´„Çø„É≠„Ç∞Áî®„Çπ„Çø„Ç§„É´ */
        .catalog-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 12px;
            padding: 10px;
        }

        .catalog-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px 5px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .catalog-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border-color: var(--accent-color);
        }

        .catalog-icon {
            font-size: 2.5em;
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.1));
        }

        .catalog-name {
            font-size: 0.85em;
            font-weight: bold;
            color: var(--text-color);
        }

        .catalog-detail {
            padding: 10px;
            animation: fadeIn 0.3s;
            text-align: left;
        }

        .detail-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            border-bottom: 2px solid #f0f2f5;
            padding-bottom: 15px;
        }

        .detail-icon {
            font-size: 3.5em;
            background: white;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .detail-title h4 {
            margin: 0 0 5px 0;
            font-size: 1.4em;
            color: var(--accent-color);
        }

        .detail-category {
            font-size: 0.8em;
            color: #95a5a6;
            background: #f0f2f5;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .detail-desc {
            background-color: #fff8e1;
            /* Ë™≠„Åø„ÇÑ„Åô„ÅÑ„ÇØ„É™„Éº„É†Ëâ≤ */
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            line-height: 1.8;
            font-size: 1em;
            color: #5d4037;
            border-left: 5px solid #f1c40f;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .detail-stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .stat-card {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #eee;
        }

        .tile-timer {
            font-size: 10px;
            color: #fff;
            text-shadow: 1px 1px 2px #000, -1px -1px 2px #000, 1px -1px 2px #000, -1px 1px 2px #000;
            margin-bottom: 2px;
            white-space: nowrap;
        }

        .stat-label {
            font-size: 0.75em;
            color: #7f8c8d;
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
            text-transform: uppercase;
        }

        .stat-content {
            font-size: 0.95em;
            font-weight: bold;
            color: var(--text-color);
        }

        .back-btn {
            background: transparent;
            color: #7f8c8d;
            border: 1px solid #ccc;
            margin-bottom: 10px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .back-btn:hover {
            background: #f0f2f5;
        }
    </style>
</head>

<body>

    <div id="debug-log"></div>
    <div id="toast-notification"></div>

    <div id="loading-screen">
        <div class="loader"></div>
        <div id="loading-text" style="font-weight:bold; color:#2c3e50;">Connecting to Cloud...</div>
    </div>

    <div id="menu-btn" onclick="openMenu()">‚â°</div>

    <header>
        <div class="status-bar">
            <div class="rank-badge">RANK <span id="display-rank">1</span></div>
            <div class="xp-container">
                <div class="xp-fill" id="display-xp-bar"></div>
            </div>
            <div style="font-size:0.8em; color:#7f8c8d;">Next: <span id="display-next-xp">0</span> XP</div>
        </div>
        <div class="resource-bar">
            <div class="res-item">üí∞ <span id="display-money">0</span></div>
            <div class="res-item">üåæ <span id="display-food">0</span></div>
            <div class="res-item">üå≤ <span id="display-wood">0</span></div>
            <div class="res-item">ü™® <span id="display-stone">0</span></div>
            <div class="res-item">üî© <span id="display-iron">0</span></div>
            <div class="res-item">üíß <span id="display-water">0</span></div>
            <div class="res-item" style="border-left:1px solid #ddd; padding-left:10px; color:#e67e22;">üë∑ <span
                    id="display-builders">0/4</span></div>
        </div>
    </header>

    <div id="game-container"></div>
    <div id="ui-overlay-layer"></div>

    <div id="control-panel">
        <div id="panel-header">
            <h2 id="panel-title">„Çø„Ç§„É´ÈÅ∏Êäû</h2>
            <div class="close-btn" onclick="closePanel()">‚úï</div>
        </div>
        <div id="panel-content"></div>
    </div>

    <!-- ÁßªÂãï„É¢„Éº„ÉâÁî®„ÅÆ„Ç¨„Ç§„Éâ„Éê„Éº -->
    <div id="action-mode-bar">
        <span id="action-mode-text">ÁßªÂãï„Åô„ÇãÊñΩË®≠„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</span>
        <div style="display:flex; gap:10px;">
            <button id="action-rotate-btn" class="action-btn" onclick="actRotate()"
                style="background-color:#3498db; display:none; padding:5px 15px;">üîÑ ÂõûËª¢</button>
            <button class="action-btn" onclick="cancelMoveMode()"
                style="background-color:#e74c3c; padding:5px 15px;">ÁµÇ‰∫Ü</button>
        </div>
    </div>

    <div id="modal-offline" class="modal">
        <div class="modal-content">
            <h3>„Åä„Åã„Åà„Çä„Å™„Åï„ÅÑÔºÅ</h3>
            <p>‰∏çÂú®„ÅÆÈñì„Å´ÁîüÁî£„Åï„Çå„ÅüË≥áÊ∫ê„Åå<br>Ë≤ØËîµÂ∫´„Å´‰øùÁÆ°„Åï„Çå„Åæ„Åó„Åü„ÄÇ</p>
            <div style="text-align:left; background:#f9f9f9; padding:10px; border-radius:5px; margin:10px 0;">
                <div id="offline-report"></div>
            </div>
            <button onclick="closeModal('modal-offline')" class="action-btn">ÂÜçÈñã„Åô„Çã</button>
        </div>
    </div>

    <div id="modal-levelup" class="modal">
        <div class="modal-content">
            <h3 style="color:var(--accent-color);">üéâ „É©„É≥„ÇØ„Ç¢„ÉÉ„ÉóÔºÅ üéâ</h3>
            <p style="font-size:1.2em; font-weight:bold;">RANK <span id="levelup-rank"></span> „Å´„Å™„Çä„Åæ„Åó„ÅüÔºÅ</p>
            <button onclick="closeModal('modal-levelup')" class="action-btn">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <div id="modal-confirm" class="modal" style="z-index:200;">
        <div class="modal-content">
            <h3 id="modal-confirm-title">Á¢∫Ë™ç</h3>
            <p id="modal-confirm-msg" style="margin:20px 0; line-height:1.5;"></p>
            <div style="display:flex; justify-content:space-around; margin-top:20px;">
                <button id="modal-confirm-yes" class="action-btn" style="width:100px;">„ÅØ„ÅÑ</button>
                <button onclick="closeModal('modal-confirm')" class="action-btn"
                    style="width:100px; background-color:#95a5a6;">„ÅÑ„ÅÑ„Åà</button>
            </div>
        </div>
    </div>

    <div id="modal-menu" class="modal">
        <div class="modal-content">
            <h3 style="margin-top:0;">„É°„Éã„É•„Éº</h3>
            <div id="menu-content" style="max-height:60vh; overflow-y:auto;"></div>
            <button onclick="closeModal('modal-menu')" class="action-btn"
                style="background-color:#95a5a6; margin-top:20px;">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <!-- ÊñΩË®≠‰∏ÄË¶ßÁî®„É¢„Éº„ÉÄ„É´ -->
    <div id="modal-building-list" class="modal">
        <div class="modal-content"
            style="max-width:500px; max-height:80vh; overflow:hidden; display:flex; flex-direction:column;">
            <h3 style="margin-top:0;">üìã ÊñΩË®≠‰∏ÄË¶ß</h3>
            <div id="building-list-content" style="flex:1; overflow-y:auto; text-align:left;"></div>
            <button onclick="closeModal('modal-building-list')" class="action-btn"
                style="background-color:#95a5a6; margin-top:10px;">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <div id="modal-catalog" class="modal">
        <div class="modal-content"
            style="max-width:500px; max-height:80vh; overflow:hidden; display:flex; flex-direction:column; background-color:#f8f9fa;">
            <h3 style="margin-top:0; color:#2c3e50;">üìñ Âª∫Ë®≠„Ç´„Çø„É≠„Ç∞</h3>
            <div id="catalog-content" style="flex:1; overflow-y:auto; text-align:left; padding:5px;"></div>
            <button onclick="closeModal('modal-catalog')" class="action-btn"
                style="background-color:#95a5a6; margin-top:10px;">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, doc, setDoc, getDoc, collection } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';

        // Global Firebase Variables
        let firebaseConfig;
        let appId;
        let offlineMode = false; // „ÇØ„É©„Ç¶„Éâ„Ç®„É©„ÉºÊôÇ„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Éï„É©„Ç∞

        // Áí∞Â¢ÉÂà§ÂÆö
        if (typeof __firebase_config !== 'undefined') {
            firebaseConfig = JSON.parse(__firebase_config);
            appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        } else {
            firebaseConfig = {
                apiKey: "AIzaSyBzJkeWGrzm5pFKAuX_Vkk-w1w4tsKHsDo",
                authDomain: "kingdom-builder-cdfb9.firebaseapp.com",
                projectId: "kingdom-builder-cdfb9",
                storageBucket: "kingdom-builder-cdfb9.firebasestorage.app",
                messagingSenderId: "672874506084",
                appId: "1:672874506084:web:573a57495e5a350d4fbc71",
                measurementId: "G-F6JMJJR146"
            };
            appId = firebaseConfig.projectId;
        }

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let currentUser = null;
        let userDocRef = null;
        let currentDocId = null;

        // --- Firebase Init ---
        async function initFirebase() {
            const loadingText = document.getElementById('loading-text');

            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Auth failed:", error);
                if (error.code === 'auth/requests-from-referer-blocked' || error.message.includes('referer')) {
                    console.warn("Domain restricted: Switching to Offline Mode.");
                    offlineMode = true;
                    loadingText.innerText = "Offline Mode (Cloud Disabled)";
                    setTimeout(loadGameFromCloud, 1000);
                    return;
                }
                try {
                    await signInAnonymously(auth);
                } catch (e) {
                    console.error("Retry Auth Failed, using offline", e);
                    offlineMode = true;
                    loadingText.innerText = "Offline Mode";
                    setTimeout(loadGameFromCloud, 1000);
                    return;
                }
            }

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUser = user;

                    const sharedId = localStorage.getItem('kingdomBuilder_sharedId');
                    if (sharedId) {
                        currentDocId = sharedId;
                        console.log("Using Shared ID:", currentDocId);
                    } else {
                        currentDocId = user.uid;
                    }

                    userDocRef = doc(db, 'artifacts', appId, 'users', currentDocId, 'gameData', 'saveSlot1');

                    loadingText.innerText = "Loading Kingdom...";
                    await loadGameFromCloud();
                }
            });
        }

        // --- Cloud Load & Save Logic ---
        async function loadGameFromCloud() {
            try {
                let data = null;
                let loadedFrom = "";

                if (!offlineMode && userDocRef) {
                    try {
                        const snap = await getDoc(userDocRef);
                        if (snap.exists()) {
                            data = snap.data();
                            loadedFrom = "Cloud";
                        }
                    } catch (e) {
                        console.warn("Cloud read failed, falling back to local:", e);
                    }
                }

                if (!data) {
                    const backup = localStorage.getItem('kingdomBuilderSave');
                    if (backup) {
                        try {
                            data = JSON.parse(backup);
                            loadedFrom = "Local Backup";
                        } catch (e) { }
                    }
                }

                if (!data) {
                    const legacyKeys = ['kingdomBuilderSave', 'kb_save_data', 'gameState'];
                    for (const key of legacyKeys) {
                        const localRaw = localStorage.getItem(key);
                        if (localRaw) {
                            try {
                                const localData = JSON.parse(localRaw);
                                if (localData && (localData.resources || localData.tiles)) {
                                    data = localData;
                                    loadedFrom = "Legacy Migration";
                                    showToast("üì¶ Âè§„ÅÑ„Éá„Éº„Çø„ÇíÂºï„ÅçÁ∂ô„Åé„Åæ„Åó„ÅüÔºÅ");
                                    break;
                                }
                            } catch (e) { }
                        }
                    }
                }

                if (data) {
                    // Deep merge for resources to preserve new keys added in code
                    const savedResources = data.resources || {};
                    const currentResources = gameState.resources || {};

                    // Merge: Use saved value if exists, otherwise keep current (default) value
                    const mergedResources = { ...currentResources, ...savedResources };

                    gameState = { ...gameState, ...data };
                    gameState.resources = mergedResources; // Apply merged resources

                    processOfflineProgress();
                    console.log(`Loaded game from: ${loadedFrom}`);
                    saveGameToCloud(true);
                } else {
                    console.log("New User: Creating initial state.");
                    saveGameToCloud(true);
                }

            } catch (e) {
                console.error("Load failed:", e);
                showToast("„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü");
            }

            initGame();

            const loader = document.getElementById('loading-screen');
            if (loader) {
                loader.style.opacity = 0;
                setTimeout(() => loader.style.display = 'none', 500);
            }
        }

        async function saveGameToCloud(silent = false) {
            gameState.lastSaveTime = Date.now();

            try {
                const dataToSave = JSON.parse(JSON.stringify(gameState));
                localStorage.setItem('kingdomBuilderSave', JSON.stringify(dataToSave));

                if (!offlineMode && currentUser && userDocRef) {
                    await setDoc(userDocRef, dataToSave);
                    // if (!silent) showToast("‚òÅÔ∏è ‰øùÂ≠ò„Åó„Åæ„Åó„Åü"); // Suppressed
                } else {
                    // if (!silent) showToast("üíæ ‰øùÂ≠ò„Åó„Åæ„Åó„Åü („Ç™„Éï„É©„Ç§„É≥)"); // Suppressed
                }
            } catch (e) {
                console.error("Save failed:", e);
                // Always show error, ignoring silent flag for critical failure (or keep logic)
                // User requirement: "Only show if failed"
                if (!offlineMode) showToast("‚ö†Ô∏è „ÇØ„É©„Ç¶„Éâ‰øùÂ≠òÂ§±Êïó(„É≠„Éº„Ç´„É´„Å´‰øùÂ≠ò)");
            }
        }

        window.saveGame = saveGameToCloud;

        window.onload = function () {
            try {
                initFirebase();
            } catch (e) {
                console.error("Firebase init crash:", e);
                document.getElementById('loading-text').innerText = "Offline Mode";
                offlineMode = true;
                setTimeout(() => {
                    loadGameFromCloud();
                }, 1000);
            }
        };


        // --- Game Logic ---

        function log(msg, isError = false) {
            const el = document.getElementById('debug-log');
            if (!el) return;
            const line = document.createElement('div');
            line.textContent = `> ${msg}`;
            if (isError) {
                line.className = 'error-msg';
                el.style.display = 'block';
                console.error(msg);
            } else {
                console.log(msg);
            }
            el.appendChild(line);
            el.scrollTop = el.scrollHeight;
        }

        function showToast(msg) {
            const t = document.getElementById('toast-notification');
            t.innerText = msg;
            t.style.display = 'none';
            void t.offsetWidth; // trigger reflow
            t.style.display = 'block';
        }

        window.onerror = function (message, source, lineno, colno, error) {
            log(`Global Error: ${message} at line ${lineno}`, true);
            return false;
        };

        const CONFIG = {
            initialGridSize: 5,
            fps: 30,
            autoSaveInterval: 10000,
            initialUnlocked: [6, 7, 8, 11, 12, 13],
            storageHours: 8,
            collectCooldown: 30000,
            initialMaxBuilders: 4
        };

        const BUILDINGS = {
            house: { name: "Ê∞ëÂÆ∂", icon: "üè†", desc: "‰ΩèÊ∞ë„Åå‰Ωè„ÇÄÂÆ∂„ÄÇ„ÅäÈáë„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { money: 2 }, cost: { money: 20, food: 10 }, baseTime: 2000 },
            farm: { name: "Áïë", icon: "üåæ", desc: "‰ΩúÁâ©„ÇíËÇ≤„Å¶„Åæ„Åô„ÄÇÈ£üÊñô„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { food: 2 }, cost: { money: 30, wood: 10 }, baseTime: 2000 },
            lumber: { name: "‰ºêÊé°ÊâÄ", icon: "üå≤", desc: "Êú®„ÇíÂàá„ÇäÂá∫„Åó„Åæ„Åô„ÄÇÊú®Êùê„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { wood: 1 }, cost: { money: 50, food: 20 }, baseTime: 3000 },
            quarry: { name: "Êé°Áü≥Â†¥", icon: "ü™®", desc: "Áü≥„ÇíÂàá„ÇäÂá∫„Åó„Åæ„Åô„ÄÇÁü≥Êùê„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { stone: 1 }, cost: { money: 100, food: 50, wood: 50 }, baseTime: 4000 },
            mine: { name: "Èâ±Â±±", icon: "üî©", desc: "Âú∞‰∏ãË≥áÊ∫ê„ÇíÊéò„Çä„Åæ„Åô„ÄÇÈâÑ„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { iron: 1 }, cost: { money: 200, food: 100, wood: 100, stone: 50 }, baseTime: 5000 },
            market: { name: "Â∏ÇÂ†¥", icon: "‚öñÔ∏è", desc: "‰∫§Êòì„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇÂ§ßÈáè„ÅÆ„ÅäÈáë„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { money: 10 }, cost: { money: 500, food: 200, wood: 200, stone: 50 }, baseTime: 6000 },
            blacksmith: { name: "ÈçõÂÜ∂Â±ã", icon: "‚öîÔ∏è", desc: "Ê≠¶ÂÖ∑„Çí‰Ωú„Çä„Åæ„Åô„ÄÇ„ÅäÈáë„Å®ÈâÑ„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { money: 5, iron: 2 }, cost: { money: 800, food: 300, wood: 300, stone: 200, iron: 100 }, baseTime: 7000 },

            // Êñ∞Ë¶èËøΩÂä†ÊñΩË®≠ („Ç≥„Çπ„Éà„ÅØÊ∞ëÂÆ∂Lv12Áõ∏ÂΩì x 10ÂÄç)
            well: {
                name: "‰∫ïÊà∏", icon: "üíß",
                desc: "„ÄêËæ≤Ê•≠ÊîØÊè¥„ÄëÊ∞¥„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇÈö£Êé•„Åô„Çã„ÄåÁïë„Äç„ÅÆÁîüÁî£ÂäπÁéá„Çí„Ç¢„ÉÉ„Éó„Åï„Åõ„Åæ„Åô(Lv1: 1.3ÂÄç)„ÄÇ",
                prod: { water: 5 },
                cost: { money: 30000, food: 10000, wood: 10000, stone: 5000, iron: 2000 },
                baseTime: 100000
            },
            inn: {
                name: "ÂÆøÂ±ã", icon: "üè®",
                desc: "„ÄêÂïÜÊ•≠„Éè„Éñ„Äë„ÄåÂ∏ÇÂ†¥„Äç„Å®„ÄåÊ∞ëÂÆ∂„Äç„ÅÆ‰∏°Êñπ„Å´Èö£Êé•„Åô„Çã„Å®Á®ºÂÉç„Åó„ÄÅÂ§öÈ°ç„ÅÆ„ÅäÈáë„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ",
                prod: { money: 60 }, // Êù°‰ª∂‰ªò„ÅçÈ´òÁîüÁî£ (‚ÄªÁîüÁî£Èáè„ÅØ„Åù„ÅÆ„Åæ„Åæ)
                cost: { money: 30000, food: 10000, wood: 10000, stone: 5000, iron: 2000 },
                baseTime: 120000
            },
            clocktower: {
                name: "ÈêòÊ•º", icon: "üîî",
                desc: "„ÄêÂÖ®‰ΩìÂä†ÈÄü„ÄëÊôÇ„ÇíÂëä„Åí„ÇãÈêò„ÅÆÈü≥„ÄÇÂÖ®ÊñΩË®≠„ÅÆÁîüÁî£ÈÄüÂ∫¶„Çí2%Âä†ÈÄü„Åó„Åæ„Åô(LvUP„Åß+0.6%)„ÄÇ",
                prod: {}, // Áõ¥Êé•ÁîüÁî£„Å™„Åó(ÂÖ®‰Ωì„Éê„Éï)
                cost: { money: 100000, food: 50000, wood: 50000, stone: 20000, iron: 10000 },
                baseTime: 200000
            },
            forest: {
                name: "Á´πÊûó", icon: "üéç",
                desc: "„ÄêÊûóÊ•≠„ÄëÈùôÂØÇ„Å™Á´πÊûó„ÄÇ2„Éû„ÇπÂç†Êúâ(1x2)„ÄÇ‰ºêÊé°ÊâÄ„ÅåÈö£Êé•„Åô„Çã„Å®ÁîüÁî£Èáè+20%„ÄÇ",
                prod: { wood: 15 },
                cost: { money: 100000, food: 40000, wood: 10000, water: 10000 },
                baseTime: 300000,
                w: 1, h: 2 // 1x2 size
            },
            bank: {
                name: "ÈáëÂ∫´", icon: "ü™ô",
                desc: "„ÄêÈáëËûç„ÄëË≤°ÂÆù„Çí‰øùÁÆ°„Åô„ÇãËîµ„ÄÇ„ÅäÈáë„ÅÆÁîüÁî£ÊñΩË®≠(Ê∞ëÂÆ∂/Â∏ÇÂ†¥/ÈçõÂÜ∂Â±ã/ÂÆøÂ±ã)„ÅÆÁîüÁî£Èáè„Å®„ÄÅ„ÅäÈáë„ÅÆË≤ØËîµ‰∏äÈôê„ÇíÂ¢ó„ÇÑ„Åó„Åæ„Åô(Lv1: 1.3ÂÄç)„ÄÇ",
                prod: {}, // ÁâπÊÆäÂäπÊûú
                cost: { money: 500000, wood: 200000, stone: 200000, iron: 100000 },
                baseTime: 500000
            },
            granary: {
                name: "Á©ÄÂÄâ", icon: "üõñ",
                desc: "„ÄêËæ≤Ê•≠„ÄëÈ£üÊñô„ÅÆÁîüÁî£ÊñΩË®≠(Áïë)„ÅÆÁîüÁî£Èáè„Å®„ÄÅÈ£üÊñô„ÅÆË≤ØËîµ‰∏äÈôê„ÇíÂ¢ó„ÇÑ„Åó„Åæ„Åô(Lv1: 1.3ÂÄç)„ÄÇ",
                prod: {},
                cost: { money: 600000, wood: 240000, stone: 240000, iron: 120000 },
                baseTime: 600000
            },
            lumber_hub: {
                name: "Ë£ΩÊùêÊâÄ", icon: "ü™µ",
                desc: "„ÄêÂ∑•Ê•≠„ÄëÊú®Êùê„ÅÆÁîüÁî£ÊñΩË®≠(‰ºêÊé°ÊâÄ/Ê£ÆÊûó)„ÅÆÁîüÁî£Èáè„Å®„ÄÅÊú®Êùê„ÅÆË≤ØËîµ‰∏äÈôê„ÇíÂ¢ó„ÇÑ„Åó„Åæ„Åô(Lv1: 1.3ÂÄç)„ÄÇ",
                prod: {},
                cost: { money: 700000, wood: 280000, stone: 280000, iron: 140000 },
                baseTime: 700000
            },
            stone_plant: {
                name: "Áü≥ÊùêÂä†Â∑•Â†¥", icon: "üè≠",
                desc: "„ÄêÂ∑•Ê•≠„Äë„ÅäÈáë„ÉªÈ£üÊñô„ÉªÊú®Êùê„ÇíÊ∂àË≤ª„Åó„Å¶„ÄÅÂ§ßÈáè„ÅÆÁü≥Êùê„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇÁ®ºÂÉç„Çπ„Ç§„ÉÉ„ÉÅÂºè„ÄÇ",
                prod: { stone: 20 }, // 4x spec
                consume: { money: 50, food: 20, wood: 20 },
                cost: { money: 2000000, wood: 500000, iron: 100000 },
                baseTime: 86400000 // 24 hours
            }
        };

        const BUILDING_KEYS = Object.keys(BUILDINGS);
        const LIMIT_START_INDEX = BUILDING_KEYS.indexOf('market');

        function getBuildingCount(type) {
            const onMap = gameState.tiles.filter(t => t.type === type).length;
            const inInventory = gameState.inventory.filter(i => i.type === type).length;
            return onMap + inInventory;
        }

        function checkBuildingLimit(type) {
            // ÁâπÂà•Âà∂Èôê: ‰∫ïÊà∏„ÉªÂÆøÂ±ã„ÉªÊôÇË®àÂ°î„ÉªÈäÄË°å„ÉªÁ©ÄÂÄâ„ÉªË£ΩÊùêÊâÄ„ÅØ2„Å§„Åæ„Åß
            if (['well', 'inn', 'clocktower', 'bank', 'granary', 'lumber_hub', 'stone_plant'].includes(type)) {
                if (getBuildingCount(type) >= 2) return false;
            }

            const typeIndex = BUILDING_KEYS.indexOf(type);
            if (typeIndex >= LIMIT_START_INDEX && typeIndex !== -1) {
                // „Åù„ÅÆ‰ªñ„ÅÆ‰∏äÁ¥öÊñΩË®≠„ÅØ4„Å§„Åæ„Åß
                if (getBuildingCount(type) >= 4) {
                    return false;
                }
            }
            return true;
        }

        for (let k in BUILDINGS) {
            const b = BUILDINGS[k];
            for (let r of ['money', 'food', 'wood', 'stone', 'iron', 'water']) {
                if (!b.prod[r]) b.prod[r] = 0;
                if (!b.cost[r]) b.cost[r] = 0;
            }
        }

        let gameState = {
            rank: 1, xp: 0,
            resources: { money: 200, food: 100, wood: 50, stone: 0, iron: 0, water: 0 },
            tiles: [],
            inventory: [],
            maxBuilders: CONFIG.initialMaxBuilders,
            gridSize: CONFIG.initialGridSize,
            lastSaveTime: Date.now()
        };

        let selectedTileIndex = null;

        // UI State for Move Mode
        let moveMode = { active: false, sourceIndex: null };

        let scene, camera, renderer;
        let raycaster, mouse;
        let tileMeshes = [];
        let pedestrians = [];
        let environmentGroup = null; // ËÉåÊôØ„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÁî®„Ç∞„É´„Éº„Éó

        let pointerDownPos = new THREE.Vector2();
        let lastPointerPos = new THREE.Vector2();
        let isDragging = false;
        let isPanning = false;

        // Áü≥Áï≥„ÉÜ„ÇØ„Çπ„ÉÅ„É£ÁîüÊàê (ÊîπËâØÁâà)
        function createCobblestoneTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // „Éô„Éº„ÇπÔºàÁõÆÂú∞„ÅÆËâ≤ÔºöÊøÉ„ÅÑ„Ç∞„É¨„ÉºÔºâ
            ctx.fillStyle = '#555';
            ctx.fillRect(0, 0, 512, 512);

            const rows = 8; // Ë°åÊï∞„ÇíÂ¢ó„ÇÑ„Åó„Å¶Áü≥„ÇíÂ∞è„Åï„Åè
            const cols = 8;
            const cellW = 512 / cols;
            const cellH = 512 / rows;

            // Áü≥„ÇíÊèèÁîª
            for (let y = 0; y < rows; y++) {
                // Ë°å„Åî„Å®„Å´„Ç™„Éï„Çª„ÉÉ„Éà„Çí„Åö„Çâ„ÅôÔºà„É¨„É≥„Ç¨Á©ç„ÅøÈ¢®Ôºâ
                const offset = (y % 2 === 0) ? 0 : cellW / 2;

                for (let x = -1; x < cols; x++) {
                    let sx = x * cellW + offset;
                    let sy = y * cellH;

                    // „É©„É≥„ÉÄ„É†„Å™‰ΩçÁΩÆ„Åö„Çå
                    sx += (Math.random() - 0.5) * 10;
                    sy += (Math.random() - 0.5) * 10;

                    // Áü≥„ÅÆ„Çµ„Ç§„Ç∫ÔºàÂ∞ë„Åó„É©„É≥„ÉÄ„É†„Å´‰∏çÊèÉ„ÅÑ„Å´„Åô„ÇãÔºâ
                    const w = cellW - 8 + (Math.random() - 0.5) * 8;
                    const h = cellH - 8 + (Math.random() - 0.5) * 8;

                    // Ëâ≤„ÅÆ„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥ÔºàËá™ÁÑ∂„Å™Áü≥„ÅÆËâ≤Âë≥Ôºâ
                    const gray = 140 + Math.random() * 60;
                    const r = gray + (Math.random() * 20 - 10);
                    const g = gray + (Math.random() * 20 - 10);
                    const b = gray + (Math.random() * 20 - 10);
                    ctx.fillStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;

                    // Ëßí‰∏∏„ÅÆÁü≥„ÇíÊèèÁîª
                    drawRoundedRect(ctx, sx, sy, w, h, 10);
                    ctx.fill();

                    // „Éè„Ç§„É©„Ç§„Éà„Å®„Ç∑„É£„Éâ„Ç¶„ÅßÁ´ã‰ΩìÊÑü„ÇíÂá∫„Åô
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(255,255,255,0.15)'; // „Éè„Ç§„É©„Ç§„Éà
                    ctx.stroke();
                }
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            // Áü≥„ÇíÁ¥∞„Åã„Åè„Åó„Åü„ÅÆ„Åß„É™„Éî„Éº„ÉàÂõûÊï∞„ÇíÊ∏õ„Çâ„Åô
            tex.repeat.set(1, 1);
            return tex;
        }

        // Ëßí‰∏∏Áü©ÂΩ¢ÊèèÁîª„Éò„É´„Éë„Éº
        function drawRoundedRect(ctx, x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function sanitizeGameState() {
            let fixedCount = 0;
            const grid = gameState.tiles;
            const size = gameState.gridSize;

            // 1. Remove Orphan Parts
            for (let i = 0; i < grid.length; i++) {
                const t = grid[i];
                if (t.type && t.type.endsWith('_part')) {
                    const mIdx = t.masterIndex;
                    if (mIdx === undefined || mIdx < 0 || mIdx >= grid.length) {
                        t.type = null; t.level = 0; t.masterIndex = undefined;
                        fixedCount++;
                        continue;
                    }
                    const master = grid[mIdx];
                    const expectedType = t.type.substring(0, t.type.length - 5);
                    if (!master.type || master.type !== expectedType) {
                        t.type = null; t.level = 0; t.masterIndex = undefined;
                        fixedCount++;
                    }
                }
            }

            // 2. Validate Masters & Heal/Delete
            for (let i = 0; i < grid.length; i++) {
                const t = grid[i];
                if (t.type && !t.type.endsWith('_part')) {
                    if (typeof getBuildingSize !== 'function') continue; // Safety
                    const bSize = getBuildingSize(t.type);
                    if (bSize.w === 1 && bSize.h === 1) continue;

                    const rot = t.rotation || 0;
                    const w = (rot % 2 === 0) ? bSize.w : bSize.h;
                    const h = (rot % 2 === 0) ? bSize.h : bSize.w;
                    const origin = getGridPos(i);

                    let isValid = true;
                    if (!t.unlocked) isValid = false; // Check Master Unlock

                    let partsToRestore = [];

                    if (isValid) {
                        for (let dy = 0; dy < h; dy++) {
                            for (let dx = 0; dx < w; dx++) {
                                if (dx === 0 && dy === 0) continue;

                                const tx = origin.x + dx;
                                const ty = origin.y + dy;
                                const tidx = getIndexFromPos(tx, ty);

                                if (tidx === -1) {
                                    isValid = false; break; // Out of bounds
                                }
                                const target = grid[tidx];

                                if (!target.unlocked) {
                                    isValid = false; break; // Locked tile
                                }

                                if (!target.type) {
                                    partsToRestore.push(tidx);
                                } else if (target.type === t.type + '_part' && target.masterIndex === i) {
                                    // OK
                                } else {
                                    isValid = false; break; // Collision
                                }
                            }
                            if (!isValid) break;
                        }
                    }

                    if (!isValid) {
                        // Corrupted or Invalid Pos -> Move to Inventory & Remove
                        // Recover Stored Resources first
                        if (t.stored) {
                            for (let r in t.stored) {
                                if (gameState.resources[r] !== undefined) {
                                    gameState.resources[r] += t.stored[r];
                                }
                            }
                        }
                        // Move to Inventory
                        gameState.inventory.push({ type: t.type, level: t.level });

                        // Remove Master
                        t.type = null; t.level = 0; t.finishTime = null; t.stored = {}; t.rotation = 0;

                        // Clean parts
                        for (let dy = 0; dy < h; dy++) {
                            for (let dx = 0; dx < w; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const tx = origin.x + dx;
                                const ty = origin.y + dy;
                                const tidx = getIndexFromPos(tx, ty);
                                if (tidx !== -1) {
                                    const p = grid[tidx];
                                    if (p.type === (t.type ? t.type + '_part' : '') && p.masterIndex === i) {
                                        p.type = null; p.level = 0; p.masterIndex = undefined;
                                    }
                                }
                            }
                        }
                        fixedCount++;
                    } else {
                        // Heal
                        if (partsToRestore.length > 0) {
                            partsToRestore.forEach(pidx => {
                                const p = grid[pidx];
                                p.type = t.type + '_part';
                                p.masterIndex = i;
                                p.level = t.level;
                            });
                            fixedCount++;
                        }
                    }
                }
            }

            if (fixedCount > 0) {
                console.log(`Sanitized ${fixedCount} issues.`);
                showToast(`‰∏çÊï¥Âêà„Éá„Éº„Çø„Çí‰øÆÊ≠£/‰øùÁÆ°Â∫´„Å∏ÁßªÂãï„Åó„Åæ„Åó„Åü(${fixedCount}‰ª∂)`);
                saveGame(); // Save fixes
            }
        }

        function initGame() {
            log("Game initializing...");

            if (typeof THREE === 'undefined') {
                document.body.innerHTML = '<div style="padding:20px;text-align:center;color:red;"><h3>„Ç®„É©„Éº: 3D„É©„Ç§„Éñ„É©„É™„ÅåË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì„ÄÇ</h3><p>ÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p></div>';
                return;
            }

            migrateXPSystem();

            if (!gameState.maxBuilders) gameState.maxBuilders = CONFIG.initialMaxBuilders;
            if (!gameState.gridSize) gameState.gridSize = CONFIG.initialGridSize;

            const totalTiles = gameState.gridSize * gameState.gridSize;
            if (gameState.tiles.length !== totalTiles) {
                if (gameState.tiles.length === 0) {
                    gameState.tiles = Array(totalTiles).fill(null).map((_, i) => ({
                        type: null, level: 0, finishTime: null,
                        unlocked: CONFIG.initialUnlocked.includes(i),
                        stored: {},
                        lastCollectTime: 0
                    }));
                } else {
                    const currentLen = gameState.tiles.length;
                    for (let i = currentLen; i < totalTiles; i++) {
                        gameState.tiles.push({
                            type: null, level: 0, finishTime: null,
                            unlocked: false,
                            stored: {},
                            lastCollectTime: 0
                        });
                    }
                }
            } else {
                gameState.tiles.forEach(t => {
                    if (!t.stored) t.stored = {};
                    if (t.lastCollectTime === undefined) t.lastCollectTime = 0;
                });
            }
            if (!gameState.inventory) gameState.inventory = [];

            sanitizeGameState(); // Auto-fix corrupted data on load

            try {
                init3D();
            } catch (e) {
                log(`3D Init Error: ${e.message}`, true);
                showToast("3DË°®Á§∫„ÅÆÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ");
                return;
            }

            updateHeader();

            requestAnimationFrame(animate3D);
            setInterval(gameLogicLoop, 1000);
            setInterval(() => window.saveGame(true), CONFIG.autoSaveInterval);
            setInterval(updatePanelUI, 500);

            log("Game loop started.");
        }

        function migrateXPSystem() {
            if (gameState.xpMigrationDone) return;
            if (gameState.rank < 12) {
                gameState.xpMigrationDone = true;
                return;
            }

            console.log("Migrating XP system for Rank 12+ user...");
            let totalXP = gameState.xp;
            const getLegacyXP = (r) => {
                const base = r * 500;
                if (r >= 10) return base * 4;
                return base;
            };
            for (let r = 1; r < gameState.rank; r++) {
                totalXP += getLegacyXP(r);
            }
            let newRank = 1;
            while (true) {
                const req = getNextRankXP(newRank);
                if (totalXP >= req) {
                    totalXP -= req;
                    newRank++;
                } else {
                    break;
                }
            }
            if (newRank !== gameState.rank) {
                console.log(`Rank migrated: ${gameState.rank} -> ${newRank}`);
                showToast(`„É©„É≥„ÇØË™øÊï¥: ${gameState.rank}‚Üí${newRank}`);
                gameState.rank = newRank;
                gameState.xp = totalXP;
            }
            gameState.xpMigrationDone = true;
            saveGame(true);
        }

        function init3D() {
            const container = document.getElementById('game-container');
            if (!container) throw new Error("Game container not found");

            let width = container.clientWidth;
            let height = container.clientHeight;

            if (width === 0 || height === 0) {
                width = window.innerWidth;
                height = window.innerHeight;
            }

            scene = new THREE.Scene();

            const aspect = width / height;
            const d = 10;

            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(20, 20, 20);
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

            const pixelRatio = Math.max(window.devicePixelRatio, 2.0);
            renderer.setPixelRatio(pixelRatio);

            renderer.setSize(width, height);
            renderer.shadowMap.enabled = true;
            renderer.setClearColor(0x000000, 0);
            container.innerHTML = '';
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            // „ÉÜ„ÇØ„Çπ„ÉÅ„É£„Å®„Éû„ÉÜ„É™„Ç¢„É´„ÅÆÂàùÊúüÂåñ
            MATERIALS.cobblestone = new THREE.MeshStandardMaterial({
                map: createCobblestoneTexture(),
                roughness: 0.8, // Â∞ë„Åó„Å§„ÇÑ„ÇíÂá∫„Åô
                color: 0xffffff
            });
            MATERIALS.grassLocked = new THREE.MeshStandardMaterial({ color: 0x27ae60, roughness: 1.0 });
            MATERIALS.white = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            createTiles();
            initPedestrians();
            createSurroundingEnvironment(); // ËÉåÊôØÁîüÊàê

            window.addEventListener('resize', onWindowResize, false);

            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            renderer.domElement.addEventListener('pointerup', onPointerUp, false);
            renderer.domElement.addEventListener('pointermove', onPointerMove, false);

            renderer.domElement.addEventListener('wheel', onMouseWheel, { passive: false });
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });

            setTimeout(onWindowResize, 100);
        }

        // „Éû„ÉÜ„É™„Ç¢„É´ÂÆöÁæ©Ôºà„ÉÜ„ÇØ„Çπ„ÉÅ„É£ÁîüÊàêÂæå„Å´‰ΩøÁî®Ôºâ
        const MATERIALS = {
            roof: new THREE.MeshStandardMaterial({ color: 0xe74c3c, roughness: 0.8 }),
            wall: new THREE.MeshStandardMaterial({ color: 0xf39c12, roughness: 0.9 }),
            leaf: new THREE.MeshStandardMaterial({ color: 0x2ecc71, roughness: 1.0 }), // Êòé„Çã„ÅÑÁ∑ë
            darkLeaf: new THREE.MeshStandardMaterial({ color: 0x27ae60, roughness: 1.0 }), // Êöó„ÅÑÁ∑ëÔºàÊ£ÆÁî®Ôºâ
            stone: new THREE.MeshStandardMaterial({ color: 0x7f8c8d, roughness: 0.6 }),
            mountain: new THREE.MeshStandardMaterial({ color: 0x95a5a6, roughness: 0.9 }), // Â±±Áî®
            snow: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 }), // Èõ™Áî®
            dark: new THREE.MeshStandardMaterial({ color: 0x34495e, roughness: 0.5 }),
            tent: new THREE.MeshStandardMaterial({ color: 0x3498db, roughness: 0.9 }),
            grass: new THREE.MeshStandardMaterial({ color: 0x27ae60, roughness: 1.0 }),
            wood: new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 }),
            window: new THREE.MeshStandardMaterial({ color: 0x87CEEB, emissive: 0x112233, roughness: 0.2 }),
            dirt: new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 1.0 }),
            metal: new THREE.MeshStandardMaterial({ color: 0xbdc3c7, metalness: 0.8, roughness: 0.2 }),
            gold: new THREE.MeshStandardMaterial({ color: 0xf1c40f, metalness: 0.6, roughness: 0.3 }),
            water: new THREE.MeshStandardMaterial({ color: 0x3498db, transparent: true, opacity: 0.7 }),
            graySheet: new THREE.MeshStandardMaterial({ color: 0x95a5a6, roughness: 0.9, side: THREE.DoubleSide }),
            // New Materials for Three Kingdoms Theme
            pillarRed: new THREE.MeshStandardMaterial({ color: 0x8e2020, roughness: 0.8 }), // Êú±Ëâ≤
            roofStraw: new THREE.MeshStandardMaterial({ color: 0xd4ac6e, roughness: 1.0 }), // ËóÅ
            roofTileBlack: new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.6 }), // ÈªíÁì¶
            roofTileGreen: new THREE.MeshStandardMaterial({ color: 0x16a085, roughness: 0.5 }), // Á∑ëÁì¶
            roofTileGold: new THREE.MeshStandardMaterial({ color: 0xf39c12, metalness: 0.4, roughness: 0.4 }), // ÈáëÁì¶
            wallWhite: new THREE.MeshStandardMaterial({ color: 0xecf0f1, roughness: 0.9 }), // ÁôΩÊºÜÂñ∞
            wallEarth: new THREE.MeshStandardMaterial({ color: 0xa08362, roughness: 1.0 }), // ÂúüÂ£Å
            lanternRed: new THREE.MeshStandardMaterial({ color: 0xe74c3c, emissive: 0x990000, emissiveIntensity: 0.5 }), // ÊèêÁÅØ
            woodDark: new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.9 }), // Êöó„ÅÑÊú®
            pavingStone: new THREE.MeshStandardMaterial({ color: 0x95a5a6, roughness: 0.8 }), // Áü≥Áï≥
            // cobblestone „Å® grassLocked „ÅØ init3D ÂÜÖ„ÅßËøΩÂä†
        };

        // Â∑•‰∫ãÁèæÂ†¥Ôºà„Ç∑„Éº„ÉàÔºã‰ΩúÊ•≠Âì°Ôºâ‰ΩúÊàê
        function createConstructionSite(type) {
            const group = new THREE.Group();

            let dimW = 1, dimH = 1;
            if (type && getBuildingSize) {
                const s = getBuildingSize(type);
                dimW = s.w; dimH = s.h;
            }

            // Use full tile offset for barrier size to reach tile edges (road boundaries)
            // Previously unitSize=2.4 left gaps; now matching 3.0 offset ensures full coverage
            const offsetStep = 3.0; // Tile offset
            const unitSize = 3.0;   // Changed from 2.4 to 3.0 to fill entire tile

            const totalW = unitSize + (dimW - 1) * offsetStep;
            const totalH = unitSize + (dimH - 1) * offsetStep; // Depth (Z)

            // Center relative to Master
            const cx = (dimW - 1) * offsetStep / 2;
            const cz = (dimH - 1) * offsetStep / 2;

            const distW = totalW / 2;
            const distH = totalH / 2;
            const height = 0.8; // Increased height to better contain buildings

            // ÊîØÊü±
            const poles = [
                { x: cx + distW, z: cz + distH },
                { x: cx - distW, z: cz + distH },
                { x: cx + distW, z: cz - distH },
                { x: cx - distW, z: cz - distH }
            ];
            const poleGeo = new THREE.CylinderGeometry(0.05, 0.05, height, 8);
            poles.forEach(p => {
                const pole = new THREE.Mesh(poleGeo, MATERIALS.metal);
                pole.position.set(p.x, height / 2, p.z);
                group.add(pole);
            });

            // Âπï
            const sheetGeoW = new THREE.PlaneGeometry(totalW, height * 0.9);
            const sheetGeoH = new THREE.PlaneGeometry(totalH, height * 0.9); // Z-axis sides

            const sides = [
                { x: cx, z: cz + distH, ry: 0, geo: sheetGeoW },
                { x: cx, z: cz - distH, ry: Math.PI, geo: sheetGeoW },
                { x: cx + distW, z: cz, ry: Math.PI / 2, geo: sheetGeoH },
                { x: cx - distW, z: cz, ry: -Math.PI / 2, geo: sheetGeoH }
            ];
            sides.forEach(s => {
                const sheet = new THREE.Mesh(s.geo, MATERIALS.graySheet);
                sheet.position.set(s.x, height / 2, s.z);
                sheet.rotation.y = s.ry;
                group.add(sheet);
            });

            // ‰ΩúÊ•≠Âì°
            const worker = new THREE.Group();
            worker.position.set(0, 0, 1.0); // ÊñΩË®≠(0.7Á®ãÂ∫¶)„Çà„ÇäÂ§ñ„ÄÅ„Ç∑„Éº„Éà(1.2)„Çà„ÇäÂÜÖÂÅ¥„Å´ÈÖçÁΩÆ

            // ‰Ωì
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.25, 8), new THREE.MeshStandardMaterial({ color: 0xecf0f1 }));
            body.position.y = 0.125;
            worker.add(body);

            // È†≠
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), new THREE.MeshStandardMaterial({ color: 0xf1c40f })); // „Éò„É´„É°„ÉÉ„ÉàÈªÑËâ≤
            head.position.y = 0.3;
            worker.add(head);

            // „Éè„É≥„Éû„Éº
            const hammer = new THREE.Group();
            hammer.position.set(0.1, 0.2, 0.1);
            const handle = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.15, 0.02), MATERIALS.wood);
            handle.position.y = 0.075;
            hammer.add(handle);
            const headH = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, 0.05), MATERIALS.metal);
            headH.position.set(0, 0.15, 0);
            hammer.add(headH);

            hammer.rotation.z = -Math.PI / 4;
            hammer.userData = { anim: 'hammerWork', speed: 0.2 };
            worker.add(hammer);

            group.add(worker);
            return group;
        }

        // Âë®Âõ≤„ÅÆÁí∞Â¢ÉÔºàÂ±±„ÇÑÊ£ÆÔºâ„ÇíÁîüÊàê„Åô„ÇãÈñ¢Êï∞
        function createSurroundingEnvironment() {
            if (environmentGroup) scene.remove(environmentGroup);
            environmentGroup = new THREE.Group();
            scene.add(environmentGroup);

            const currentSize = gameState.gridSize * 2; // „Ç∞„É™„ÉÉ„Éâ„ÅÆÂÄç„ÅÆÁØÑÂõ≤„ÇíÂÆâÂÖ®Âú∞Â∏Ø„Å®„Åô„Çã
            const range = 60; // ÁîüÊàêÁØÑÂõ≤„ÅÆÂçäÂæÑ

            // „Éò„É´„Éë„Éº: Êú®„Çí‰ΩúÊàê
            const createTree = (x, z, scale = 1) => {
                const g = new THREE.Group();
                g.position.set(x, 0, z);
                g.scale.set(scale, scale, scale);

                // Âππ
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.15, 0.5, 5),
                    MATERIALS.wood
                );
                trunk.position.y = 0.25;
                trunk.castShadow = true;
                g.add(trunk);

                // Ëëâ (3ÊÆµ)
                const l1 = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.6, 5), MATERIALS.darkLeaf);
                l1.position.y = 0.6;
                l1.castShadow = true;
                g.add(l1);

                const l2 = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.5, 5), MATERIALS.darkLeaf);
                l2.position.y = 0.9;
                l2.castShadow = true;
                g.add(l2);

                return g;
            };

            // „Éò„É´„Éë„Éº: Â±±„Çí‰ΩúÊàê
            const createMountain = (x, z, height, radius) => {
                const g = new THREE.Group();
                g.position.set(x, 0, z);

                // Êú¨‰Ωì
                const m = new THREE.Mesh(
                    new THREE.ConeGeometry(radius, height, 5),
                    MATERIALS.mountain
                );
                m.position.y = height / 2;
                m.castShadow = true;
                m.receiveShadow = true;
                g.add(m);

                // Èõ™Ëß£„ÅëÔºàÈ†Ç‰∏äÔºâ
                const s = new THREE.Mesh(
                    new THREE.ConeGeometry(radius * 0.3, height * 0.3, 5),
                    MATERIALS.snow
                );
                s.position.y = height * 0.85;
                g.add(s);

                return g;
            };

            // ÈÖçÁΩÆ„É≠„Ç∏„ÉÉ„ÇØ
            for (let i = 0; i < 150; i++) {
                const angle = Math.random() * Math.PI * 2;
                // „Ç∞„É™„ÉÉ„Éâ„ÅÆÂ§ñÂÅ¥„Åã„ÇâÈÅ†„Åè„Åæ„ÅßÈÖçÁΩÆ
                // offset=3„Å™„ÅÆ„Åß„ÄÅ„Çµ„Ç§„Ç∫„ÇÇÂ§ß„Åç„Åè„Å™„Å£„Å¶„ÅÑ„Çã„ÄÇ
                // ÂçäÂæÑË®àÁÆó: (currentSize / 2 * 3) + ‰ΩôË£ï
                const dist = (currentSize * 1.5) + 8 + Math.random() * range;

                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;

                // Â••ÂÅ¥ÔºàÂåóÂÅ¥Ôºâ„Å´„ÅØÂ±±„ÇíÂ§ö„ÇÅ„Å´ÈÖçÁΩÆ
                if (z < -10 && Math.random() > 0.6) {
                    const h = 3 + Math.random() * 5; // È´ò„Åï„ÇíÊäë„Åà„Çã
                    const r = 2 + Math.random() * 3; // ÂπÖ„ÇíÊäë„Åà„Çã
                    environmentGroup.add(createMountain(x, z, h, r));
                } else {
                    // Êú®„ÇíÈÖçÁΩÆ
                    const scale = 0.8 + Math.random() * 0.8; // „Çµ„Ç§„Ç∫„ÇíÂ∞è„Åï„Åè„Åô„Çã
                    const tree = createTree(x, z, scale);
                    // „É©„É≥„ÉÄ„É†„Å´Â∞ë„ÅóÂÇæ„Åë„Çã
                    tree.rotation.z = (Math.random() - 0.5) * 0.1;
                    tree.rotation.x = (Math.random() - 0.5) * 0.1;
                    environmentGroup.add(tree);
                }
            }

            // Âú∞Èù¢„Å®„Å™„ÇãÂ∑®Â§ß„Å™ÂÜÜÁõ§Ôºà„Éó„É¨„Ç§„Ç®„É™„Ç¢„ÅÆ‰∏ãÔºâ
            const bigGround = new THREE.Mesh(
                new THREE.CircleGeometry(range + 30, 32),
                new THREE.MeshStandardMaterial({ color: 0x3c5c35, roughness: 1.0 }) // ÊøÉ„ÅÑÁ∑ë„ÅÆÂú∞Èù¢
            );
            bigGround.rotation.x = -Math.PI / 2;
            bigGround.position.y = -0.1; // „Çø„Ç§„É´„ÅÆÂú∞Èù¢„Çà„Çä„Åï„Çâ„Å´‰∏ã
            bigGround.receiveShadow = true;
            environmentGroup.add(bigGround);
        }

        // --- Sound Manager (Web Audio API) ---
        const SoundManager = {
            ctx: null,
            bgmNode: null,
            masterGain: null,
            bgmGain: null,
            nextNoteTime: 0,
            isPlaying: false,
            timerID: null,
            config: {
                bgmVolume: parseFloat(localStorage.getItem('kb_config_bgm_vol') || '0.5'),
                seVolume: parseFloat(localStorage.getItem('kb_config_se_vol') || '0.5')
            },

            init: function () {
                if (this.ctx) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;

                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 1.0;
                this.masterGain.connect(this.ctx.destination);

                if (this.config.bgmVolume > 0) this.playBGM();
            },

            resume: function () {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
                if (!this.ctx) this.init();
            },

            setBGMVolume: function (val) {
                this.config.bgmVolume = val;
                localStorage.setItem('kb_config_bgm_vol', val);
                if (!this.ctx) return; // Wait for init
                if (this.bgmGain) {
                    try {
                        this.bgmGain.gain.cancelScheduledValues(0);
                        this.bgmGain.gain.value = val * 0.3;
                    } catch (e) {
                        console.warn("Audio error", e);
                    }
                }
                if (val > 0 && !this.isPlaying) {
                    this.playBGM();
                } else if (val === 0 && this.isPlaying) {
                    this.stopBGM();
                }
            },

            setSEVolume: function (val) {
                this.config.seVolume = val;
                localStorage.setItem('kb_config_se_vol', val);
            },

            // --- BGM Sequencer ---
            playBGM: function () {
                if (this.isPlaying || !this.ctx) return;
                this.resume();

                // If volume is 0, don't start
                if (this.config.bgmVolume <= 0) return;

                this.isPlaying = true;
                this.nextNoteTime = this.ctx.currentTime + 0.1;

                // Master BGM Gain for volume control
                this.bgmGain = this.ctx.createGain();
                this.bgmGain.gain.value = this.config.bgmVolume * 0.3;
                this.bgmGain.connect(this.masterGain);

                this.melodyIndex = 0;
                this.scheduler();
            },

            stopBGM: function () {
                this.isPlaying = false;
                if (this.timerID) clearTimeout(this.timerID);
                if (this.bgmGain) {
                    this.bgmGain.disconnect();
                    this.bgmGain = null;
                }
            },

            scheduler: function () {
                if (!this.isPlaying) return;
                // Schedule ahead 0.1s
                while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
                    this.scheduleNote(this.nextNoteTime);
                    this.nextNoteTime += 0.4; // Tempo
                }
                this.timerID = setTimeout(() => this.scheduler(), 25);
            },

            melodyIndex: 0,
            scheduleNote: function (time) {
                // Calming pentatonic melody loop
                // C4, D4, E4, G4, A4 ... 
                const notes = [
                    261.63, 293.66, 329.63, 392.00, // C D E G
                    440.00, 392.00, 329.63, 293.66, // A G E D
                    261.63, -1, 329.63, -1,         // C - E -
                    392.00, 261.63, 293.66, -1      // G C D -
                ];

                const freq = notes[this.melodyIndex % notes.length];
                this.melodyIndex++;
                if (freq <= 0) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                // Soft Triangle (Electric Piano like)
                osc.type = 'triangle';
                osc.frequency.value = freq;

                // Envelope
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(1.0, time + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.6);

                osc.connect(gain);
                gain.connect(this.bgmGain);

                osc.start(time);
                osc.stop(time + 0.6);
            },

            playSE: function (type) {
                if (this.config.seVolume <= 0) return;
                this.resume();
                if (!this.ctx) return;

                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.connect(gain);
                gain.connect(this.masterGain);

                const vol = this.config.seVolume;

                if (type === 'select') {
                    // High blip
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(800, t);
                    osc.frequency.exponentialRampToValueAtTime(1200, t + 0.1);
                    gain.gain.setValueAtTime(0.3 * vol, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                    osc.start(t);
                    osc.stop(t + 0.1);

                } else if (type === 'build') {
                    // Low thud
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(150, t);
                    osc.frequency.exponentialRampToValueAtTime(40, t + 0.2);
                    gain.gain.setValueAtTime(0.5 * vol, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                    osc.start(t);
                    osc.stop(t + 0.2);

                } else if (type === 'collect') {
                    // Coin / Shimmer
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(1200, t);
                    gain.gain.setValueAtTime(0.3 * vol, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                    osc.start(t);
                    osc.stop(t + 0.15);

                    const osc2 = this.ctx.createOscillator();
                    const gain2 = this.ctx.createGain();
                    osc2.connect(gain2);
                    gain2.connect(this.masterGain);
                    osc2.type = 'sine';
                    osc2.frequency.setValueAtTime(1800, t + 0.05);
                    gain2.gain.setValueAtTime(0.3 * vol, t + 0.05);
                    gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                    osc2.start(t + 0.05);
                    osc2.stop(t + 0.2);

                } else if (type === 'levelup') {
                    // Fanfare
                    const notes = [523.25, 659.25, 783.99, 1046.50];
                    notes.forEach((freq, i) => {
                        const o = this.ctx.createOscillator();
                        const g = this.ctx.createGain();
                        o.connect(g);
                        g.connect(this.masterGain);
                        o.type = 'triangle';
                        o.frequency.value = freq;
                        g.gain.setValueAtTime(0.2 * vol, t + i * 0.1);
                        g.gain.exponentialRampToValueAtTime(0.01, t + i * 0.1 + 0.3);
                        o.start(t + i * 0.1);
                        o.stop(t + i * 0.1 + 0.3);
                    });

                } else if (type === 'error') {
                    // Buzz
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, t);
                    osc.frequency.linearRampToValueAtTime(100, t + 0.15);
                    gain.gain.setValueAtTime(0.2 * vol, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                    osc.start(t);
                    osc.stop(t + 0.15);
                } else if (type === 'cancel') {
                    // Descending
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, t);
                    osc.frequency.linearRampToValueAtTime(300, t + 0.2);
                    gain.gain.setValueAtTime(0.2 * vol, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                    osc.start(t);
                    osc.stop(t + 0.2);
                }
            }
        };

        // Click to resume
        window.SoundManager = SoundManager;
        const initAudio = () => { SoundManager.resume(); };
        document.addEventListener('click', initAudio, { once: true });
        document.addEventListener('touchstart', initAudio, { once: true });

        function createTiles() {
            tileMeshes.forEach(t => {
                scene.remove(t.mesh);
                scene.remove(t.groundMesh);
                t.overlayEl.remove();
            });
            tileMeshes = [];

            // ÂúüÂè∞„ÅØ„ÄåË¶ã„Åà„Å™„ÅÑ„Éí„ÉÉ„Éà„Éú„ÉÉ„ÇØ„Çπ„Äç„Å´Â§âÊõ¥
            const geometry = new THREE.BoxGeometry(2.1, 0.75, 2.1);
            const invisibleMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0 });

            // Âú∞Èù¢„ÇíÂ∞ë„ÅóÂ§ß„Åç„Åè„Åó„Å¶ÈöôÈñì„Çí„Å™„Åè„Åô
            const groundGeo = new THREE.PlaneGeometry(3.1, 3.1);
            // groundMat„ÅØÂÄãÂà•„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å®„Åó„Å¶ÁîüÊàê

            const offset = 3;
            const size = gameState.gridSize;
            const start = -offset * (size - 1) / 2;

            for (let i = 0; i < size * size; i++) {
                const row = Math.floor(i / size);
                const col = i % size;
                const x = start + col * offset;
                const z = start + row * offset;

                // Âú∞Èù¢ÔºàÂàùÊúü„Éû„ÉÜ„É™„Ç¢„É´„ÅØ‰ªÆ„ÄÅsync3DState„ÅßÊõ¥Êñ∞Ôºâ
                const groundMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.position.set(x, -0.05, z); // „Å°„Çâ„Å§„ÅçÈò≤Ê≠¢„ÅÆ„Åü„ÇÅÂ∞ë„Åó‰∏ã„Åí„Çã
                ground.receiveShadow = true;
                scene.add(ground);

                // ÈÄèÊòé„Å™„Éí„ÉÉ„ÉàÂà§ÂÆöÁî®„Éú„ÉÉ„ÇØ„Çπ
                const mesh = new THREE.Mesh(geometry, invisibleMat.clone());
                mesh.position.set(x, 0, z);
                mesh.userData = { index: i, type: 'tile' };
                scene.add(mesh);

                const bGroup = new THREE.Group();
                // Âª∫Áâ©„ÅØÂú∞Èù¢(y=0)„Åã„ÇâÁõ¥Êé•Âª∫„Å¶„Çã
                bGroup.position.set(0, 0, 0);
                mesh.add(bGroup);

                const overlay = document.createElement('div');
                overlay.className = 'overlay-item';
                document.getElementById('ui-overlay-layer').appendChild(overlay);

                const particles = new ParticleSystem(mesh.position, scene);

                tileMeshes.push({
                    mesh: mesh,
                    groundMesh: ground,
                    buildingGroup: bGroup,
                    overlayEl: overlay,
                    particles: particles,
                    currentType: null
                });
            }
            sync3DState();
            createSurroundingEnvironment(); // „Çø„Ç§„É´ÁîüÊàêÊôÇ„Å´„ÇÇÁí∞Â¢É„ÇíÊõ¥Êñ∞Ôºà„Çµ„Ç§„Ç∫Êã°ÂºµÂØæÂøúÔºâ
        }

        class Person {
            constructor(scene) {
                this.scene = scene;
                this.mesh = new THREE.Group();
                this.mesh.castShadow = true;

                // Materials - Historical Palette (Earth tones, Indigo, Unbleached)
                const getHistoricalColor = () => {
                    const palette = [
                        0x8B4513, // SaddleBrown
                        0x556B2F, // DarkOliveGreen
                        0x708090, // SlateGray
                        0x2F4F4F, // DarkSlateGray
                        0x4682B4, // SteelBlue (faded indigo)
                        0xCD853F, // Peru (tan)
                        0xA0522D, // Sienna
                        0xD2B48C  // Tan
                    ];
                    return palette[Math.floor(Math.random() * palette.length)];
                };

                const shirtColor = getHistoricalColor();
                const pantsColor = getHistoricalColor();
                const skinColor = 0xffccaa;

                const matShirt = new THREE.MeshStandardMaterial({ color: shirtColor });
                const matPants = new THREE.MeshStandardMaterial({ color: pantsColor });
                const matSkin = new THREE.MeshStandardMaterial({ color: skinColor });

                // Container for Scale/Rotation local
                this.bodyGroup = new THREE.Group();
                this.mesh.add(this.bodyGroup);

                // --- Body Parts ---
                // Torso (0.15 width, 0.25 height)
                const torsoGeo = new THREE.BoxGeometry(0.15, 0.25, 0.08);
                this.torso = new THREE.Mesh(torsoGeo, matShirt);
                this.torso.position.y = 0.25; // Center of torso
                this.torso.castShadow = true;
                this.bodyGroup.add(this.torso);

                // Head
                const headGeo = new THREE.BoxGeometry(0.12, 0.12, 0.12); // Boxy head for low poly style
                this.head = new THREE.Mesh(headGeo, matSkin);
                this.head.position.y = 0.43;
                this.head.castShadow = true;
                this.bodyGroup.add(this.head);

                // Helper for Limbs (pivot at top)
                const createLimb = (w, h, d, mat, ox, oy, oz) => {
                    const g = new THREE.Group();
                    g.position.set(ox, oy, oz);
                    const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
                    mesh.position.y = -h / 2; // pivot at top
                    mesh.castShadow = true;
                    g.add(mesh);
                    return g;
                };

                // Arms (Pivot at shoulder: y=0.35)
                this.leftArm = createLimb(0.06, 0.22, 0.06, matShirt, 0.11, 0.35, 0);
                this.rightArm = createLimb(0.06, 0.22, 0.06, matShirt, -0.11, 0.35, 0);
                this.bodyGroup.add(this.leftArm);
                this.bodyGroup.add(this.rightArm);

                // Legs (Pivot at hip: y=0.25 so feet touch ground at y=0)
                this.leftLeg = createLimb(0.065, 0.25, 0.065, matPants, 0.05, 0.25, 0);
                this.rightLeg = createLimb(0.065, 0.25, 0.065, matPants, -0.05, 0.25, 0);
                this.bodyGroup.add(this.leftLeg);
                this.bodyGroup.add(this.rightLeg);


                scene.add(this.mesh);
                this.active = false;
                this.mesh.visible = false;
                this.isStopped = false;
                this.stopTimer = 0;
                this.canTurn = true;

                // Animation State
                this.animTime = Math.random() * 100;

                this.reset();
            }

            updateAnimation(dt) {
                if (!this.active || !this.mesh.visible) return;

                if (this.isStopped) {
                    // Reset pose Lerp
                    const lerpFactor = 0.1;
                    this.leftArm.rotation.x += (0 - this.leftArm.rotation.x) * lerpFactor;
                    this.rightArm.rotation.x += (0 - this.rightArm.rotation.x) * lerpFactor;
                    this.leftLeg.rotation.x += (0 - this.leftLeg.rotation.x) * lerpFactor;
                    this.rightLeg.rotation.x += (0 - this.rightLeg.rotation.x) * lerpFactor;
                    return;
                }

                // Walk Cycle
                const speed = 4.0; // Animation frequency (4 = ~2 steps/second)
                const range = 0.3; // Swing amplitude

                // Use dt directly for animation timing
                this.animTime += dt * 0.75; // 0.75 base rate for natural walking

                const angle = Math.sin(this.animTime * speed) * range;

                // Arms (Opposite to legs)
                this.leftArm.rotation.x = angle;
                this.rightArm.rotation.x = -angle;

                // Legs
                this.leftLeg.rotation.x = -angle;
                this.rightLeg.rotation.x = angle;
            }

            getNearestRoadCoord(val) {
                const size = gameState.gridSize;
                const offset = 3;
                const tileStart = -offset * (size - 1) / 2;
                const roadStart = tileStart + 1;
                const index = Math.round((val - roadStart) / offset);
                return roadStart + index * offset;
            }

            // Update body rotation to face movement direction
            updateFacing() {
                const dx = this.direction.x;
                const dz = this.direction.z;
                if (dx !== 0 || dz !== 0) {
                    this.mesh.rotation.y = Math.atan2(dx, dz);
                }
            }

            // Spawn pedestrian inside the road grid (for initial load)
            resetInside() {
                const size = gameState.gridSize;
                const offset = 3;
                const tileStart = -offset * (size - 1) / 2;
                const roadStart = tileStart + 1;
                const roadCount = Math.max(1, size - 1);

                // Try up to 20 times to find a valid (non-blocked) spawn position
                for (let attempt = 0; attempt < 20; attempt++) {
                    const isVertical = Math.random() < 0.5;

                    // Pick random road lane
                    const roadIndex = Math.floor(Math.random() * roadCount);
                    const laneCenter = roadStart + roadIndex * offset;
                    const jitter = (Math.random() - 0.5) * 0.4;
                    const lane = laneCenter + jitter;

                    // Pick random position ALONG the road (inside grid)
                    const posAlongRoad = roadStart + Math.random() * (roadCount - 1) * offset;

                    let sx, sz;
                    if (isVertical) {
                        sx = lane;
                        sz = posAlongRoad;
                    } else {
                        sz = lane;
                        sx = posAlongRoad;
                    }

                    // Check if this road position is blocked by a multi-tile building
                    if (this.isRoadBlocked(sx, sz, isVertical)) {
                        continue; // Try another position
                    }

                    // Valid position found
                    this.baseSpeed = (0.02 + Math.random() * 0.02) * 0.25;
                    this.speed = this.baseSpeed;
                    const dx = isVertical ? 0 : (Math.random() < 0.5 ? -1 : 1);
                    const dz = isVertical ? (Math.random() < 0.5 ? -1 : 1) : 0;

                    this.mesh.position.set(sx, 0, sz);
                    this.direction = new THREE.Vector3(dx, 0, dz);
                    this.updateFacing();
                    this.active = true;
                    this.isStopped = false;
                    this.canTurn = true;
                    this.updateVisibility();
                    return; // Successfully spawned
                }

                // Fallback: if no valid position found, use regular reset (spawn from outside)
                this.reset();
            }
            reset() {
                const isVertical = Math.random() < 0.5;
                const size = gameState.gridSize;
                const offset = 3;
                const tileStart = -offset * (size - 1) / 2;
                const roadStart = tileStart + 1;
                const roadCount = Math.max(1, size - 1);
                const roadIndex = Math.floor(Math.random() * roadCount);
                const laneCenter = roadStart + roadIndex * offset;
                const jitter = (Math.random() - 0.5) * 0.4;
                const lane = laneCenter + jitter;
                this.baseSpeed = (0.02 + Math.random() * 0.02) * 0.25;
                this.speed = this.baseSpeed;
                let sx, sz, dx, dz;
                const spawnDist = size + 5;
                if (isVertical) {
                    sx = lane;
                    sz = (Math.random() < 0.5 ? -spawnDist : spawnDist);
                    dx = 0; dz = sz > 0 ? -1 : 1;
                } else {
                    sz = lane;
                    sx = (Math.random() < 0.5 ? -spawnDist : spawnDist);
                    dx = sx > 0 ? -1 : 1; dz = 0;
                }
                this.mesh.position.set(sx, 0, sz);
                this.direction = new THREE.Vector3(dx, 0, dz);
                this.updateFacing(); // Sync facing on spawn
                this.active = true;
                this.isStopped = false;
                this.canTurn = true;
                this.updateVisibility();
            }
            isRoadBlocked(x, z, isVertical) {
                const size = gameState.gridSize;
                const offset = 3;
                const start = -offset * (size - 1) / 2;

                const getTileIdx = (wx, wz) => {
                    const col = Math.round((wx - start) / offset);
                    const row = Math.round((wz - start) / offset);
                    if (col < 0 || col >= size || row < 0 || row >= size) return -1;
                    return row * size + col;
                };

                let t1_idx = -1, t2_idx = -1;

                if (isVertical) {
                    // Vertical road: separates Left(x-1) and Right(x+1)
                    t1_idx = getTileIdx(x - 1, z);
                    t2_idx = getTileIdx(x + 1, z);
                } else {
                    // Horizontal road: separates Top(z-1) and Bottom(z+1)
                    t1_idx = getTileIdx(x, z - 1);
                    t2_idx = getTileIdx(x, z + 1);
                }

                if (t1_idx === -1 || t2_idx === -1) return false; // Edge of map, usually fine or handled by reset

                const t1 = gameState.tiles[t1_idx];
                const t2 = gameState.tiles[t2_idx];

                if (!t1 || !t2) return false;

                // Helper to get master index
                const getMaster = (t, idx) => {
                    if (!t.type) return null;
                    if (t.type.endsWith('_part')) return t.masterIndex;
                    return idx; // It is master or single
                };

                const m1 = getMaster(t1, t1_idx);
                const m2 = getMaster(t2, t2_idx);

                // If both share the SAME master (and are not null), they are connected -> Road Blocked
                if (m1 !== null && m2 !== null && m1 === m2) {
                    return true;
                }

                return false;
            }

            isOnGreenRoad(x, z, isVertical) {
                const size = gameState.gridSize;
                const offset = 3; // Fixed from 2
                const start = -offset * (size - 1) / 2;
                const checkTile = (wx, wz) => {
                    const col = Math.round((wx - start) / offset);
                    const row = Math.round((wz - start) / offset);
                    if (col < 0 || col >= size || row < 0 || row >= size) return false;
                    const idx = row * size + col;
                    return gameState.tiles[idx] && gameState.tiles[idx].unlocked;
                };
                let t1_unlocked = false;
                let t2_unlocked = false;
                if (isVertical) {
                    t1_unlocked = checkTile(x - 1, Math.round(z));
                    t2_unlocked = checkTile(x + 1, Math.round(z));
                } else {
                    t1_unlocked = checkTile(Math.round(x), z - 1);
                    t2_unlocked = checkTile(Math.round(x), z + 1);
                }
                return (!t1_unlocked && !t2_unlocked);
            }
            update() {
                if (!this.active) {
                    if (Math.random() < 0.01) this.reset();
                    return;
                }
                if (this.isStopped) {
                    this.stopTimer--;
                    if (this.stopTimer <= 0) {
                        this.isStopped = false;
                    }
                    this.updateVisibility();
                    return;
                }

                // Check for obstacles ahead
                // Only check if moving
                if (this.speed > 0) {
                    const isVertical = (this.direction.z !== 0);
                    // Look ahead slightly
                    const lookAhead = 0.5;
                    const nextX = this.mesh.position.x + this.direction.x * lookAhead;
                    const nextZ = this.mesh.position.z + this.direction.z * lookAhead;

                    if (this.isRoadBlocked(nextX, nextZ, isVertical)) {
                        // Reverse direction
                        this.direction.negate();
                        this.updateFacing(); // Sync facing after reversal
                        // Also move back a bit to prevent sticking
                        this.mesh.position.addScaledVector(this.direction, 0.2);
                        this.updateVisibility();
                        return;
                    }
                }

                if (Math.random() < 0.005) {
                    this.isStopped = true;
                    this.stopTimer = 30 + Math.random() * 60;
                    return;
                }
                const nearestRoadX = this.getNearestRoadCoord(this.mesh.position.x);
                const nearestRoadZ = this.getNearestRoadCoord(this.mesh.position.z);
                const distX = Math.abs(this.mesh.position.x - nearestRoadX);
                const distZ = Math.abs(this.mesh.position.z - nearestRoadZ);
                const intersectionThreshold = 0.1;
                const isAtIntersection = (distX < intersectionThreshold && distZ < intersectionThreshold);
                if (isAtIntersection) {
                    if (this.canTurn) {
                        if (Math.random() < 0.5) {
                            const dirs = [
                                new THREE.Vector3(1, 0, 0),
                                new THREE.Vector3(-1, 0, 0),
                                new THREE.Vector3(0, 0, 1),
                                new THREE.Vector3(0, 0, -1)
                            ];
                            // Filter valid directions (don't turn into walls)
                            const validDirs = dirs.filter(d => {
                                // Simple check: is immediate next step blocked?
                                const checkX = this.mesh.position.x + d.x * 0.5;
                                const checkZ = this.mesh.position.z + d.z * 0.5;
                                return !this.isRoadBlocked(checkX, checkZ, d.z !== 0);
                            });

                            if (validDirs.length > 0) {
                                this.direction = validDirs[Math.floor(Math.random() * validDirs.length)];
                                this.updateFacing(); // Sync facing after turn
                                this.mesh.position.x = nearestRoadX;
                                this.mesh.position.z = nearestRoadZ;
                            } else {
                                // Dead end? Reverse
                                this.direction.negate();
                                this.updateFacing(); // Sync facing after reversal
                            }
                        }
                        this.canTurn = false;
                    }
                } else {
                    if (Math.max(distX, distZ) > 0.4) {
                        this.canTurn = true;
                    }
                }
                this.mesh.position.addScaledVector(this.direction, this.speed);
                const limit = gameState.gridSize * 1.5 + 5;
                if (Math.abs(this.mesh.position.x) > limit || Math.abs(this.mesh.position.z) > limit) {
                    this.reset();
                    return;
                }
                this.updateVisibility();
                this.mesh.position.y = Math.abs(Math.sin(Date.now() * 0.005)) * 0.05;
            }
            updateVisibility() {
                const isVertical = (this.direction.z !== 0);
                if (this.isOnGreenRoad(this.mesh.position.x, this.mesh.position.z, isVertical)) {
                    this.mesh.visible = false;
                } else {
                    this.mesh.visible = true;
                }
            }
        }

        function initPedestrians() {
            if (pedestrians.length === 0) {
                // Initial load: spawn pedestrians inside existing roads
                for (let i = 0; i < 15; i++) {
                    const p = new Person(scene);
                    p.resetInside(); // Spawn inside the grid
                    pedestrians.push(p);
                }
            } else {
                // Respawn: use outside spawn (normal reset)
                pedestrians.forEach(p => p.reset());
            }
        }

        class ParticleSystem {
            constructor(position, scene) {
                this.origin = position.clone().add(new THREE.Vector3(0, 1, 0));
                this.particles = [];
                this.scene = scene;
                this.active = false;
                this.geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                this.mat = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true });
            }
            update() {
                if (!this.active && this.particles.length === 0) return;
                if (this.active && Math.random() < 0.2) {
                    const mesh = new THREE.Mesh(this.geo, this.mat.clone());
                    const offset = new THREE.Vector3((Math.random() - 0.5) * 1.5, 0, (Math.random() - 0.5) * 1.5);
                    mesh.position.copy(this.origin).add(offset);
                    this.scene.add(mesh);
                    this.particles.push({
                        mesh: mesh,
                        vel: new THREE.Vector3(0, 0.05 + Math.random() * 0.05, 0),
                        life: 1.0
                    });
                }
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.mesh.position.add(p.vel);
                    p.mesh.rotation.x += 0.1;
                    p.mesh.rotation.y += 0.1;
                    p.life -= 0.02;
                    p.mesh.material.opacity = p.life;
                    if (p.life <= 0) {
                        this.scene.remove(p.mesh);
                        this.particles.splice(i, 1);
                    }
                }
            }
        }

        function createBuildingMesh(type, level) {
            const group = new THREE.Group();
            // „Éô„Éº„Çπ„Çπ„Ç±„Éº„É´Ë™øÊï¥
            // Cap level at 30 for visuals
            const vizLevel = Math.min(level, 30);
            const scale = 1.0 + (vizLevel * 0.02);
            group.scale.set(scale, scale, scale);

            // Tier 1: 1-20, Tier 2: 21+
            const tier = vizLevel >= 21 ? 2 : 1;

            const createBox = (w, h, d, mat, x, y, z, rotY = 0) => {
                const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
                m.position.set(x, y, z);
                if (rotY) m.rotation.y = rotY;
                m.castShadow = true;
                m.receiveShadow = true;
                return m;
            };
            const createCyl = (rt, rb, h, mat, x, y, z, rotY = 0, seg = 8) => {
                const m = new THREE.Mesh(new THREE.CylinderGeometry(rt, rb, h, seg), mat);
                m.position.set(x, y, z);
                if (rotY) m.rotation.y = rotY;
                m.castShadow = true;
                return m;
            };
            const createCone = (r, h, mat, x, y, z, rotY = 0) => {
                const geom = new THREE.ConeGeometry(r, h, 8); // Smoother cones (8 segments)
                const m = new THREE.Mesh(geom, mat);
                m.position.set(x, y, z);
                if (rotY) m.rotation.y = rotY;
                m.castShadow = true;
                return m;
            };

            // Enhanced Helper: Box with "noise" or distinct look
            const createDetailedBox = (w, h, d, mat, x, y, z) => {
                const g = new THREE.Group();
                g.position.set(x, y, z);
                // Main mesh
                const main = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
                main.castShadow = true;
                main.receiveShadow = true;
                g.add(main);
                // Detail (Trim/Top) - random slightly larger plate on top for texture
                if (h > 0.2) {
                    const plate = new THREE.Mesh(new THREE.BoxGeometry(w + 0.02, 0.05, d + 0.02), mat);
                    plate.position.y = h / 2;
                    plate.castShadow = true;
                    // g.add(plate); // Maybe too much noise for everything
                }
                return g;
            };

            // Helper: Fence Segment
            const createFence = (x1, z1, x2, z2, h = 0.2) => {
                const len = Math.sqrt((x2 - x1) ** 2 + (z2 - z1) ** 2);
                const angle = Math.atan2(z2 - z1, x2 - x1);

                const g = new THREE.Group();
                const centerx = (x1 + x2) / 2;
                const centerz = (z1 + z2) / 2;
                g.position.set(centerx, h / 2, centerz);
                g.rotation.y = -angle; // Three.js rotation is CCW from X+? Check

                // Posts
                const p1 = createBox(0.05, h + 0.1, 0.05, MATERIALS.wood, -len / 2, 0, 0);
                const p2 = createBox(0.05, h + 0.1, 0.05, MATERIALS.wood, len / 2, 0, 0);
                g.add(p1); g.add(p2);

                // Rails
                const r1 = createBox(len, 0.03, 0.02, MATERIALS.wood, 0, 0.05, 0);
                const r2 = createBox(len, 0.03, 0.02, MATERIALS.wood, 0, -0.05, 0);
                g.add(r1); g.add(r2);

                return g;
            };

            // --- Helper Functions for Chinese Architecture ---

            // ÂØÑÊ£ü(„Çà„Åõ„ÇÄ„Å≠)„ÉªÂÖ•ÊØçÂ±ã(„ÅÑ„Çä„ÇÇ„ÇÑ)È¢®„ÅÆÂ±ãÊ†π
            const createChineseRoof = (w, d, h, mat, x, y, z, tier = 1) => {
                const roofGroup = new THREE.Group();
                roofGroup.position.set(x, y, z);

                // Main roof slope
                const geom = new THREE.ConeGeometry(w * 0.8, h, 4);
                const mesh = new THREE.Mesh(geom, mat);
                mesh.rotation.y = Math.PI / 4;
                mesh.scale.set(1, 1, d / w); // Adjust aspect
                mesh.castShadow = true;
                roofGroup.add(mesh);

                // Eaves (Âèç„Çä) - represented by a flattened wider cone/box at the bottom
                const eaves = new THREE.Mesh(new THREE.BoxGeometry(w * 1.2, 0.1, d * 1.2), mat);
                eaves.position.y = -h / 2;
                eaves.castShadow = true;
                roofGroup.add(eaves);

                // Ridge decorations for higher tiers
                if (tier >= 2) {
                    const ridge = new THREE.Mesh(new THREE.BoxGeometry(w * 0.8, 0.1, 0.1), MATERIALS.gold);
                    ridge.position.y = h / 2;
                    roofGroup.add(ridge);
                }

                return roofGroup;
            };

            // Êú±Ëâ≤„ÅÆÊü±
            const createPillar = (h, x, y, z) => {
                return createCyl(0.1, 0.1, h, MATERIALS.pillarRed, x, y, z);
            };

            // ÊèêÁÅØ
            const createLantern = (x, y, z) => {
                const g = new THREE.Group();
                g.position.set(x, y, z);
                // String
                g.add(createBox(0.02, 0.2, 0.02, MATERIALS.woodDark, 0, 0.1, 0));
                // Body
                const body = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), MATERIALS.lanternRed);
                body.scale.set(1, 0.8, 1);
                body.castShadow = true;
                g.add(body);
                // Tassel (implied)
                return g;
            };

            // Áü≥Áï≥„ÅÆÂúüÂè∞
            const createFoundation = (w, d) => {
                return createBox(w, 0.2, d, MATERIALS.pavingStone, 0, 0.1, 0);
            };

            // Procedural Props Generator
            const addProps = (targetGroup, seed, count) => {
                for (let i = 0; i < count; i++) {
                    const type = (seed + i) % 3;
                    const offsetX = ((seed * 7 + i * 3) % 10 - 5) * 0.1;
                    const offsetZ = ((seed * 11 + i * 5) % 10 - 5) * 0.1;

                    if (type === 0) { // Barrel
                        targetGroup.add(createCyl(0.1, 0.1, 0.2, MATERIALS.wood, offsetX, 0.1, offsetZ));
                    } else if (type === 1) { // Box
                        targetGroup.add(createBox(0.15, 0.15, 0.15, MATERIALS.woodDark, offsetX, 0.1, offsetZ, (seed + i) * 0.5));
                    } else { // Bush/Pot
                        targetGroup.add(createCone(0.1, 0.2, MATERIALS.leaf, offsetX, 0.1, offsetZ));
                    }
                }
            };

            // --- End Helpers ---

            switch (type) {
                case 'wild': // Êú™ÈñãÊãìÂú∞
                    // Ëçâ
                    for (let i = 0; i < 8; i++) {
                        const r = 0.1 + (i % 3) * 0.05;
                        const x = Math.sin(i * 2.5) * 0.5;
                        const z = Math.cos(i * 2.5) * 0.5;
                        group.add(createCone(0.1, 0.3, MATERIALS.grass, x, 0.15, z, Math.random()));
                    }
                    // Â≤©„ÇÑÊú®
                    group.add(createBox(0.3, 0.2, 0.3, MATERIALS.stone, 0.4, 0.1, 0.4, 0.5));
                    group.add(createCyl(0.05, 0.08, 0.4, MATERIALS.wood, -0.3, 0.2, -0.3)); // Âππ
                    group.add(createCone(0.3, 0.6, MATERIALS.leaf, -0.3, 0.5, -0.3)); // Ëëâ
                    break;

                case 'house': // Ê∞ëÂÆ∂ -> ‰ΩèÂ±Ö (Residence)
                    // ÂúüÂè∞
                    if (tier >= 2) group.add(createFoundation(0.9, 0.9));

                    if (tier === 1) { // Tier 1: Thatched Hut (Straw Roof)
                        // Main walls - slightly tapered look? (Trapezoid logic hard, use box)
                        const houseW = 0.6;
                        const houseD = 0.5;
                        const houseH = 0.4;

                        group.add(createBox(houseW, houseH, houseD, MATERIALS.wallWhite, 0, houseH / 2, 0));

                        // Wooden beams/framing (Timber frame look)
                        // Corners
                        const beamW = 0.06;
                        group.add(createBox(beamW, houseH, beamW, MATERIALS.wood, houseW / 2, houseH / 2, houseD / 2));
                        group.add(createBox(beamW, houseH, beamW, MATERIALS.wood, -houseW / 2, houseH / 2, houseD / 2));
                        group.add(createBox(beamW, houseH, beamW, MATERIALS.wood, houseW / 2, houseH / 2, -houseD / 2));
                        group.add(createBox(beamW, houseH, beamW, MATERIALS.wood, -houseW / 2, houseH / 2, -houseD / 2));

                        // Roof (Straw - Conical/Pyramidal)
                        const roofH = 0.5;
                        const roof = createCone(0.55, roofH, MATERIALS.roofStraw, 0, houseH + roofH / 2 - 0.1, 0, Math.PI / 4); // 8-segment cone
                        roof.scale.set(1, 1, 0.8);
                        group.add(roof);

                        // Door (Detailed)
                        const doorH = 0.3;
                        const doorW = 0.2;
                        group.add(createBox(doorW + 0.04, doorH + 0.04, 0.04, MATERIALS.woodDark, 0, doorH / 2 + 0.02, houseD / 2)); // Frame
                        group.add(createBox(doorW, doorH, 0.06, MATERIALS.wood, 0, doorH / 2, houseD / 2)); // Door
                        group.add(createBox(0.03, 0.03, 0.08, MATERIALS.metal, 0.06, 0.2, houseD / 2)); // Knob

                        // Window (Side)
                        const winSize = 0.15;
                        group.add(createBox(winSize + 0.04, winSize + 0.04, 0.04, MATERIALS.woodDark, houseW / 2, 0.25, 0)); // Frame
                        group.add(createBox(winSize, winSize, 0.05, MATERIALS.wallWhite, houseW / 2, 0.25, 0)); // "Paper"
                        // Window Bars
                        group.add(createBox(winSize, 0.02, 0.06, MATERIALS.woodDark, houseW / 2, 0.25, 0));
                        group.add(createBox(0.02, winSize, 0.06, MATERIALS.woodDark, houseW / 2, 0.25, 0));

                        // Small Garden patch
                        group.add(createBox(0.2, 0.05, 0.15, MATERIALS.leaf, -0.3, 0.05, 0.35));
                        group.add(createCone(0.05, 0.1, MATERIALS.gold, -0.3, 0.1, 0.35)); // Flower?

                    } else { // Tier 2: Áì¶Â±ã (Tile House)
                        // Pillars
                        group.add(createPillar(0.8, 0.35, 0.4, 0.35));
                        group.add(createPillar(0.8, -0.35, 0.4, 0.35));
                        group.add(createPillar(0.8, 0.35, 0.4, -0.35));
                        group.add(createPillar(0.8, -0.35, 0.4, -0.35));

                        // Walls (White plaster)
                        group.add(createBox(0.7, 0.7, 0.7, MATERIALS.wallWhite, 0, 0.45, 0));

                        // Roof (Black tile)
                        group.add(createChineseRoof(1.0, 1.0, 0.6, MATERIALS.roofTileBlack, 0, 1.1, 0, 1));

                        // Door & Windows
                        group.add(createBox(0.25, 0.5, 0.05, MATERIALS.woodDark, 0, 0.25, 0.36));
                        group.add(createBox(0.2, 0.2, 0.05, MATERIALS.wood, 0.25, 0.5, 0.36)); // Window
                        group.add(createBox(0.2, 0.2, 0.05, MATERIALS.wood, -0.25, 0.5, 0.36)); // Window

                        // Lanterns at higher sub-levels (Lv 30)
                        if (vizLevel >= 30) {
                            group.add(createLantern(0.45, 0.8, 0.45));
                            group.add(createLantern(-0.45, 0.8, 0.45));
                        }
                    }

                    // Props (Levels 11-20 in Tier 1, 21-30 in Tier 2)
                    if (vizLevel >= 11) {
                        // Add props based on level seed
                        const propCount = Math.floor(vizLevel / 5);
                        addProps(group, vizLevel, propCount);
                    }

                    // Smoke (common)
                    if (tier >= 2 || vizLevel >= 15) {
                        const smokeNode = new THREE.Object3D();
                        smokeNode.position.set(0, 1.5, 0);
                        smokeNode.userData = { anim: 'smoke' };
                        group.add(smokeNode);
                    }

                    // Simple entrance stone step instead of base
                    group.add(createBox(0.3, 0.05, 0.2, MATERIALS.stone, 0, 0.025, 0.4));
                    break;

                case 'farm': // Áïë -> Ëæ≤Âú∞ (Farmland)
                    // Ground - Soil Texture (Rows)
                    const soilW = 0.9;
                    const soilD = 0.9;
                    // Base soil
                    group.add(createBox(soilW, 0.02, soilD, MATERIALS.dirt, 0, 0.01, 0));

                    // Add distinctive Furrows (3 Rows)
                    for (let i = -1; i <= 1; i++) {
                        group.add(createCyl(0.05, 0.08, soilW, MATERIALS.dirt, i * 0.25, 0.02, 0, Math.PI / 2));
                    }

                    if (tier >= 2) {
                        // Water channel (High detail)
                        const channelW = 0.25;
                        group.add(createBox(1.0, 0.05, channelW, MATERIALS.water, 0, 0.03, 0));
                        // Stone edging
                        group.add(createBox(1.0, 0.06, 0.05, MATERIALS.stone, 0, 0.04, channelW / 2 + 0.02));
                        group.add(createBox(1.0, 0.06, 0.05, MATERIALS.stone, 0, 0.04, -channelW / 2 - 0.02));
                    }

                    // Fence around the farm (Partial)
                    group.add(createFence(-0.45, -0.45, -0.45, 0.45));
                    group.add(createFence(-0.45, 0.45, 0.45, 0.45));
                    if (tier === 1) group.add(createFence(0.45, 0.45, 0.45, -0.45)); // Open front for tier 2 channel

                    // Crops (Detailed)
                    const rows = 3;
                    const cols = tier >= 2 ? 2 : 3;

                    for (let i = 0; i < rows; i++) {
                        for (let j = 0; j < cols; j++) {
                            // Position relative to furrows
                            let xPos = (i - 1) * 0.25; // Match furrow X
                            let zPos = (j - 1) * 0.25;
                            if (tier >= 2) zPos = (j === 0 ? -0.3 : 0.3); // Avoid channel

                            const cropGroup = new THREE.Group();
                            cropGroup.position.set(xPos, 0.05, zPos);
                            const s = 0.8 + Math.random() * 0.4;
                            cropGroup.scale.set(s, s, s);
                            cropGroup.rotation.y = Math.random() * Math.PI;

                            if (tier === 1) {
                                // Turnip/Vegetable (Leafy)
                                cropGroup.add(createCone(0.08, 0.15, MATERIALS.leaf, 0, 0.05, 0));
                                cropGroup.add(createCone(0.06, 0.12, MATERIALS.leaf, 0.02, 0.04, 0, 0.2));
                                cropGroup.add(createCone(0.06, 0.12, MATERIALS.leaf, -0.02, 0.04, 0, -0.2));
                                // The veg itself peeking out
                                cropGroup.add(createCyl(0.03, 0.01, 0.05, MATERIALS.white, 0, -0.01, 0));
                            } else {
                                // Wheat/Rice Stalks
                                for (let k = 0; k < 3; k++) {
                                    const stalk = createCyl(0.01, 0.01, 0.3, MATERIALS.wood, (Math.random() - 0.5) * 0.05, 0.15, (Math.random() - 0.5) * 0.05);
                                    cropGroup.add(stalk);
                                    const grain = createBox(0.03, 0.08, 0.03, MATERIALS.gold, stalk.position.x, 0.28, stalk.position.z);
                                    cropGroup.add(grain);
                                }
                            }
                            cropGroup.userData = { anim: 'sway', speed: 2.0 + Math.random(), offset: Math.random() };
                            group.add(cropGroup);
                        }
                    }

                    // Props: Scarecrow, Fence, Tools (ALWAYS present at Level 1 for identity)
                    if (vizLevel >= 1) {
                        // Scarecrow
                        const sc = new THREE.Group();
                        sc.position.set(0.4, 0, 0.4);
                        sc.add(createCyl(0.03, 0.03, 0.6, MATERIALS.wood, 0, 0.3, 0));
                        sc.add(createBox(0.3, 0.03, 0.03, MATERIALS.wood, 0, 0.4, 0));
                        sc.add(createBox(0.1, 0.1, 0.1, MATERIALS.white, 0, 0.5, 0)); // Head
                        sc.rotation.y = 0.5;
                        group.add(sc);
                    }
                    if (tier >= 2) {
                        // Water bucket next to channel
                        group.add(createCyl(0.1, 0.08, 0.12, MATERIALS.wood, -0.4, 0.15, -0.1));
                    }
                    break;

                case 'lumber': // ‰ºêÊé°ÊâÄ (Lumber Mill)
                    // Ground - Wood chips / worn dirt
                    group.add(createBox(1.0, 0.02, 1.0, MATERIALS.dirt, 0, 0.01, 0));
                    // Wood chips texture (particles)
                    for (let i = 0; i < 15; i++) {
                        const s = 0.05 + Math.random() * 0.05;
                        group.add(createBox(s, 0.01, s, MATERIALS.wood, (Math.random() - 0.5) * 0.8, 0.02, (Math.random() - 0.5) * 0.8));
                    }

                    if (tier === 1) { // Tier 1: Woodcutter's Camp
                        // 1. The Chopping Area
                        const stump = createCyl(0.2, 0.25, 0.3, MATERIALS.wood, 0.3, 0.15, 0.3);
                        group.add(stump);
                        // Axe embedded
                        const axeGroup = new THREE.Group();
                        axeGroup.position.set(0.3, 0.3, 0.3);
                        axeGroup.rotation.z = 0.6;
                        axeGroup.rotation.y = 0.5;
                        axeGroup.add(createCyl(0.02, 0.03, 0.4, MATERIALS.wood, 0, 0.2, 0));
                        axeGroup.add(createBox(0.15, 0.08, 0.02, MATERIALS.metal, 0, 0.4, 0)); // Blade
                        group.add(axeGroup);

                        // 2. Woodcutter's Shack (Small enclosed hut) - Adds mass to building
                        const shack = new THREE.Group();
                        shack.position.set(-0.25, 0, -0.25);
                        // Walls
                        shack.add(createBox(0.45, 0.4, 0.45, MATERIALS.woodDark, 0, 0.2, 0));
                        // Doorway
                        shack.add(createBox(0.15, 0.3, 0.05, MATERIALS.dark, 0.1, 0.15, 0.21));
                        // Roof (Sloped single shed roof)
                        const roof = createBox(0.55, 0.05, 0.6, MATERIALS.wood, 0, 0.45, 0);
                        roof.rotation.x = 0.2;
                        shack.add(roof);
                        group.add(shack);

                        // 3. Stacked Logs
                        group.add(createCyl(0.1, 0.1, 0.8, MATERIALS.wood, 0.3, 0.05, -0.2, Math.PI / 2, 0.1));
                        group.add(createCyl(0.1, 0.1, 0.8, MATERIALS.wood, 0.4, 0.05, -0.3, Math.PI / 2, -0.05));
                        group.add(createCyl(0.1, 0.1, 0.8, MATERIALS.wood, 0.35, 0.12, -0.25, Math.PI / 2, 0));

                        // Dead Tree / Standing Timber
                        const deadTree = new THREE.Group();
                        deadTree.position.set(-0.35, 0, 0.35);
                        deadTree.add(createCyl(0.08, 0.12, 0.6, MATERIALS.woodDark, 0, 0.3, 0));
                        deadTree.add(createCyl(0.04, 0.06, 0.3, MATERIALS.woodDark, 0.1, 0.5, 0, 0, 0, -0.5)); // Branch
                        group.add(deadTree);

                    } else { // Tier 2: Sawmill Yard (Open Air with Roofed Storage)
                        const roofY = 0.8;

                        // 1. Saw Mechanism Area (Left side)
                        const sawGroup = new THREE.Group();
                        sawGroup.position.set(-0.2, 0, 0);

                        // Roof over saw
                        sawGroup.add(createPillar(0.7, -0.25, 0.35, -0.25));
                        sawGroup.add(createPillar(0.7, 0.25, 0.35, -0.25));
                        sawGroup.add(createPillar(0.7, -0.25, 0.35, 0.25));
                        sawGroup.add(createPillar(0.7, 0.25, 0.35, 0.25));
                        sawGroup.add(createBox(0.6, 0.05, 0.6, MATERIALS.wood, 0, roofY, 0)); // Simple roof

                        // Reciprocating Frame Saw (Vertical)
                        const sawBase = createBox(0.4, 0.2, 0.3, MATERIALS.wood, 0, 0.1, 0);
                        sawGroup.add(sawBase);

                        // The Frame holding the blade
                        const frame = new THREE.Group();
                        frame.position.set(0, 0.4, 0);
                        // Side posts
                        frame.add(createBox(0.05, 0.4, 0.05, MATERIALS.woodDark, 0, 0, 0.1));
                        frame.add(createBox(0.05, 0.4, 0.05, MATERIALS.woodDark, 0, 0, -0.1));
                        // Top/Bottom bars
                        frame.add(createBox(0.05, 0.05, 0.25, MATERIALS.woodDark, 0, 0.175, 0));
                        frame.add(createBox(0.05, 0.05, 0.25, MATERIALS.woodDark, 0, -0.175, 0));
                        // Blade
                        frame.add(createBox(0.02, 0.35, 0.15, MATERIALS.metal, 0, 0, 0));
                        frame.userData = { anim: 'shuttleY', speed: 1.0, range: 0.15 };
                        sawGroup.add(frame);

                        // Log being cut
                        sawGroup.add(createCyl(0.12, 0.12, 0.8, MATERIALS.wood, 0, 0.25, 0, Math.PI / 2));
                        // Sawdust
                        sawGroup.add(createCone(0.2, 0.1, MATERIALS.gold, 0.4, 0.05, 0.4));
                        group.add(sawGroup);


                        // 2. Timber Storage Shed (Right side) - Adds volume
                        const shed = new THREE.Group();
                        shed.position.set(0.35, 0, 0);
                        // Roof (sloped)
                        shed.add(createPillar(0.6, 0.2, 0.3, -0.2)); // Back high
                        shed.add(createPillar(0.6, 0.2, 0.3, 0.2));
                        shed.add(createPillar(0.5, -0.2, 0.25, -0.2)); // Front low
                        shed.add(createPillar(0.5, -0.2, 0.25, 0.2));

                        const shedRoof = createBox(0.5, 0.05, 0.6, MATERIALS.wood, 0, 0.65, 0);
                        shedRoof.rotation.z = 0.2; // Slope
                        shed.add(shedRoof);

                        // Stacked Timber inside
                        shed.add(createBox(0.3, 0.3, 0.4, MATERIALS.wood, 0, 0.15, 0));
                        shed.add(createBox(0.3, 0.3, 0.4, MATERIALS.wood, 0, 0.15, 0)); // just a block of wood for now? No, make it look like planks
                        // Planks texture
                        for (let k = 0; k < 5; k++) {
                            shed.add(createBox(0.35, 0.04, 0.4, MATERIALS.woodDark, 0, 0.05 + k * 0.06, 0));
                        }
                        group.add(shed);
                    }
                    break;

                case 'quarry': // Êé°Áü≥Â†¥ -> Áü≥Âàá„ÇäÂ†¥ (Stone Pit)
                    // Ground - Thin stone layer

                    // Rock Face (Jagged, irregular)
                    const rockScale = tier >= 2 ? 0.8 : 0.6;
                    for (let i = 0; i < 4; i++) {
                        // Random-ish looking rocks
                        const rx = -0.3 + (i % 2) * 0.6;
                        const rz = -0.3 + Math.floor(i / 2) * 0.6;
                        const rh = 0.2 + Math.random() * 0.4;
                        group.add(createBox(0.3, rh, 0.3, MATERIALS.stone, rx, rh / 2, rz));
                    }

                    if (tier >= 2) {
                        // Crane (Wooden) - No walls, distinctive silhouette
                        const craneGroup = new THREE.Group();
                        craneGroup.position.set(0.2, 0, 0.2);
                        craneGroup.add(createCyl(0.06, 0.08, 1.2, MATERIALS.wood, 0, 0.6, 0)); // Mast

                        const jib = createBox(0.8, 0.06, 0.06, MATERIALS.wood, -0.3, 1.1, 0); // Jib
                        jib.rotation.z = 0.2;
                        craneGroup.add(jib);

                        // Hanging stone
                        const rope = createCyl(0.01, 0.01, 0.6, MATERIALS.white, -0.6, 0.8, 0);
                        craneGroup.add(rope);
                        const stone = createBox(0.25, 0.25, 0.25, MATERIALS.stone, -0.6, 0.5, 0);
                        craneGroup.add(stone);

                        craneGroup.rotation.y = -0.7; // Angle it
                        group.add(craneGroup);

                        // Cut stone blocks ready for transport
                        group.add(createBox(0.2, 0.15, 0.3, MATERIALS.stoneWhite, -0.3, 0.075, 0.4));
                    } else {
                        // Tier 1: Just tools and rubble
                        group.add(createBox(0.05, 0.4, 0.05, MATERIALS.wood, 0, 0.2, 0, 0.5)); // Pick handle
                        group.add(createBox(0.2, 0.05, 0.05, MATERIALS.metal, 0, 0.4, 0, 0.5)); // Pick head

                        // Rubble
                        group.add(createCone(0.3, 0.2, MATERIALS.stone, 0.3, 0.1, 0.3));

                        // Wheelbarrow (suggests transport)
                        const barrow = new THREE.Group();
                        barrow.position.set(-0.3, 0.1, 0.3);
                        barrow.rotation.y = 0.5;
                        barrow.add(createBox(0.2, 0.1, 0.3, MATERIALS.wood, 0, 0, 0));
                        barrow.add(createCyl(0.08, 0.08, 0.05, MATERIALS.woodDark, 0, -0.05, 0.15, 0, 0, Math.PI / 2)); // Wheel
                        barrow.add(createCyl(0.02, 0.02, 0.4, MATERIALS.wood, -0.08, 0.1, -0.2)); // Handle L
                        barrow.add(createCyl(0.02, 0.02, 0.4, MATERIALS.wood, 0.08, 0.1, -0.2)); // Handle R
                        group.add(barrow);
                    }
                    break;

                case 'mine': // Èâ±Â±± -> ÈâÑÂ±± (Iron Mine)
                    // Ground - Thin dirt layer
                    group.add(createBox(1.0, 0.02, 1.0, MATERIALS.dirt, 0, 0.01, 0));

                    if (tier === 1) { // Tier 1: Mine Shaft
                        // Hill/Mound
                        group.add(createBox(0.9, 0.5, 0.6, MATERIALS.dirt, 0, 0.25, -0.2));
                        // Entrance frame
                        group.add(createBox(0.5, 0.4, 0.1, MATERIALS.wood, 0, 0.2, 0.1));
                        group.add(createBox(0.4, 0.35, 0.05, MATERIALS.dark, 0, 0.175, 0.12)); // Hole

                        // Lantern at entrance
                        group.add(createBox(0.1, 0.15, 0.1, MATERIALS.gold, -0.3, 0.3, 0.15)); // Light

                        // Rails coming out
                        group.add(createBox(0.03, 0.03, 0.6, MATERIALS.metal, -0.15, 0.11, 0.3));
                        group.add(createBox(0.03, 0.03, 0.6, MATERIALS.metal, 0.15, 0.11, 0.3));
                        // Sleepers
                        group.add(createBox(0.4, 0.02, 0.05, MATERIALS.wood, 0, 0.1, 0.2));
                        group.add(createBox(0.4, 0.02, 0.05, MATERIALS.wood, 0, 0.1, 0.4));

                    } else { // Tier 2: Ironworks
                        // Blast Furnace (Tall cylinder/cone structure) - distinctive profile
                        group.add(createCyl(0.4, 0.3, 1.0, MATERIALS.stone, 0, 0.5, -0.1));
                        // Fire glow at base
                        group.add(createBox(0.2, 0.2, 0.1, MATERIALS.gold, 0, 0.2, 0.15));

                        // Bellows (Fungo) attached
                        group.add(createBox(0.3, 0.2, 0.4, MATERIALS.wood, 0.4, 0.15, 0));

                        // Chimney smoke
                        const smokeNode = new THREE.Object3D();
                        smokeNode.position.set(0, 1.2, -0.1);
                        smokeNode.userData = { anim: 'smoke' };
                        group.add(smokeNode);

                        // Pile of Iron Ore
                        group.add(createCone(0.3, 0.3, MATERIALS.dark, -0.4, 0.15, 0.3));
                    }
                    break;

                    // Props (Ore cart)
                    if (vizLevel >= 15) {
                        const cart = new THREE.Group();
                        cart.position.set(0, 0.15, 0.3);
                        cart.add(createBox(0.25, 0.15, 0.2, MATERIALS.wood, 0, 0, 0));
                        cart.add(createBox(0.2, 0.1, 0.15, MATERIALS.dark, 0, 0.05, 0)); // Ore
                        group.add(cart);
                    }
                    break;

                case 'market': // Â∏ÇÂ†¥ -> Â∏Ç (Bazaar)
                    // No solid ground box - just placed on the road/grass

                    // Tier 1: Open Mat Market (Enhanced)
                    if (tier === 1) {
                        // Rug/Mat on ground - Keep thin
                        group.add(createBox(0.8, 0.02, 0.6, MATERIALS.roofStraw, 0, 0.01, 0));

                        // Simple Stall Structure (Crates + Board + Sunshade)
                        const tableH = 0.2;
                        // Table improvised (Crates)
                        group.add(createBox(0.15, tableH, 0.15, MATERIALS.woodDark, -0.15, tableH / 2, -0.1));
                        group.add(createBox(0.15, tableH, 0.15, MATERIALS.woodDark, 0.15, tableH / 2, -0.1));
                        // Table Top
                        group.add(createBox(0.5, 0.02, 0.25, MATERIALS.wood, 0, tableH, -0.1));

                        // Sunshade / Umbrella (Striped)
                        const umbrella = new THREE.Group();
                        umbrella.position.set(0.3, 0, 0.2);
                        umbrella.add(createCyl(0.03, 0.03, 0.7, MATERIALS.wood, 0, 0.35, 0)); // Pole

                        // Shade (Red/White stripes improvised by overlapped cones?)
                        // Just use Tent material which is reddish
                        const shade = createCone(0.35, 0.15, MATERIALS.tent, 0, 0.7, 0);
                        umbrella.add(shade);
                        group.add(umbrella);

                        // Seat
                        group.add(createCyl(0.1, 0.1, 0.08, MATERIALS.wood, -0.2, 0.04, 0.2));

                        // Wares (Detailed)
                        // Pot
                        const pot = createCyl(0.06, 0.04, 0.08, MATERIALS.stone, 0.15, tableH + 0.04, -0.08);
                        group.add(pot);
                        // Apples? (Red spheres/boxes)
                        group.add(createBox(0.04, 0.04, 0.04, MATERIALS.tent, -0.1, tableH + 0.02, -0.1));
                        group.add(createBox(0.04, 0.04, 0.04, MATERIALS.tent, -0.05, tableH + 0.02, -0.08));

                        // Vertical Sign/Flag
                        group.add(createCyl(0.02, 0.02, 0.8, MATERIALS.wood, -0.35, 0.4, 0.25));
                        group.add(createBox(0.2, 0.4, 0.01, MATERIALS.white, -0.35, 0.6, 0.25)); // Banner
                        // Text on banner? (Texture not avail, use red box trick)
                        group.add(createBox(0.05, 0.2, 0.015, MATERIALS.tent, -0.35, 0.6, 0.25));

                    } else { // Tier 2: Tented Stalls (Pavilions)
                        // Structure: 4 Poles + Cloth Roof (No walls)
                        group.add(createPillar(0.6, -0.3, 0.3, -0.3));
                        group.add(createPillar(0.6, 0.3, 0.3, -0.3));
                        group.add(createPillar(0.6, -0.3, 0.3, 0.3));
                        group.add(createPillar(0.6, 0.3, 0.3, 0.3));

                        // Cloth Roof (Draped)
                        const cloth = createBox(0.8, 0.05, 0.8, MATERIALS.tent, 0, 0.6, 0);
                        // Drapes? - simplified as box for now, maybe add smaller side pieces
                        group.add(cloth);

                        // Tables with wares
                        group.add(createBox(0.7, 0.2, 0.3, MATERIALS.wood, 0, 0.2, 0)); // Main table back
                        group.add(createBox(0.1, 0.1, 0.1, MATERIALS.leaf, -0.2, 0.35, 0));
                        group.add(createBox(0.1, 0.1, 0.1, MATERIALS.gold, 0.2, 0.35, 0));

                        // Banners/Flags
                        group.add(createCyl(0.02, 0.02, 1.0, MATERIALS.wood, -0.38, 0.5, 0.38));
                        group.add(createBox(0.2, 0.1, 0.01, MATERIALS.roof, -0.38, 0.8, 0.38)); // Red flag
                    }

                    // Props: More baskets/pots
                    if (vizLevel >= 15) {
                        group.add(createCyl(0.1, 0.12, 0.15, MATERIALS.wood, 0.35, 0.08, 0.35));
                    }
                    break;

                case 'blacksmith': // ÈçõÂÜ∂Â±ã -> ÂÖµÂô®Âª† (Arsenal)
                    // Ground - stone patches
                    if (tier >= 2) group.add(createBox(1.0, 0.02, 1.0, MATERIALS.stone, 0, 0.01, 0));

                    if (tier === 1) { // Tier 1: Field Smithy
                        // 1. Large Open Furnace (Stone)
                        group.add(createBox(0.5, 0.4, 0.4, MATERIALS.stone, 0, 0.2, -0.2));
                        // Fire Heart
                        group.add(createBox(0.25, 0.2, 0.2, MATERIALS.gold, 0, 0.2, -0.15));
                        // Chimney/Vent hint
                        group.add(createBox(0.3, 0.2, 0.1, MATERIALS.stone, 0, 0.5, -0.3));

                        // 2. Anvil on Stump (Prominent)
                        group.add(createCyl(0.2, 0.25, 0.25, MATERIALS.wood, -0.25, 0.125, 0.1)); // Stump
                        // Anvil Shape (T-shape)
                        const anvilGroup = new THREE.Group();
                        anvilGroup.position.set(-0.25, 0.3, 0.1);
                        anvilGroup.add(createBox(0.12, 0.15, 0.25, MATERIALS.metal, 0, 0, 0)); // Base
                        anvilGroup.add(createBox(0.18, 0.08, 0.3, MATERIALS.metal, 0, 0.1, 0)); // Top
                        // Hammer resting
                        anvilGroup.add(createBox(0.03, 0.03, 0.2, MATERIALS.wood, 0, 0.15, 0, 0, 0, 0.2));
                        group.add(anvilGroup);

                        // 3. Water Trough
                        group.add(createBox(0.25, 0.15, 0.15, MATERIALS.wood, 0.25, 0.075, 0.2));
                        group.add(createBox(0.2, 0.1, 0.1, MATERIALS.water, 0.25, 0.1, 0.2));

                        // 4. Weapon Rack (Spears)
                        const rack = new THREE.Group();
                        rack.position.set(0.35, 0.2, -0.1);
                        rack.add(createBox(0.1, 0.4, 0.05, MATERIALS.wood, 0, 0, 0));
                        // Spear
                        rack.add(createCyl(0.02, 0.02, 0.6, MATERIALS.metal, 0, 0.1, 0.05, 0.2));
                        group.add(rack);
                    } else { // Tier 2: Arsenal (Roof but no walls)
                        // 4 Poles
                        const h = 0.8;
                        group.add(createPillar(h, -0.35, 0.4, -0.35));
                        group.add(createPillar(h, 0.35, 0.4, -0.35));
                        group.add(createPillar(h, -0.35, 0.4, 0.35));
                        group.add(createPillar(h, 0.35, 0.4, 0.35));
                        // Roof
                        group.add(createChineseRoof(0.9, 0.9, 0.3, MATERIALS.roofTileBlack, 0, h + 0.15, 0));

                        // Larger Furnace
                        group.add(createBox(0.4, 0.5, 0.4, MATERIALS.stone, -0.2, 0.25, -0.2));
                        group.add(createBox(0.2, 0.2, 0.1, MATERIALS.gold, -0.2, 0.2, -0.01)); // Fire

                        // Weapon Racks
                        const rack = new THREE.Group();
                        rack.position.set(0.3, 0, 0.2);
                        rack.add(createBox(0.1, 0.5, 0.4, MATERIALS.wood, 0, 0.25, 0));
                        // Spears
                        rack.add(createCyl(0.01, 0.01, 0.7, MATERIALS.metal, 0, 0.35, 0.1));
                        rack.add(createCyl(0.01, 0.01, 0.7, MATERIALS.metal, 0, 0.35, -0.1));
                        group.add(rack);

                        // Anvil
                        group.add(createBox(0.2, 0.3, 0.2, MATERIALS.metal, 0, 0.15, 0.2));
                    }

                    // Smoke (Both tiers)
                    const smokeB = new THREE.Object3D();
                    smokeB.position.set(0, 0.8, -0.2);
                    smokeB.userData = { anim: 'smoke' };
                    group.add(smokeB);
                    break;

                case 'well': // ‰∫ïÊà∏ -> Áµ¶Ê∞¥ÊâÄ (Water Works)
                    // Ground: Paving stones - Thin
                    group.add(createBox(0.8, 0.02, 0.8, MATERIALS.pavingStone, 0, 0.01, 0));

                    // Well Base
                    group.add(createCyl(0.35, 0.35, 0.3, MATERIALS.stone, 0, 0.15, 0, 0, 8));
                    group.add(createCyl(0.28, 0.28, 0.31, MATERIALS.water, 0, 0.15, 0, 0, 8));

                    if (tier >= 2) {
                        // Roof over well (Small shrine style) - 2 pillars
                        group.add(createPillar(0.7, -0.3, 0.35, 0));
                        group.add(createPillar(0.7, 0.3, 0.35, 0));
                        // Small Roof
                        group.add(createChineseRoof(0.8, 0.5, 0.3, MATERIALS.roofTileGreen, 0, 0.75, 0));

                        // Pulley system
                        group.add(createBox(0.6, 0.05, 0.05, MATERIALS.wood, 0, 0.5, 0));
                        // Bucket line
                        group.add(createCyl(0.005, 0.005, 0.3, MATERIALS.white, 0, 0.4, 0));
                    }

                    // Bucket
                    if (vizLevel >= 15 || tier >= 2) {
                        const bucket = createCyl(0.1, 0.08, 0.12, MATERIALS.wood, 0, tier >= 2 ? 0.25 : 0.3, 0);
                        if (tier >= 2) bucket.userData = { anim: 'bounceY', speed: 0.15, range: 0.05 };
                        group.add(bucket);
                    }
                    // Tier 1 props - Pulley Frame
                    if (tier === 1) {
                        // Simple wooden frame over well
                        group.add(createCyl(0.04, 0.04, 0.6, MATERIALS.wood, -0.25, 0.3, 0));
                        group.add(createCyl(0.04, 0.04, 0.6, MATERIALS.wood, 0.25, 0.3, 0));
                        group.add(createCyl(0.03, 0.03, 0.5, MATERIALS.wood, 0, 0.55, 0, 0, 0, Math.PI / 2));

                        if (vizLevel >= 5) {
                            group.add(createBox(0.15, 0.05, 0.2, MATERIALS.wood, 0.3, 0.05, 0.3)); // Wash board/platform
                        }
                    }
                    break;

                case 'inn': // ÂÆøÂ±ã -> Ëå∂È§®/ÂÆøÂ†¥ (Teahouse/Inn)
                    // Ground - Removed Foundation

                    if (tier === 1) { // Tier 1: Teahouse
                        // Open-front building
                        // Back wall and side walls
                        group.add(createBox(0.8, 0.5, 0.6, MATERIALS.wallWhite, 0, 0.25, 0));

                        // Overhanging roof for seating area
                        group.add(createBox(0.8, 0.05, 0.3, MATERIALS.roofStraw, 0, 0.4, 0.45));
                        group.add(createPillar(0.4, -0.35, 0.2, 0.55));
                        group.add(createPillar(0.4, 0.35, 0.2, 0.55));

                        // Main Roof
                        const roof = createCone(0.9, 0.6, MATERIALS.roofStraw, 0, 0.8, 0, Math.PI / 4);
                        roof.scale.z = 0.8;
                        group.add(roof);

                        // Tea bench outside
                        group.add(createBox(0.3, 0.1, 0.15, MATERIALS.wood, 0, 0.05, 0.5)); // Bench
                        group.add(createBox(0.3, 0.02, 0.15, MATERIALS.roof, 0, 0.11, 0.5)); // Red Cloth on bench
                        group.add(createBox(0.2, 0.2, 0.02, MATERIALS.tent, 0.2, 0.35, 0.31)); // Noren (Curtain)

                    } else { // Tier 2: Inn (2-Story with balconies)
                        // 1st Floor
                        group.add(createBox(0.8, 0.5, 0.8, MATERIALS.woodDark, 0, 0.25, 0));
                        // 2nd Floor (Slightly smaller)
                        group.add(createBox(0.7, 0.5, 0.7, MATERIALS.wallWhite, 0, 0.75, 0));

                        // Roofs
                        group.add(createChineseRoof(1.0, 1.0, 0.2, MATERIALS.roofTileBlack, 0, 0.5, 0)); // 1st floor roof skirting
                        group.add(createChineseRoof(0.9, 0.7, 0.5, MATERIALS.roofTileBlack, 0, 1.25, 0)); // Main roof

                        // Balcony (Wraparound)
                        group.add(createBox(0.8, 0.05, 0.1, MATERIALS.wood, 0, 0.5, 0.4)); // Floor
                        group.add(createBox(0.8, 0.15, 0.05, MATERIALS.wood, 0, 0.6, 0.45)); // Railing

                        // Lanterns
                        group.add(createLantern(0.4, 0.4, 0.45));
                        group.add(createLantern(-0.4, 0.4, 0.45));

                        // Signboard
                        const sign = createBox(0.15, 0.3, 0.05, MATERIALS.wood, 0.3, 0.25, 0.42);
                        group.add(sign);
                    }

                    // Horse props if high level
                    if (vizLevel >= 15) {
                        group.add(createBox(0.3, 0.05, 0.1, MATERIALS.wood, -0.3, 0.1, 0.4)); // Trough
                    }
                    break;

                case 'clocktower': // ÊôÇË®àÂ°î -> ÈêòÊ•º (Bell Tower)
                    // Ground - minimal
                    const towerH = tier >= 2 ? 1.4 : 1.0;

                    if (tier === 1) { // Tier 1: Watchtower (Wood) - Open frame
                        // Legs
                        group.add(createCyl(0.05, 0.08, towerH, MATERIALS.wood, 0.2, towerH / 2, 0.2));
                        group.add(createCyl(0.05, 0.08, towerH, MATERIALS.wood, -0.2, towerH / 2, 0.2));
                        group.add(createCyl(0.05, 0.08, towerH, MATERIALS.wood, 0.2, towerH / 2, -0.2));
                        group.add(createCyl(0.05, 0.08, towerH, MATERIALS.wood, -0.2, towerH / 2, -0.2));
                        // Cross braces
                        group.add(createBox(0.5, 0.05, 0.05, MATERIALS.wood, 0, towerH * 0.3, 0.2));
                        group.add(createBox(0.5, 0.05, 0.05, MATERIALS.wood, 0, towerH * 0.6, -0.2));

                        // Platform (railed)
                        group.add(createBox(0.5, 0.05, 0.5, MATERIALS.wood, 0, towerH, 0));
                        group.add(createBox(0.5, 0.2, 0.05, MATERIALS.wood, 0, towerH + 0.1, 0.22)); // Rail
                        group.add(createBox(0.5, 0.2, 0.05, MATERIALS.wood, 0, towerH + 0.1, -0.22)); // Rail

                        // Drum/Gong
                        group.add(createCyl(0.15, 0.15, 0.1, MATERIALS.wood, 0, towerH + 0.1, 0, Math.PI / 2));
                    } else { // Tier 2: Bell Tower (Stone Base, Open top)
                        // Stone Base - kept for Bell Tower as it IS the building
                        group.add(createBox(0.6, 0.8, 0.6, MATERIALS.stone, 0, 0.4, 0));

                        // Upper Wooden Frame
                        const upperY = 0.8;
                        const topY = upperY + 0.6;
                        // Pillars
                        group.add(createPillar(0.6, 0.25, upperY + 0.3, 0.25));
                        group.add(createPillar(0.6, -0.25, upperY + 0.3, 0.25));
                        group.add(createPillar(0.6, 0.25, upperY + 0.3, -0.25));
                        group.add(createPillar(0.6, -0.25, upperY + 0.3, -0.25));

                        // Big Bronze Bell
                        const bell = createCyl(0.2, 0.3, 0.3, MATERIALS.metal, 0, upperY + 0.3, 0);
                        bell.userData = { anim: 'sway', speed: 2.0, offset: 0 };
                        group.add(bell);

                        // Roof (Hip-and-Gable)
                        group.add(createChineseRoof(0.8, 0.8, 0.5, MATERIALS.roofTileGreen, 0, topY, 0, 1));
                    }
                    break;

                case 'forest': // Ê£Æ -> Á´πÊûó (Bamboo Grove)
                    // Forest Area (1x2). Slave tile at Z+3.0 equivalent distance logic
                    // Logic handles rendering at Master pos.

                    const addTree = (tx, tz, s) => {
                        if (tier >= 2) {
                            // Bamboo
                            const bamboo = new THREE.Group();
                            bamboo.position.set(tx, 0, tz);
                            bamboo.scale.set(s, s * 1.5, s);
                            // Segments
                            bamboo.add(createCyl(0.05, 0.06, 0.8, MATERIALS.leaf, 0, 0.4, 0));
                            // Leaves
                            bamboo.add(createCone(0.2, 0.3, MATERIALS.leaf, 0, 0.7, 0));
                            bamboo.userData = { anim: 'sway', speed: 1.0 + Math.random(), offset: Math.random() * 10 };
                            group.add(bamboo);
                        } else {
                            // Normal Tree
                            const trunk = createCyl(0.1 * s, 0.15 * s, 0.5 * s, MATERIALS.wood, tx, 0.25 * s, tz);
                            group.add(trunk);
                            const l1 = createCone(0.4 * s, 0.6 * s, MATERIALS.darkLeaf, tx, 0.6 * s, tz);
                            group.add(l1);
                            const l2 = createCone(0.3 * s, 0.5 * s, MATERIALS.darkLeaf, tx, 0.9 * s, tz);
                            group.add(l2);
                        }
                    };

                    // Cabin removal - Tier 1 woods focus on nature
                    if (tier === 1) {
                        // Small Shrine / Landmark instead of House
                        group.add(createBox(0.2, 0.4, 0.2, MATERIALS.stone, 0, 0.2, 0.2));
                        group.add(createBox(0.3, 0.1, 0.3, MATERIALS.stone, 0, 0.45, 0.2));
                        // Fallen Log
                        group.add(createCyl(0.1, 0.1, 0.6, MATERIALS.wood, 0.4, 0.05, -0.4, Math.PI / 2, Math.PI / 6));
                    } else {
                        // Tier 2: Bamboo features - maybe a small fence?
                        group.add(createBox(0.05, 0.6, 0.05, MATERIALS.wood, 0.5, 0.3, 0.5));
                        group.add(createBox(0.05, 0.6, 0.05, MATERIALS.wood, -0.5, 0.3, 0.5));
                        group.add(createBox(1.0, 0.05, 0.05, MATERIALS.wood, 0, 0.4, 0.5));
                    }

                    // Scatter trees
                    const range = tier >= 2 ? 0.6 : 0.8; // Denser for bamboo
                    const dens = tier >= 2 ? 1.5 : 1.0;

                    // Master area
                    addTree(-0.8, -0.8, 0.9);
                    addTree(0.8, -0.6, 0.8);
                    addTree(0.6, 0.8, 0.7);
                    if (tier >= 2) addTree(0.2, -0.9, 0.8);

                    // Slave area (z around 3.0)
                    addTree(0, 3.0, 1.2);
                    addTree(-0.8, 2.5, 0.9);
                    addTree(0.8, 2.5, 0.8);
                    addTree(-0.7, 3.5, 0.7);
                    addTree(0.7, 3.6, 0.8);
                    if (tier >= 2) {
                        addTree(0.3, 2.8, 0.9);
                        addTree(-0.3, 3.2, 0.8);
                    }
                    break;

                case 'bank': // ÈäÄË°å -> ÈáëÂ∫´ (Vault)
                    // Ground - stone path under door?

                    if (tier === 1) { // Tier 1: Storehouse (Kurazukuri style)
                        // White walls, thick, small footprint high height
                        group.add(createBox(0.7, 0.7, 0.7, MATERIALS.wallWhite, 0, 0.35, 0));
                        // Black base (part of the building, not platform)
                        group.add(createBox(0.72, 0.2, 0.72, MATERIALS.dark, 0, 0.1, 0));
                        // Roof - Heavy Tiled, but simple
                        group.add(createChineseRoof(0.8, 0.8, 0.4, MATERIALS.roofTileBlack, 0, 0.9, 0));
                        // Heavy Door with no windows anywhere else
                        group.add(createBox(0.3, 0.35, 0.05, MATERIALS.metal, 0, 0.25, 0.36));
                    } else { // Tier 2: Stone Vault (Fortress-like)
                        // Heavy Stone Block (Chamfered look?)
                        group.add(createBox(0.8, 0.6, 0.8, MATERIALS.stone, 0, 0.3, 0));
                        // Reinforced Corners
                        group.add(createBox(0.15, 0.65, 0.15, MATERIALS.stoneWhite, 0.35, 0.32, 0.35));
                        group.add(createBox(0.15, 0.65, 0.15, MATERIALS.stoneWhite, -0.35, 0.32, 0.35));
                        group.add(createBox(0.15, 0.65, 0.15, MATERIALS.stoneWhite, 0.35, 0.32, -0.35));
                        group.add(createBox(0.15, 0.65, 0.15, MATERIALS.stoneWhite, -0.35, 0.32, -0.35));

                        // Flat Stone Roof / Battlements
                        group.add(createBox(0.9, 0.1, 0.9, MATERIALS.stoneWhite, 0, 0.65, 0));

                        // Gold Doors
                        group.add(createBox(0.4, 0.5, 0.05, MATERIALS.gold, 0, 0.25, 0.41));

                        // Gold accents
                        group.add(createBox(0.2, 0.2, 0.2, MATERIALS.gold, 0, 0.75, 0)); // Top ornament
                    }

                    if (tier >= 3) {
                        // Gold piles
                        group.add(createBox(0.2, 0.1, 0.2, MATERIALS.gold, 0.3, 0.1, 0.3));
                        group.add(createBox(0.2, 0.15, 0.2, MATERIALS.gold, -0.3, 0.1, 0.3));
                    }
                    break;

                case 'granary': // Á©ÄÂÄâ (Granary)
                    // Ground - minimal

                    if (tier === 1) { // Tier 1: Raised Floor Granary (Takayuka)
                        // Stilts
                        group.add(createCyl(0.05, 0.05, 0.3, MATERIALS.wood, 0.3, 0.15, 0.3));
                        group.add(createCyl(0.05, 0.05, 0.3, MATERIALS.wood, -0.3, 0.15, 0.3));
                        group.add(createCyl(0.05, 0.05, 0.3, MATERIALS.wood, 0.3, 0.15, -0.3));
                        group.add(createCyl(0.05, 0.05, 0.3, MATERIALS.wood, -0.3, 0.15, -0.3));

                        // Main box
                        group.add(createBox(0.7, 0.5, 0.7, MATERIALS.wood, 0, 0.55, 0));
                        // Roof
                        group.add(createChineseRoof(0.8, 0.8, 0.5, MATERIALS.roofStraw, 0, 1.05, 0));
                        // Ladder
                        const ladder = createBox(0.2, 0.4, 0.05, MATERIALS.wood, 0, 0.2, 0.35);
                        ladder.rotation.x = -0.5;
                        group.add(ladder);
                    } else { // Tier 2: Large Granary Complex (Silos)
                        // 3 Round Silos instead of one house
                        const siloR = 0.25;
                        const siloH = 0.6;

                        const addSilo = (tx, tz) => {
                            const s = new THREE.Group();
                            s.position.set(tx, 0, tz);
                            // Body (White plaster)
                            s.add(createCyl(siloR, siloR, siloH, MATERIALS.wallWhite, 0, siloH / 2, 0));
                            // Base
                            s.add(createCyl(siloR + 0.02, siloR + 0.02, 0.1, MATERIALS.stone, 0, 0.05, 0));
                            // Roof (Conical Straw)
                            s.add(createCone(siloR + 0.1, 0.3, MATERIALS.roofStraw, 0, siloH + 0.15, 0));
                            group.add(s);
                        };

                        addSilo(-0.25, -0.2);
                        addSilo(0.25, -0.2);
                        addSilo(0, 0.3); // Back one

                        // Rice Bales (Tawara) scattered
                        const baleGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.25, 8);
                        const makeBale = (x, z) => {
                            const m = new THREE.Mesh(baleGeo, MATERIALS.roofStraw);
                            m.rotation.z = Math.PI / 2;
                            m.position.set(x, 0.125, z);
                            return m;
                        };
                        group.add(makeBale(0.3, 0.3));
                        group.add(makeBale(-0.3, 0.3));
                        if (tier >= 3) {
                            group.add(makeBale(0, -0.3));
                        }
                    }
                    break;

                case 'lumber_hub': // Êú®ÊùêÂä†Â∑•ÊâÄ -> Â§ßÂ∑• (Carpenter)
                    // Ground - minimal or wood shavings?
                    if (tier >= 2) group.add(createBox(1.0, 0.02, 1.0, MATERIALS.dirt, 0, 0.01, 0));

                    // Main Workshop area
                    // Main Workshop area
                    if (tier === 1) { // Workshop - Carpentry Shed
                        // 1. Simple Roof Structure (Distinguishes from Open Air Lumber Mill)
                        group.add(createPillar(0.7, -0.3, 0.3, -0.2));
                        group.add(createPillar(0.7, 0.3, 0.3, -0.2));
                        group.add(createPillar(0.7, -0.3, 0.3, 0.2));
                        group.add(createPillar(0.7, 0.3, 0.3, 0.2));
                        // Lattice Roof / Open Rafters
                        group.add(createBox(0.7, 0.05, 0.5, MATERIALS.wood, 0, 0.7, 0));

                        // 2. Workbench (Under roof)
                        group.add(createBox(0.4, 0.25, 0.2, MATERIALS.wood, 0, 0.125, -0.1)); // Bench
                        // Planer/Tools
                        group.add(createBox(0.05, 0.03, 0.08, MATERIALS.metal, 0, 0.26, -0.1));

                        // 3. Neat Stacks of Planks (Processed wood)
                        const plankL = 0.5;
                        const plankW = 0.3;
                        const stackH = 0.2;
                        // Stack 1
                        group.add(createBox(plankW, stackH, plankL, MATERIALS.wood, -0.2, stackH / 2, 0.2));
                        // Detail lines for planks
                        group.add(createBox(plankW + 0.01, 0.02, plankL, MATERIALS.woodDark, -0.2, 0.05, 0.2));
                        group.add(createBox(plankW + 0.01, 0.02, plankL, MATERIALS.woodDark, -0.2, 0.15, 0.2));

                    } else { // Carpenter - Large Shed (Roof, no walls)
                        // 4 Tall Pillars
                        const h = 0.9;
                        group.add(createPillar(h, -0.35, 0.45, -0.3));
                        group.add(createPillar(h, 0.35, 0.45, -0.3));
                        group.add(createPillar(h, -0.35, 0.45, 0.3));
                        group.add(createPillar(h, 0.35, 0.45, 0.3));

                        // Roof Area
                        group.add(createChineseRoof(0.9, 0.9, 0.3, MATERIALS.roofTileBlack, 0, h + 0.15, 0));

                        // Working area - Large Bench
                        group.add(createBox(0.6, 0.3, 0.3, MATERIALS.wood, 0, 0.15, 0));

                        // Lumber rack
                        group.add(createPillar(0.6, -0.3, 0.3, -0.3)); // reuse pillar func for rack post
                        group.add(createPillar(0.6, 0.3, 0.3, -0.3));
                        group.add(createBox(0.7, 0.05, 0.2, MATERIALS.wood, 0, 0.4, -0.3));

                        // Spinning Saw
                        const saw = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.02, 16), MATERIALS.metal);
                        saw.rotation.x = Math.PI / 2;
                        saw.userData = { anim: 'spinX', speed: 0.4 };
                        const sawGroup = new THREE.Group();
                        sawGroup.position.set(0.2, 0.35, 0.1);
                        sawGroup.add(saw);
                        group.add(sawGroup);
                    }
                    // Logs
                    group.add(createCyl(0.1, 0.1, 0.5, MATERIALS.wood, 0.3, 0.05, -0.3, Math.PI / 2));
                    break;

                case 'stone_plant': // Áü≥ÊùêÂä†Â∑•ÊâÄ -> ÂüéÂ£ÅÂª∫Ë®≠ÁèæÂ†¥ (Wall Construction)
                    // Ground - stone dust
                    if (tier >= 2) group.add(createBox(1.0, 0.02, 1.0, MATERIALS.stone, 0, 0.01, 0));

                    if (tier === 1) { // Stone Yard (Processing)
                        // Paved Work Area
                        group.add(createBox(0.8, 0.05, 0.6, MATERIALS.stone, 0, 0.025, 0));

                        // 1. Large Worked Stone Block (Centerpiece)
                        group.add(createBox(0.3, 0.25, 0.3, MATERIALS.stoneWhite, 0, 0.15, 0));
                        // Chips around it
                        group.add(createCone(0.1, 0.05, MATERIALS.stoneWhite, 0.2, 0.05, 0.2));
                        group.add(createCone(0.08, 0.04, MATERIALS.stoneWhite, -0.2, 0.05, 0.15));

                        // 2. Simple Wooden Hoist (Crane)
                        const hoist = new THREE.Group();
                        hoist.position.set(-0.3, 0, -0.2);
                        // A-Frame legs
                        hoist.add(createCyl(0.04, 0.04, 0.8, MATERIALS.wood, 0, 0.4, 0.15, 0, 0, 0.3));
                        hoist.add(createCyl(0.04, 0.04, 0.8, MATERIALS.wood, 0, 0.4, -0.15, 0, 0, -0.3));
                        // Crossbar
                        hoist.add(createCyl(0.03, 0.03, 0.4, MATERIALS.wood, 0, 0.7, 0, Math.PI / 2));
                        // Rope
                        hoist.add(createCyl(0.01, 0.01, 0.5, MATERIALS.white, 0, 0.5, 0));
                        // Hook/Stone suspended?
                        hoist.add(createBox(0.15, 0.1, 0.15, MATERIALS.stone, 0, 0.3, 0));
                        group.add(hoist);

                        // 3. Chisel Bench
                        group.add(createBox(0.3, 0.05, 0.15, MATERIALS.wood, 0.3, 0.1, 0.3)); // Low Bench
                        group.add(createBox(0.02, 0.15, 0.02, MATERIALS.metal, 0.3, 0.2, 0.3)); // Chisel
                        group.add(createBox(0.05, 0.03, 0.1, MATERIALS.wood, 0.35, 0.14, 0.3)); // Mallet
                    } else { // Wall Construction Site
                        // A larger stone wall section (looks like a wall, not a building)
                        group.add(createBox(0.9, 0.6, 0.3, MATERIALS.stone, 0, 0.3, -0.2));
                        // Crenellations
                        group.add(createBox(0.2, 0.1, 0.3, MATERIALS.stone, -0.35, 0.65, -0.2));
                        group.add(createBox(0.2, 0.1, 0.3, MATERIALS.stone, 0, 0.65, -0.2));
                        group.add(createBox(0.2, 0.1, 0.3, MATERIALS.stone, 0.35, 0.65, -0.2));

                        // Wooden Scaffolding wrapping around
                        const scaffold = new THREE.Group();
                        scaffold.position.set(0, 0, 0.2);
                        scaffold.add(createCyl(0.04, 0.04, 0.8, MATERIALS.wood, -0.4, 0.4, 0));
                        scaffold.add(createCyl(0.04, 0.04, 0.8, MATERIALS.wood, 0.4, 0.4, 0));
                        scaffold.add(createBox(0.9, 0.05, 0.2, MATERIALS.wood, 0, 0.4, 0)); // Platform
                        group.add(scaffold);

                        // Crane lifting stone
                        const crane = new THREE.Group();
                        crane.position.set(0.3, 0, 0.3);
                        crane.add(createCyl(0.05, 0.05, 1.2, MATERIALS.wood, 0, 0.6, 0)); // Tall mast
                        crane.add(createBox(0.6, 0.05, 0.05, MATERIALS.wood, -0.2, 1.1, 0)); // Jib

                        const block = createBox(0.15, 0.15, 0.15, MATERIALS.stoneWhite, -0.5, 0.8, 0); // Suspended high
                        crane.add(block);
                        crane.userData = { anim: 'rotateY', speed: 0.005 };
                        group.add(crane);
                    }
                    break;
            }
            return group;
        }

        let _lastAnimTime = null; // For delta time calculation
        function animate3D() {
            requestAnimationFrame(animate3D);
            const time = Date.now() * 0.001;
            const dt = _lastAnimTime ? time - _lastAnimTime : 0.016; // Default to ~60fps
            _lastAnimTime = time;

            tileMeshes.forEach((t, i) => {
                t.particles.update();

                if (t.buildingGroup.visible) {
                    t.buildingGroup.traverse((obj) => {
                        if (obj.userData && obj.userData.anim) {
                            const data = obj.userData;
                            switch (data.anim) {
                                case 'sway':
                                    obj.rotation.z = Math.sin(time * data.speed + data.offset) * 0.1;
                                    break;
                                case 'rotateY':
                                    obj.rotation.y += data.speed;
                                    break;
                                case 'rotateZ':
                                    obj.rotation.z -= data.speed;
                                    break;
                                case 'spinX':
                                    obj.rotation.x += data.speed;
                                    break;
                                case 'blink':
                                    obj.visible = Math.sin(time * 10 * data.speed) > 0;
                                    break;
                                case 'bounceY':
                                    obj.position.y = 0.35 + Math.abs(Math.sin(time * 5)) * data.range;
                                    break;
                                case 'shuttleX':
                                    obj.position.x = Math.sin(time * data.speed * 20) * data.range;
                                    break;
                                case 'shuttleY':
                                    obj.position.y = Math.sin(time * data.speed * 20) * data.range;
                                    break;
                                case 'sawMove':
                                    obj.position.z = Math.sin(time * 5) * 0.15;
                                    break;
                                case 'hammer':
                                    const cycle = (time * 3) % Math.PI;
                                    obj.rotation.z = Math.PI / 4 + Math.sin(cycle) * Math.PI / 4;
                                    break;
                                case 'smoke':
                                    if (Math.random() < 0.05) {
                                    }
                                    break;
                                case 'hammerWork':
                                    obj.rotation.z = -Math.PI / 4 + Math.abs(Math.sin(time * 10)) * 1.5;
                                    break;
                            }
                        }
                    });
                }
            });

            pedestrians.forEach(p => {
                p.update();
                p.updateAnimation(dt); // Pass delta time for frame-rate independent animation
            });
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
            updateOverlayPositions();
        }

        function updateOverlayPositions() {
            if (!camera) return;
            const width = window.innerWidth;
            const height = window.innerHeight;
            const widthHalf = width / 2;
            const heightHalf = height / 2;

            tileMeshes.forEach((t, i) => {
                const pos = t.mesh.position.clone();

                // „Ç¢„Ç§„Ç≥„É≥È´ò„ÅïË™øÊï¥ÔºàÂúüÂè∞ÂâäÈô§„Å´‰º¥„ÅÑÂ∞ë„Åó‰∏ã„Åí„ÇãÔºâ
                if (gameState.tiles[i] && !gameState.tiles[i].unlocked) {
                    pos.y += 0.5;
                } else {
                    pos.y += 1.0;
                }

                pos.project(camera);

                const x = (pos.x * widthHalf) + widthHalf;
                const y = -(pos.y * heightHalf) + heightHalf;

                // ÁßªÂãï„É¢„Éº„Éâ‰∏≠„ÅÆ„Éè„Ç§„É©„Ç§„Éà
                if (moveMode.active) {
                    if (moveMode.sourceIndex === i) {
                        t.overlayEl.innerHTML = `<div style="background:rgba(231, 76, 60, 0.9); color:white; padding:5px 10px; border-radius:15px; font-weight:bold; font-size:0.8em; box-shadow:0 0 10px rgba(231, 76, 60, 0.5);">ÁßªÂãïÂÖÉ</div>`;
                        t.overlayEl.style.display = 'flex';
                    } else if (!t.overlayEl.innerHTML && t.mesh.visible && gameState.tiles[i].unlocked) {
                        // ‰Ωï„ÇÇ„Å™„ÅÑÂ†¥ÊâÄÔºàÁßªÂãïÂÖàÂÄôË£úÔºâ„Å´„Ç¨„Ç§„Éâ„ÇíË°®Á§∫„Åï„Åõ„Åü„ÅÑÂ†¥Âêà
                        // „Åì„Åì„Åß„ÅØ„Ç∑„É≥„Éó„É´„Å´„Åô„Çã„Åü„ÇÅ„ÄÅ„ÇΩ„Éº„ÇπÈÅ∏ÊäûÂæå„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑÔºà„ÇØ„É™„ÉÉ„ÇØ„ÅßÂèçÂøú„Åï„Åõ„ÇãÔºâ
                    }
                }

                if (x < -100 || x > width + 100 || y < -100 || y > height + 100) {
                    t.overlayEl.style.display = 'none';
                } else {
                    t.overlayEl.style.display = 'flex';
                    t.overlayEl.style.left = `${x}px`;
                    t.overlayEl.style.top = `${y}px`;
                }
            });
        }

        function sync3DState() {
            const reqRank = getRequiredRankForExpansion();

            gameState.tiles.forEach((tile, i) => {
                const tObj = tileMeshes[i];
                const mesh = tObj.mesh; // ÈÄèÊòé„Éí„ÉÉ„Éà„Éú„ÉÉ„ÇØ„Çπ
                const overlay = tObj.overlayEl;
                const ground = tObj.groundMesh;

                if (!tile.unlocked) {
                    // Êú™ÈñãÊãìÂú∞
                    ground.material = MATERIALS.grassLocked;
                    tObj.buildingGroup.visible = true;
                    tObj.particles.active = false;

                    const stateKey = `wild`;
                    if (tObj.currentType !== stateKey) {
                        while (tObj.buildingGroup.children.length > 0) {
                            tObj.buildingGroup.remove(tObj.buildingGroup.children[0]);
                        }
                        const newModel = createBuildingMesh('wild', 0);
                        tObj.buildingGroup.add(newModel);
                        tObj.currentType = stateKey;
                    }

                    const canUnlock = gameState.rank >= reqRank;
                    if (canUnlock) {
                        overlay.innerHTML = `<div class="lock-icon">üîí</div>`;
                    } else {
                        overlay.innerHTML = "";
                    }
                } else {
                    // ÈñãÊãìÂú∞ÔºàÁü≥Áï≥Ôºâ
                    ground.material = MATERIALS.cobblestone;

                    if (tile.type) {
                        tObj.buildingGroup.visible = true;
                        const isBuilding = !!tile.finishTime;
                        const stateKey = `${tile.type}_${tile.level}_${isBuilding ? 'b' : ''}`;
                        if (tObj.currentType !== stateKey) {
                            while (tObj.buildingGroup.children.length > 0) {
                                tObj.buildingGroup.remove(tObj.buildingGroup.children[0]);
                            }

                            // Lv0(Êñ∞Ë¶è)„Å™„ÇâÂª∫Áâ©„Å™„Åó„ÄÅLv1‰ª•‰∏ä„Å™„Çâ„Åù„ÅÆ„É¨„Éô„É´„ÅÆÂª∫Áâ©„ÇíË°®Á§∫
                            if (tile.level > 0) {
                                const newModel = createBuildingMesh(tile.type, tile.level);
                                tObj.buildingGroup.add(newModel);
                            }

                            // Â∑•‰∫ã‰∏≠„Å™„Çâ„Ç∑„Éº„Éà„Å®‰ΩúÊ•≠Âì°„ÇíËøΩÂä†
                            if (isBuilding) {
                                const construction = createConstructionSite(tile.type);
                                tObj.buildingGroup.add(construction);
                            }

                            tObj.currentType = stateKey;
                        }

                        // ÂõûËª¢„ÅÆÈÅ©Áî® (0, 1, 2, 3 -> 0, -90, -180, -270)
                        if (tile.rotation) {
                            tObj.buildingGroup.rotation.y = -Math.PI / 2 * tile.rotation;
                        } else {
                            tObj.buildingGroup.rotation.y = 0;
                        }

                        if (tile.finishTime) {
                            tObj.particles.active = true;
                            const remaining = Math.max(0, (tile.finishTime - Date.now()));
                            const total = getBuildTime(tile.type, tile.level);
                            const percent = Math.min(100, Math.max(0, 100 - (remaining / total * 100)));

                            overlay.innerHTML = `
                            <div class="tile-timer">${formatTime(remaining / 1000)}</div>
                            <div class="progress-bar-container"><div class="progress-fill" style="width:${percent}%"></div></div>
                        `;
                        } else {
                            tObj.particles.active = false;

                            let content = "";
                            let hasResource = false;
                            let maxRes = ""; let maxVal = 0;
                            const canCollect = (Date.now() - (tile.lastCollectTime || 0)) >= CONFIG.collectCooldown;

                            if (tile.stored && canCollect) {
                                for (let r in tile.stored) {
                                    if (tile.stored[r] >= 1) {
                                        hasResource = true;
                                        if (tile.stored[r] > maxVal) { maxVal = tile.stored[r]; maxRes = r; }
                                    }
                                }
                            }
                            if (hasResource) {
                                const icon = (maxRes == 'money' ? 'üí∞' : maxRes == 'food' ? 'üåæ' : maxRes == 'wood' ? 'üå≤' : maxRes == 'stone' ? 'ü™®' : maxRes == 'iron' ? 'üî©' : 'üíß');
                                content = `<div class="harvest-bubble" onclick="collectResourceUI(${i}, event)">${icon}</div>`;
                            }
                            overlay.innerHTML = content;
                        }
                    } else {
                        tObj.buildingGroup.visible = false;
                        tObj.particles.active = false;
                        tObj.currentType = null;
                        overlay.innerHTML = "";
                    }
                }

                // ÈÅ∏ÊäûÊôÇ„ÅÆ„Éè„Ç§„É©„Ç§„Éà (Âú∞Èù¢„ÇíÂÖâ„Çâ„Åõ„Çã)
                let isHighlight = (selectedTileIndex === i) || (moveMode.active && moveMode.sourceIndex === i);

                if (isHighlight) {
                    // „Éû„ÉÜ„É™„Ç¢„É´„ÅåÂÖ±Êúâ„Åï„Çå„Å¶„ÅÑ„Çã„ÅÆ„Åß‰∏ÄÊôÇÁöÑ„Å´„ÇØ„É≠„Éº„É≥„Åó„Å¶ÂÖâ„Çâ„Åõ„Çã
                    // Ê≥®ÊÑè: „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ„ÅÆ„Åü„ÇÅ„Å´„ÅØÂà•ÈÄîSelectionBox„Çí‰Ωø„ÅÜ„ÅÆ„ÅåËâØ„ÅÑ„Åå„ÄÅÁ∞°ÊòìÂÆüË£Ö„Å®„Åó„Å¶
                    if (ground.material.uuid === MATERIALS.cobblestone.uuid || ground.material.uuid === MATERIALS.grassLocked.uuid) {
                        ground.material = ground.material.clone();
                    }
                    if (moveMode.active && moveMode.sourceIndex === i) {
                        ground.material.emissive.setHex(0xe74c3c); // Ëµ§„ÅèÂÖâ„Çâ„Åõ„ÇãÔºàÁßªÂãïÂÖÉÔºâ
                    } else {
                        ground.material.emissive.setHex(0x3498db); // Èùí„ÅèÂÖâ„Çâ„Åõ„ÇãÔºàÈÄöÂ∏∏ÈÅ∏ÊäûÔºâ
                    }
                    ground.material.emissiveIntensity = 0.4;
                } else {
                    // ÂÖâ„Å£„Å¶„ÅÑ„Å™„ÅÑÁä∂ÊÖã„Å´Êàª„ÅôÔºàÂÖ±Êúâ„Éû„ÉÜ„É™„Ç¢„É´„ÇíÂÜçÂâ≤„ÇäÂΩì„Å¶Ôºâ
                    if (tile.unlocked && ground.material.uuid !== MATERIALS.cobblestone.uuid) {
                        ground.material = MATERIALS.cobblestone;
                    } else if (!tile.unlocked && ground.material.uuid !== MATERIALS.grassLocked.uuid) {
                        ground.material = MATERIALS.grassLocked;
                    }
                }
            });
        }

        // --- Production Helper Functions ---
        function getGlobalBuffs() {
            let buffs = { speed: 1.0, bank: 1.0, granary: 1.0, lumber_hub: 1.0 };

            // Clocktower (Speed)
            gameState.tiles.forEach(t => {
                if (t.type === 'clocktower' && !t.finishTime && t.level > 0) {
                    buffs.speed += 0.02 + (t.level - 1) * 0.006;
                }
            });

            // Boosters (Bank, Granary, Lumber Hub)
            const calcBoost = (type) => {
                let add = 0;
                gameState.tiles.forEach(t => {
                    if (t.type === type && t.level > 0) {
                        add += 0.27 + (t.level * 0.03);
                    }
                });
                return 1.0 + add;
            };

            buffs.bank = calcBoost('bank');
            buffs.granary = calcBoost('granary');
            buffs.lumber_hub = calcBoost('lumber_hub');
            return buffs;
        }

        // Weighted Buffs for Offline: Accounts for buildings finishing mid-offline
        function getWeightedGlobalBuffs(totalSeconds, lastSaveTime, completionTimes) {
            let buffs = { speed: 1.0, bank: 1.0, granary: 1.0, lumber_hub: 1.0 };

            // Helper to integrate bonus over time
            const integrateBonus = (tile, idx, baseBonusPerLevel, levelScale) => {
                let duration = totalSeconds;

                // Check if it finished during this session
                const finishedAt = completionTimes ? completionTimes.get(idx) : null;

                if (finishedAt) {
                    // Finished during offline (Lv0 -> Lv1 or LvX -> LvX+1)
                    // Active at CURRENT level only for (Now - FinishedAt)
                    const finishDelay = (finishedAt - lastSaveTime) / 1000;
                    duration = totalSeconds - finishDelay;
                    if (duration < 0) duration = 0;
                } else if (tile.finishTime) {
                    // Still building (Future finish)
                    // Currently constructing -> Level 0 contribution (or Base level if upgrading)
                    // For Boosters: "level > 0".
                    // If upgrading Lv1->2, t.level is 1. Effective is 1. 
                    // Duration is Full.
                    // If New Build, t.level is 0. Effective is 0.
                    // So we just use Current Level * Full Duration.
                    duration = totalSeconds;
                }

                // If finishedAt existed: t.level is high level. We apply it for 'duration'.
                // The pre-finish time (low level) contribution is ignored here?
                // Example: Upgrading Lv1->2. 
                // Pre: Lv1. Post: Lv2.
                // This function currently only adds ONE term: (duration * CurrentLevelEffect).
                // We should add the Pre-term too.

                let bonus = 0;
                // Post-term (Current Level) - applies for 'duration'
                if (tile.level > 0) {
                    bonus += duration * (baseBonusPerLevel + tile.level * levelScale);
                }

                // Pre-term (Previous Level) - applies for (total - duration)
                // Only if it finished (was upgrading)
                if (finishedAt) {
                    const preDuration = totalSeconds - duration;
                    const preLevel = Math.max(0, tile.level - 1);
                    if (preLevel > 0) {
                        bonus += preDuration * (baseBonusPerLevel + preLevel * levelScale);
                    }
                }

                return bonus;
            };

            let totalSpeedBonusSeconds = 0;
            gameState.tiles.forEach((t, i) => {
                if (t.type === 'clocktower') { // Count even if level 0 if about to finish? integrate handles level check
                    totalSpeedBonusSeconds += integrateBonus(t, i, 0.014, 0.006); // 0.02 base = 0.014 + 0.006*1
                }
            });
            buffs.speed += (totalSpeedBonusSeconds / totalSeconds);

            const calcWeightedBoost = (type) => {
                let totalAddSeconds = 0;
                gameState.tiles.forEach((t, i) => {
                    if (t.type === type) {
                        totalAddSeconds += integrateBonus(t, i, 0.27, 0.03);
                    }
                });
                return 1.0 + (totalAddSeconds / totalSeconds);
            };

            buffs.bank = calcWeightedBoost('bank');
            buffs.granary = calcWeightedBoost('granary');
            buffs.lumber_hub = calcWeightedBoost('lumber_hub');

            return buffs;
        }

        function getTileProductionMultiplier(index, globalBuffs, isOffline = false, offlineCtx = null) {
            const tile = gameState.tiles[index];
            if (!tile || !tile.type || tile.level <= 0) return 0;

            const getWeightedLevel = (t, idx) => {
                if (!isOffline || !offlineCtx) return t.level;
                const { totalSeconds, lastSaveTime, completionTimes } = offlineCtx;

                let wL = t.level; // Current Level (High)

                const finishedAt = completionTimes ? completionTimes.get(idx) : null;
                if (finishedAt) {
                    // Weighted Average of (Level - 1) and (Level)
                    const finishDelay = (finishedAt - lastSaveTime) / 1000;
                    const durHigh = Math.max(0, totalSeconds - finishDelay);
                    const durLow = Math.max(0, totalSeconds - durHigh);

                    const lowL = Math.max(0, t.level - 1);
                    wL = (lowL * durLow + t.level * durHigh) / totalSeconds;
                }
                // If still building (finishTime exists), t.level is Base Level (Low). Correct.

                return wL;
            };

            const getActiveDurationRatio = (t, idx) => {
                if (!isOffline || !offlineCtx) {
                    return (t.level > 0 && !t.finishTime) ? 1.0 : 0.0;
                }
                const { totalSeconds, lastSaveTime, completionTimes } = offlineCtx;

                const finishedAt = completionTimes ? completionTimes.get(idx) : null;
                if (finishedAt) {
                    // Finished during offline.
                    // If it was Lv0 -> Lv1, active only after finish.
                    // If it was Lv X -> X+1, active whole time.
                    if (t.level === 1) {
                        const finishDelay = (finishedAt - lastSaveTime) / 1000;
                        const activeDur = Math.max(0, totalSeconds - finishDelay);
                        return activeDur / totalSeconds;
                    } else {
                        return 1.0;
                    }
                }

                if (t.finishTime) return 0.0; // Still building
                if (t.level > 0) return 1.0;  // Active whole time
                return 0.0;
            };

            let mult = globalBuffs.speed;

            // 1. Well -> Farm
            if (tile.type === 'farm') {
                const gridSize = gameState.gridSize;
                const checkOffsets = [-1, 1, -gridSize, gridSize];

                let maxAvgBonus = 0;

                checkOffsets.forEach(offset => {
                    const nIdx = index + offset;
                    // Check bounds (basic) - assuming valid grid linear logic (pseudo-valid)
                    // Better: check if nIdx is valid and adjacent in 2D
                    // But for now relying on checking gameState.tiles[nIdx] existence
                    if (gameState.tiles[nIdx]) {
                        const t = gameState.tiles[nIdx];
                        if (t && t.type === 'well') {
                            const wL = getWeightedLevel(t, nIdx);
                            if (wL > 0) {
                                const bonus = (wL < 1) ? wL * 0.3 : 0.3 + (wL - 1) * 0.03;
                                if (bonus > maxAvgBonus) maxAvgBonus = bonus;
                            }
                        }
                    }
                });

                if (maxAvgBonus > 0) mult *= (1 + maxAvgBonus);
            }

            // 2. Inn Condition
            if (tile.type === 'inn') {
                const gridSize = gameState.gridSize;
                const checkOffsets = [-1, 1, -gridSize, gridSize];

                let maxMarketRatio = 0.0;
                let maxHouseRatio = 0.0;

                checkOffsets.forEach(offset => {
                    const nIdx = index + offset;
                    if (gameState.tiles[nIdx]) {
                        const t = gameState.tiles[nIdx];
                        if (t) {
                            if (t.type === 'market') maxMarketRatio = Math.max(maxMarketRatio, getActiveDurationRatio(t, nIdx));
                            if (t.type === 'house') maxHouseRatio = Math.max(maxHouseRatio, getActiveDurationRatio(t, nIdx));
                        }
                    }
                });

                // Effective ratio is min of requirement existences
                const ratio = Math.min(maxMarketRatio, maxHouseRatio);
                if (ratio <= 0) return 0;
                mult *= ratio;
            }

            // 3. Forest Synergy
            if (tile.type === 'forest') {
                const gridSize = gameState.gridSize;
                const slaveOffset = (tile.rotation % 2 === 0) ? gridSize : 1;
                const slaveIdx = index + slaveOffset;

                const checkIdxs = new Set();
                [index, slaveIdx].forEach(center => {
                    [-1, 1, -gridSize, gridSize].forEach(offset => checkIdxs.add(center + offset));
                });

                let weightedCount = 0;
                checkIdxs.forEach(nIdx => {
                    const t = gameState.tiles[nIdx];
                    if (t && t.type === 'lumber') {
                        const wL = getWeightedLevel(t, nIdx);
                        weightedCount += Math.min(1, wL);
                    }
                });

                if (weightedCount > 0) {
                    mult *= (1 + 0.2 * weightedCount);
                }
            }

            return mult;
        }

        function gameLogicLoop() {
            const now = Date.now();
            let dirty = false;

            const globalBuffs = getGlobalBuffs();

            gameState.tiles.forEach((tile, i) => {
                if (tile.unlocked) {
                    if (tile.finishTime && now >= tile.finishTime) {
                        tile.level++;
                        tile.finishTime = null;
                        const xp = Math.floor(getBuildTime(tile.type, tile.level - 1) / 1000);
                        addXP(xp);
                        dirty = true;
                        if (selectedTileIndex !== null) updatePanelUI();
                    }

                    if (tile.type && tile.level > 0 && !tile.finishTime) {
                        const b = BUILDINGS[tile.type];
                        if (!b) return;

                        // Stone Processing Plant Logic
                        if (tile.type === 'stone_plant') {
                            if (tile.isActive) {
                                const costScale = tile.level * Math.pow(1.05, tile.level - 1);
                                const moneyCost = (b.consume.money || 0) * costScale;
                                const foodCost = (b.consume.food || 0) * costScale;
                                const woodCost = (b.consume.wood || 0) * costScale;

                                // Check Affordability
                                if (gameState.resources.money >= moneyCost &&
                                    gameState.resources.food >= foodCost &&
                                    gameState.resources.wood >= woodCost) {

                                    // Consume
                                    gameState.resources.money -= moneyCost;
                                    gameState.resources.food -= foodCost;
                                    gameState.resources.wood -= woodCost;

                                    // Produce Stone
                                    // Spec: 20 base * level logic
                                    const stoneProd = (b.prod.stone || 0) * tile.level * Math.pow(1.05, tile.level - 1);

                                    // Add Stone directly to GLOBAL resources (no storage limit mentioned for this converter, or use stored?)
                                    // "Produce stone" - typically goes to storage? 
                                    // Spec says "Converts resources... to produce stone".
                                    // Standard buildings use storage. Let's use storage to be consistent with harvest logic?
                                    // OR directly add to global because it consumes global?
                                    // Standard logic is: Produce -> Storage -> Manual Collect.
                                    // If it consumes AUTOMATICALLY from global, maybe it should produce to Storage.
                                    // Let's use Storage.

                                    const caps = getStorageCapacity(tile.type, tile.level, i);
                                    if (!tile.stored.stone) tile.stored.stone = 0;

                                    // If full, stop consuming? Or waste?
                                    // Let's stop if full to be kind.
                                    if (tile.stored.stone < caps.stone) {
                                        tile.stored.stone += stoneProd;
                                        if (tile.stored.stone > caps.stone) tile.stored.stone = caps.stone;
                                        dirty = true;
                                    }
                                } else {
                                    // Auto Turn Off
                                    tile.isActive = false;
                                    showToast(`‚ö†Ô∏è Á¥†Êùê‰∏çË∂≥„ÅÆ„Åü„ÇÅÁü≥ÊùêÂä†Â∑•Â†¥(Lv.${tile.level})„ÅåÂÅúÊ≠¢„Åó„Åæ„Åó„Åü`);
                                    dirty = true;
                                    if (selectedTileIndex === i) updatePanelUI();
                                }
                            }
                            return; // Skip standard logic for this special building
                        }

                        // Calculate efficiency
                        const efficiency = getTileProductionMultiplier(i, globalBuffs);

                        if (efficiency > 0) {
                            const caps = getStorageCapacity(tile.type, tile.level, i); // Pass index for adjacency
                            for (let r in b.prod) {
                                if (b.prod[r] > 0) {
                                    let finalMult = efficiency;

                                    if (r === 'money' && ['house', 'market', 'blacksmith', 'inn'].includes(tile.type)) finalMult *= globalBuffs.bank;
                                    if (r === 'food' && ['farm'].includes(tile.type)) finalMult *= globalBuffs.granary;
                                    if (r === 'wood' && ['lumber', 'forest'].includes(tile.type)) finalMult *= globalBuffs.lumber_hub;

                                    // Add to storage
                                    const amount = b.prod[r] * tile.level * Math.pow(1.05, tile.level - 1) * finalMult;

                                    // Update storage
                                    if (!tile.stored[r]) tile.stored[r] = 0;
                                    if (tile.stored[r] < caps[r]) {
                                        tile.stored[r] = Math.min(caps[r], tile.stored[r] + amount);
                                        if (Math.floor(tile.stored[r]) >= 1) dirty = true;
                                    }
                                }
                            }
                        }
                    }
                }
            });

            if (dirty) saveGame();
            sync3DState();
            updateHeader();
        }

        function onPointerDown(event) {
            pointerDownPos.set(event.clientX, event.clientY);
            lastPointerPos.set(event.clientX, event.clientY);
            isDragging = false;

            if (event.button === 0 || event.pointerType === 'touch') {
                isPanning = true;
            }
        }

        function onPointerMove(event) {
            if (!isDragging && (Math.abs(event.clientX - pointerDownPos.x) > 5 || Math.abs(event.clientY - pointerDownPos.y) > 5)) {
                isDragging = true;
            }
            if (isPanning) {
                const deltaX = event.clientX - lastPointerPos.x;
                const deltaY = event.clientY - lastPointerPos.y;
                lastPointerPos.set(event.clientX, event.clientY);

                if (touchStartDist > 0) return;

                moveCamera(deltaX, deltaY);
            }
        }

        function onPointerUp(event) {
            isPanning = false;

            if (isDragging) return;

            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const targetObjects = tileMeshes.map(t => t.mesh);
            const intersects = raycaster.intersectObjects(targetObjects, true);

            if (intersects.length > 0) {
                let target = intersects[0].object;
                while (target && target.userData.index === undefined && target.parent) {
                    target = target.parent;
                }

                if (target && target.userData.index !== undefined) {
                    const idx = target.userData.index;

                    // ÁßªÂãï„É¢„Éº„Éâ„ÅÆÂá¶ÁêÜ
                    if (moveMode.active) {
                        handleMoveInput(idx);
                        return;
                    }

                    const collected = collectResource(idx);
                    if (!collected) {
                        selectTile(idx);
                    }
                }
            } else {
                // ËÉåÊôØ„ÇØ„É™„ÉÉ„ÇØ„Å™„Å©„Åß„Éë„Éç„É´„ÇíÈñâ„Åò„ÇãÔºàÁßªÂãï„É¢„Éº„Éâ‰ª•Â§ñÔºâ
                if (!moveMode.active) {
                    closePanel();
                }
            }
        }

        // --- Move Mode Logic ---
        window.startMoveMode = function () {
            closeModal('modal-menu');
            closePanel();
            moveMode.active = true;
            moveMode.sourceIndex = null;

            document.getElementById('action-mode-bar').style.display = 'flex';
            document.getElementById('action-mode-text').innerText = "ÁßªÂãï„Åô„ÇãÊñΩË®≠„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ";

            sync3DState(); // „Éè„Ç§„É©„Ç§„ÉàËß£Èô§„Å™„Å©
        };

        window.actRotate = function () {
            if (moveMode.sourceIndex === null) return;
            const tile = gameState.tiles[moveMode.sourceIndex];
            if (!tile.rotation) tile.rotation = 0;
            tile.rotation = (tile.rotation + 1) % 4;
            sync3DState();
        };

        window.cancelMoveMode = function () {
            moveMode.active = false;
            moveMode.sourceIndex = null;
            document.getElementById('action-mode-bar').style.display = 'none';
            document.getElementById('action-rotate-btn').style.display = 'none'; // Hide rotate button
            sync3DState();
        };

        function handleMoveInput(index) {
            const tile = gameState.tiles[index];

            // Êú™ÈñãÊãìÂú∞„ÅØÂØæË±°Â§ñ
            if (!tile.unlocked) {
                showToast("Êú™ÈñãÊãìÂú∞„ÅØÊìç‰Ωú„Åß„Åç„Åæ„Åõ„Çì");
                return;
            }

            // Redirect slave to master
            if (tile.type && tile.type.endsWith('_part') && tile.masterIndex !== undefined) {
                handleMoveInput(tile.masterIndex);
                return;
            }

            if (moveMode.sourceIndex === null) {
                // „ÇΩ„Éº„ÇπÈÅ∏ÊäûÔºàÊñΩË®≠„Åå„ÅÇ„ÇãÂ†¥ÊâÄ„ÅÆ„ÅøÔºâ
                if (!tile.type && !tile.finishTime) {
                    showToast("ÁßªÂãï„Åï„Åõ„ÇãÊñΩË®≠„Åå„ÅÇ„Çä„Åæ„Åõ„Çì");
                    return;
                }

                // Prevent moving multi-tile
                const size = getBuildingSize(tile.type);
                // Note: getBuildingSize returns {w,h}. If simple building, returns {w:1,h:1}.
                // Forest returns {w:1,h:2} (static). But wait, existing building might be rotated?
                // getBuildingSize helper reads from BUILDINGS config, which is static.
                // It returns the base dimensions.
                // If w>1 or h>1, it's multi-tile.
                if (size.w > 1 || size.h > 1) {
                    showToast("Â§ßÂûãÊñΩË®≠„ÅØÁßªÂãï„Åß„Åç„Åæ„Åõ„Çì(Â£≤Âç¥‚ÜíÂª∫Áõ¥„ÅÆ„Åø)");
                    return;
                }

                moveMode.sourceIndex = index;
                document.getElementById('action-mode-text').innerText = "ÁßªÂãïÂÖà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ";
                document.getElementById('action-rotate-btn').style.display = 'block'; // Show rotate button
                sync3DState(); // „Éè„Ç§„É©„Ç§„ÉàÊõ¥Êñ∞
            } else {
                // „Çø„Éº„Ç≤„ÉÉ„ÉàÈÅ∏Êäû
                if (moveMode.sourceIndex === index) {
                    // Âêå„ÅòÂ†¥ÊâÄ„ÇíÈÅ∏Êäû -> „Ç≠„É£„É≥„Çª„É´ÔºàÈÅ∏ÊäûËß£Èô§Ôºâ
                    moveMode.sourceIndex = null;
                    document.getElementById('action-mode-text').innerText = "ÁßªÂãï„Åô„ÇãÊñΩË®≠„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ";
                    document.getElementById('action-rotate-btn').style.display = 'none'; // Hide rotate button
                    sync3DState();
                    return;
                }

                // „Çø„Éº„Ç≤„ÉÉ„ÉàÈÅ∏Êäû
                if (moveMode.sourceIndex === index) {
                    // Âêå„ÅòÂ†¥ÊâÄ„ÇíÈÅ∏Êäû -> „Ç≠„É£„É≥„Çª„É´ÔºàÈÅ∏ÊäûËß£Èô§Ôºâ
                    moveMode.sourceIndex = null;
                    document.getElementById('action-mode-text').innerText = "ÁßªÂãï„Åô„ÇãÊñΩË®≠„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ";
                    document.getElementById('action-rotate-btn').style.display = 'none'; // Hide rotate button
                    sync3DState();
                    return;
                }

                // ÁßªÂãïÂÆüË°å (Swap)
                swapTiles(moveMode.sourceIndex, index);

                // „É¢„Éº„ÉâÁµÇ‰∫Ü
                cancelMoveMode();
                showToast("ÊñΩË®≠„ÇíÁßªÂãï„Åó„Åæ„Åó„ÅüÔºÅ");
            }
        }

        function swapTiles(idx1, idx2) {
            const t1 = gameState.tiles[idx1];
            const t2 = gameState.tiles[idx2];

            // ÂúüÂú∞(unlocked)‰ª•Â§ñ„ÅÆÂª∫Áâ©„Éá„Éº„Çø„Çí‰∫§Êèõ
            const temp = {
                type: t1.type,
                level: t1.level,
                finishTime: t1.finishTime,
                stored: t1.stored,
                lastCollectTime: t1.lastCollectTime,
                rotation: t1.rotation || 0
            };

            // t1 <- t2
            t1.type = t2.type;
            t1.level = t2.level;
            t1.finishTime = t2.finishTime;
            t1.stored = t2.stored;
            t1.lastCollectTime = t2.lastCollectTime;
            t1.rotation = t2.rotation || 0;

            // t2 <- temp
            t2.type = temp.type;
            t2.level = temp.level;
            t2.finishTime = temp.finishTime;
            t2.stored = temp.stored;
            t2.lastCollectTime = temp.lastCollectTime;
            t2.rotation = temp.rotation;

            saveGame();
            sync3DState();
        }

        // „Ç≥„Çπ„ÉàË°®Á§∫Áî®„Éò„É´„Éë„ÉºÔºà‰∏çË∂≥ÂàÜ„ÇíËµ§Â≠ó„Å´„Åô„ÇãÔºâ
        function formatCostWithColor(cost) {
            let html = [];
            for (let r in cost) {
                if (cost[r] > 0) {
                    const val = cost[r];
                    const has = gameState.resources[r] || 0;
                    const icon = (r == 'money' ? 'üí∞' : r == 'food' ? 'üåæ' : r == 'wood' ? 'üå≤' : r == 'stone' ? 'ü™®' : r == 'iron' ? 'üî©' : 'üíß');

                    if (has < val) {
                        html.push(`<span style="color:red; font-weight:bold;">${icon}${val.toLocaleString()}</span>`);
                    } else {
                        html.push(`${icon}${val.toLocaleString()}`);
                    }
                }
            }
            return html.join(' ');
        }

        // ÊñΩË®≠ÂäπÊûú„ÅÆHTMLÁîüÊàêÔºàUtilityÊñΩË®≠ÂØæÂøúÔºâ
        function getBuildingEffectHtml(type, level, nextLevel = null) {
            const b = BUILDINGS[type];
            let html = "";

            // Helper to generate text for a single level
            const getEffectText = (lvl) => {
                if (lvl === 0) return "ÂäπÊûú„Å™„Åó";

                if (type === 'well') {
                    // Ê∞¥ÁîüÁî£ + Ëæ≤Â†¥„Éê„Éï
                    const buffVal = 1.3 + (lvl - 1) * 0.03;
                    let parts = [`Èö£Êé•Áïëx${buffVal.toFixed(2)}`];

                    // Ê∞¥ÁîüÁî£
                    if (b.prod.water) {
                        const waterVal = b.prod.water * lvl * Math.pow(1.05, lvl - 1);
                        parts.push(`üíß${waterVal.toFixed(1)}/s`);
                    }
                    return parts.join(' / ');
                } else if (type === 'clocktower') {
                    // 2.0 + (lvl-1)*0.1
                    const val = 2.0 + (lvl - 1) * 0.1;
                    return `ÂÖ®‰ΩìÈÄüÂ∫¶ +${val.toFixed(1)}%`;
                } else if (type === 'inn') {
                    // „ÅäÈáëÁîüÁî£ + Êù°‰ª∂
                    // const val = b.prod.money * lvl * Math.pow(1.05, lvl - 1);
                    // Inn„ÅÆË®àÁÆóÂºè: b.prod.money=60.
                    const val = 60 * lvl * Math.pow(1.05, lvl - 1);
                    return `üí∞${val.toFixed(1)}/s <span style="font-size:0.8em">(Ë¶Å:Â∏ÇÂ†¥&Ê∞ëÂÆ∂)</span>`;
                } else if (type === 'bank') {
                    // 1.27 + lvl * 0.03
                    const val = 1.27 + (lvl * 0.03);
                    return `ÈáëÁî£„ÉªÈáëË≤Ø x${val.toFixed(2)}`;
                } else if (type === 'granary') {
                    const val = 1.27 + (lvl * 0.03);
                    return `È£üÁî£„ÉªÈ£üË≤Ø x${val.toFixed(2)}`;
                } else if (type === 'lumber_hub') {
                    const val = 1.27 + (lvl * 0.03);
                    return `Êú®Áî£„ÉªÊú®Ë≤Ø x${val.toFixed(2)}`;
                } else {
                    // ‰∏ÄËà¨ÁîüÁî£ÊñΩË®≠
                    let parts = [];
                    for (let r in b.prod) {
                        if (b.prod[r] > 0) {
                            const val = b.prod[r] * lvl * Math.pow(1.05, lvl - 1);
                            const icon = (r == 'money' ? 'üí∞' : r == 'food' ? 'üåæ' : r == 'wood' ? 'üå≤' : r == 'stone' ? 'ü™®' : r == 'iron' ? 'üî©' : 'üíß');
                            parts.push(`${icon}${val.toFixed(1)}/s`);
                        }
                    }
                    return parts.length ? parts.join(' ') : 'ÂäπÊûú„Å™„Åó';
                }
            };

            const currText = getEffectText(level);

            if (nextLevel !== null) {
                const nextText = getEffectText(nextLevel);
                // Â§âÊõ¥ÈÉ®ÂàÜ„ÇíÂº∑Ë™ø
                // ÂçòÁ¥î„Å´ÊñáÂ≠óÂàóÂÖ®‰Ωì„ÇíÁü¢Âç∞„Åß„Å§„Å™„Åê (‰∫ïÊà∏„ÇÑÊôÇË®àÂ°î„ÅÆ„Çà„ÅÜ„Å´Êï∞ÂÄ§ÈÉ®ÂàÜ„Å†„Åë„ÅåÂ§â„Çè„ÇãÂ†¥Âêà„ÇÇÂê´„ÇÄ)

                // „Åü„Å†„Åó„ÄÅInn„ÇÑÈÄöÂ∏∏ÊñΩË®≠„ÅÆ„Çà„ÅÜ„Å´HTML„Çø„Ç∞„ÇíÂê´„ÇÄÂ†¥Âêà„ÅÆÊØîËºÉ„ÅØÂ∞ë„ÅóÂÜóÈï∑„Å´„Å™„Çã„Åå„ÄÅ„Ç∑„É≥„Éó„É´„Å´
                // "Current -> Next" „Å®„Åô„Çã
                return `<div>${currText} <span style="color:#2ecc71; font-weight:bold;">‚ûû ${nextText}</span></div>`;
            } else {
                return `<div>${currText}</div>`;
            }
        }

        function moveCamera(dx, dy) {
            if (!camera) return;

            const speed = 0.05 / camera.zoom;

            const vec = new THREE.Vector3();
            const quat = camera.quaternion.clone();

            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(quat);
            right.y = 0; right.normalize();

            const up = new THREE.Vector3(0, 1, 0).applyQuaternion(quat);
            up.y = 0; up.normalize();

            camera.position.addScaledVector(right, -dx * speed);
            camera.position.addScaledVector(up, dy * speed);
        }

        function setCameraZoom(val) {
            if (!camera) return;
            const minZoom = 0.5;
            const maxZoom = 2.5;
            camera.zoom = Math.max(minZoom, Math.min(maxZoom, val));
            camera.updateProjectionMatrix();
        }

        function onMouseWheel(event) {
            event.preventDefault();
            const zoomSpeed = 0.001;
            const newZoom = camera.zoom - event.deltaY * zoomSpeed;
            setCameraZoom(newZoom);
        }

        let touchStartDist = 0;
        let touchStartZoom = 1;

        function onTouchStart(event) {
            if (event.touches.length === 2) {
                isPanning = false;
                const dx = event.touches[0].pageX - event.touches[1].pageX;
                const dy = event.touches[0].pageY - event.touches[1].pageY;
                touchStartDist = Math.sqrt(dx * dx + dy * dy);
                touchStartZoom = camera.zoom;
            }
        }

        function onTouchMove(event) {
            if (event.target === renderer.domElement) {
                event.preventDefault();
            }

            if (event.touches.length === 2) {
                const dx = event.touches[0].pageX - event.touches[1].pageX;
                const dy = event.touches[0].pageY - event.touches[1].pageY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (touchStartDist > 0) {
                    const scale = dist / touchStartDist;
                    setCameraZoom(touchStartZoom * scale);
                }
            }
        }

        function onTouchEnd(event) {
            if (event.touches.length < 2) {
                touchStartDist = 0;
            }
        }

        window.collectResourceUI = function (index, e) {
            // ÁßªÂãï„É¢„Éº„Éâ‰∏≠„ÅØË≥áÊ∫êÂõûÂèéUI„ÇíÁÑ°ÂäπÂåñÔºàË™§„Çø„ÉÉ„ÉóÈò≤Ê≠¢Ôºâ
            if (moveMode.active) return;

            e.stopPropagation();
            collectResource(index);
        };

        function selectTile(index) {
            const t = gameState.tiles[index];
            if (t && t.type && t.type.endsWith('_part') && t.masterIndex !== undefined) {
                selectTile(t.masterIndex);
                return;
            }
            selectedTileIndex = index;
            sync3DState();
            showPanel(index);
        }

        window.closePanel = function () {
            selectedTileIndex = null;
            document.getElementById('control-panel').classList.remove('active');
            SoundManager.playSE('cancel');
            sync3DState();
        };

        // Helper for Confirm Modal
        window.showConfirmModal = function (msg, onYes) {
            document.getElementById('modal-confirm-msg').innerText = msg;
            const yesBtn = document.getElementById('modal-confirm-yes');
            // Remove old listeners by cloning
            const newBtn = yesBtn.cloneNode(true);
            yesBtn.parentNode.replaceChild(newBtn, yesBtn);
            newBtn.addEventListener('click', () => {
                if (window.SoundManager) SoundManager.playSE('select');
                document.getElementById('modal-confirm').style.display = 'none';
                onYes();
            });
            document.getElementById('modal-confirm').style.display = 'flex';
            if (window.SoundManager) SoundManager.playSE('select');
        };

        window.closeModal = function (id) {
            SoundManager.playSE('cancel');
            document.getElementById(id).style.display = 'none';
        };

        function formatTimeShort(s) { if (s < 60) return `${Math.floor(s)}s`; if (s < 3600) return `${Math.floor(s / 60)}m`; return `${Math.floor(s / 3600)}h`; }
        function formatTime(s) {
            s = Math.floor(s);
            const d = Math.floor(s / 86400);
            const h = Math.floor((s % 86400) / 3600);
            const m = Math.floor((s % 3600) / 60);
            const sec = s % 60;

            if (d > 0) return `${d}Êó•${h}ÊôÇÈñì${m}ÂàÜ${sec}Áßí`;
            if (h > 0) return `${h}ÊôÇÈñì${m}ÂàÜ${sec}Áßí`;
            if (m > 0) return `${m}ÂàÜ${sec}Áßí`;
            return `${sec}Áßí`;
        }

        function getNextRankXP(r) {
            const base = r * 500;
            if (r >= 12) return base * 4 * 3;
            if (r >= 10) return base * 4;
            return base;
        }

        function getBuildTime(t, l) {
            const tl = l + 1; // Target Level
            const base = BUILDINGS[t].baseTime;

            // Optimization: If simple calculation is less than 1 day, use standard formula
            const simpleTime = base * Math.pow(tl, 2.8);
            if (simpleTime <= 86400000) {
                return Math.floor(simpleTime);
            }

            // Iterative calculation for longer times
            // 1Êó•„ÇíË∂Ö„Åà„Çã„Åæ„Åß„ÅØÈÄöÂ∏∏Âºè„ÄÅË∂Ö„Åà„Åü„ÇâÊàêÈï∑Áéá„ÇíÊúÄÂ§ß30%(1.3ÂÄç)„Å´Êäë„Åà„Çã
            let time = base;
            for (let i = 2; i <= tl; i++) {
                const polyRate = Math.pow(i / (i - 1), 2.8);
                let rate = polyRate;

                if (time >= 172800000) { // 2 days
                    rate = Math.min(polyRate, 1.1); // Max 10%
                } else if (time >= 86400000) { // 1 day
                    rate = Math.min(polyRate, 1.3); // Max 30%
                }
                time = time * rate;
            }
            return Math.floor(time);
        }

        function getCost(t, l) {
            let m = Math.pow(1.6, l) * 1.5;
            if (l >= 10) m *= 10;
            const r = {};
            for (let k in BUILDINGS[t].cost) r[k] = Math.floor(BUILDINGS[t].cost[k] * m);
            return r;
        }

        function getStorageCapacity(t, l, tileIndex = -1, passedBuffs = null) {
            const b = BUILDINGS[t];
            const s = CONFIG.storageHours * 3600;
            const c = {};
            // Use passed (weighted) buffs if available, else static global
            const globalBuffs = passedBuffs || getGlobalBuffs();

            // Adjacency for Storage
            let adjacencyMult = 1.0;
            if (tileIndex >= 0) {
                if (t === 'farm') {
                    const adj = getAdjacentTiles(tileIndex);
                    const maxWell = adj.reduce((max, t) => (t && t.type === 'well' && t.level > 0 && !t.finishTime) ? Math.max(max, t.level) : max, 0);
                    if (maxWell > 0) adjacencyMult *= (1.3 + (maxWell - 1) * 0.03);
                } else if (t === 'lumber') {
                    const adj = getAdjacentTiles(tileIndex);
                    if (adj.some(t => t && t.type === 'forest')) adjacencyMult *= 1.2;
                }
            }

            for (let r in b.prod) {
                if (b.prod[r] > 0) {
                    let capMult = 1.0;
                    if (r === 'money' && ['house', 'market', 'blacksmith', 'inn'].includes(t)) capMult *= globalBuffs.bank;
                    if (r === 'food' && ['farm'].includes(t)) capMult *= globalBuffs.granary;
                    if (r === 'wood' && ['lumber', 'forest'].includes(t)) capMult *= globalBuffs.lumber_hub;

                    if (r === 'food') capMult *= adjacencyMult;
                    if (r === 'wood') capMult *= adjacencyMult;

                    c[r] = b.prod[r] * l * Math.pow(1.05, l - 1) * s * capMult;
                }
            }
            return c;
        }

        function getExpandCost(r) {
            const reqRank = getRequiredRankForExpansion();
            const virtualUnlockedCount = reqRank + 2;

            let b;
            const thresholdRank = 22;
            // virtualUnlockedCount = reqRank + 2
            // Threshold count = 24

            if (reqRank < thresholdRank) {
                b = 500 * Math.pow(1.5, virtualUnlockedCount - 4);
            } else {
                // Base at threshold (Rank 22 / Count 24) -> 1.5^20
                // Then grow by 1.3
                const baseAtThreshold = 500 * Math.pow(1.5, (thresholdRank + 2) - 4);
                b = baseAtThreshold * Math.pow(1.3, virtualUnlockedCount - (thresholdRank + 2));
            }

            if (reqRank >= 6) b *= 20;

            let cost = {
                money: Math.floor(b),
                food: Math.floor(b * 0.5),
                wood: Math.floor(b * 0.3),
                stone: Math.floor(b * 0.1),
                iron: 0
            };

            if (reqRank >= 12) {
                cost.money *= 20;
                cost.food *= 20;
                cost.wood *= 5;
                cost.stone *= 5;
            }

            return cost;
        }

        function getRequiredRankForExpansion() {
            const unlockedCount = gameState.tiles.filter(t => t.unlocked).length;
            const baseReq = Math.max(2, unlockedCount - 2);

            if (baseReq <= 10) {
                return baseReq;
            } else {
                return 10 + (baseReq - 10) * 2;
            }
        }

        function checkAfford(c) { for (let k in c) if ((gameState.resources[k] || 0) < c[k]) return false; return true; }
        function payCost(c) { for (let k in c) gameState.resources[k] -= c[k]; updateHeader(); }
        function getUnlockRank(type) {
            if (type === 'forest') return 20;
            if (type === 'bank') return 22;
            if (type === 'granary') return 24;
            if (type === 'lumber_hub') return 26;
            if (type === 'stone_plant') return 28;
            if (type === 'well') return 10;
            if (type === 'inn' || type === 'clocktower') return 15;
            return 1;
        }

        function addXP(a) {
            const oldRank = gameState.rank;
            gameState.xp += a;
            while (gameState.xp >= getNextRankXP(gameState.rank)) {
                gameState.xp -= getNextRankXP(gameState.rank);
                gameState.rank++;
            }

            if (gameState.rank > oldRank) {
                document.getElementById('levelup-rank').innerText = gameState.rank;
                document.getElementById('modal-levelup').style.display = 'flex';
                SoundManager.playSE('levelup');

                // Check for new unlocks
                let unlockedNames = [];
                for (let k in BUILDINGS) {
                    const r = getUnlockRank(k);
                    if (r > oldRank && r <= gameState.rank) {
                        unlockedNames.push(BUILDINGS[k].name);
                    }
                }
                if (unlockedNames.length > 0) {
                    showToast(`üéâ Êñ∞„Åó„ÅÑÊñΩË®≠„ÅåËß£Êîæ„Åï„Çå„Åæ„Åó„Åü: ${unlockedNames.join(', ')}`);
                }
            }
        }

        function getActiveBuilders() {
            return gameState.tiles.filter(t => t.finishTime !== null).length;
        }

        function getBuilderCost() {
            const current = gameState.maxBuilders;
            const target = current + 1;

            // 10‰∫∫ÁõÆ„Åæ„Åß„ÅØÈÄöÂ∏∏Ë®àÁÆó (20‰∏á * 1.5^(N-5))
            if (target <= 10) {
                const extra = Math.max(0, current - 4);
                return Math.floor(200000 * Math.pow(1.5, extra));
            }

            // 10‰∫∫ÁõÆ„ÅÆ„Ç≥„Çπ„ÉàÔºàÂü∫Ê∫ñÔºâ
            const cost10 = Math.floor(200000 * Math.pow(1.5, 5));

            // 11‰∫∫ÁõÆ„ÅØÂâçÂõû„ÅÆ100ÂÄç
            if (target === 11) {
                return cost10 * 100;
            }

            // 12‰∫∫ÁõÆ‰ª•Èôç„ÅØÂâçÂõû„ÅÆ3ÂÄç
            // C(N) = C(11) * 3^(N-11)
            const cost11 = cost10 * 100;
            return cost11 * Math.pow(3, target - 11);
        }

        function collectResource(index) {
            const t = gameState.tiles[index];
            if (!t || !t.stored) return false;

            const now = Date.now();
            if ((now - (t.lastCollectTime || 0)) < CONFIG.collectCooldown) {
                return false;
            }

            let total = 0, txt = "";
            for (let r in t.stored) {
                const val = Math.floor(t.stored[r]);
                if (val > 0) {
                    gameState.resources[r] += val;
                    t.stored[r] = 0;
                    total += val;
                    const icon = (r == 'money' ? 'üí∞' : r == 'food' ? 'üåæ' : r == 'wood' ? 'üå≤' : r == 'stone' ? 'ü™®' : r == 'iron' ? 'üî©' : 'üíß');
                    txt += `${icon}+${val} `;
                }
            }
            if (total > 0) {
                t.lastCollectTime = now;
                SoundManager.playSE('collect');
                saveGame(); // Âç≥Â∫ß„Å´‰øùÂ≠ò
                updateHeader();
                sync3DState();
                const overlay = tileMeshes[index].overlayEl;
                const el = document.createElement('div');
                el.className = 'float-text';
                el.innerText = txt;
                overlay.appendChild(el);
                setTimeout(() => el.remove(), 1000);
                return true;
            }
            return false;
        }

        function checkAndExpandWorld() {
            const allUnlocked = gameState.tiles.every(t => t.unlocked);
            if (allUnlocked) {
                expandWorldSize();
            }
        }

        function expandWorldSize() {
            const oldSize = gameState.gridSize;
            const newSize = oldSize + 1;
            const newTiles = [];

            for (let i = 0; i < newSize * newSize; i++) {
                const row = Math.floor(i / newSize);
                const col = i % newSize;

                if (row < oldSize && col < oldSize) {
                    const oldIdx = row * oldSize + col;
                    newTiles.push(gameState.tiles[oldIdx]);
                } else {
                    newTiles.push({
                        type: null, level: 0, finishTime: null,
                        unlocked: false,
                        stored: {},
                        lastCollectTime: 0
                    });
                }
            }

            gameState.tiles = newTiles;
            gameState.gridSize = newSize;

            remapMasterIndices(gameState.tiles, oldSize, newSize);
            sanitizeGameState(); // Ensure integrity

            createTiles();
            createSurroundingEnvironment(); // Áí∞Â¢ÉÂÜçÁîüÊàê
            showToast(`üéâ ‰∏ñÁïå„ÅåÂ∫É„Åå„Çä„Åæ„Åó„ÅüÔºÅ (${newSize}x${newSize})`);

            initPedestrians();
            saveGame();
        }

        function remapMasterIndices(tiles, oldSize, newSize) {
            // Re-calculate masterIndex for all slave tiles when grid resizes
            tiles.forEach(t => {
                if (t.type && t.type.endsWith('_part') && t.masterIndex !== undefined) {
                    const ox = t.masterIndex % oldSize;
                    const oy = Math.floor(t.masterIndex / oldSize);
                    const ni = oy * newSize + ox;
                    t.masterIndex = ni;
                }
            });
        }



        function validateAndFixState() {
            // Fix 1: Multi-tile integrity
            gameState.tiles.forEach((t, i) => {
                if (!t.type) {
                    // Ensure clean state if empty
                    if (t.masterIndex !== undefined) delete t.masterIndex;
                    if (t.mas) delete t.mas;
                    return;
                }

                if (t.type.endsWith('_part')) {
                    // Slave check
                    const mIdx = t.masterIndex;
                    const validMaster = mIdx !== undefined && gameState.tiles[mIdx];
                    if (!validMaster || !gameState.tiles[mIdx].type || !t.type.startsWith(gameState.tiles[mIdx].type)) {
                        console.warn("Found orphan slave part at", i, "cleaning...");
                        t.type = null;
                        t.level = 0;
                        t.finishTime = null;
                        delete t.masterIndex;
                    }
                } else if (t.mas) {
                    // Master check (optional: verify slaves exist?)
                    // For now, assume if slave is missing, it's just a visual/logic glitch but less critical 
                    // than slave pointing to wrong things.
                    // But we should verify.
                    // If we find a Master whose slaves are missing/wrong, strictly we should clear it or restore them.
                    // Let's clear to be safe against overlaps.
                    const size = getBuildingSize(t.type);
                    const rot = t.rotation || 0;
                    const w = (rot % 2 === 0) ? size.w : size.h;
                    const h = (rot % 2 === 0) ? size.h : size.w;
                    const origin = getGridPos(i);
                    let healthy = true;

                    for (let dy = 0; dy < h; dy++) {
                        for (let dx = 0; dx < w; dx++) {
                            if (dx === 0 && dy === 0) continue;
                            const sIdx = getIndexFromPos(origin.x + dx, origin.y + dy);
                            if (sIdx === -1) { healthy = false; break; }
                            const slave = gameState.tiles[sIdx];
                            if (!slave || slave.masterIndex !== i) { healthy = false; break; }
                        }
                    }
                    if (!healthy) {
                        console.warn("Found broken master at", i, "cleaning...");
                        // Can't use clearMultiTile safely here as it might recurse. Manual clear.
                        t.type = null;
                        t.level = 0;
                        t.finishTime = null;
                        delete t.mas;
                        // We don't chase slaves here, they will be caught by orphan check on next pass or if we run multiple passes.
                        // Better: Loop again? Or just let it slide for one frame. 
                        // To be safe, just invalidating Master turns it into a 'ghost' or 'orphan' scenario eventually fixed.
                        // But if we null the type, the visual won't render. Current orphan check handles slaves.
                    }
                }
            });
        }

        function showPanel(index) {
            const tile = gameState.tiles[index];
            const p = document.getElementById('control-panel');
            const content = document.getElementById('panel-content');
            SoundManager.playSE('select');
            p.classList.add('active');
            updatePanelUI();
        }

        function updatePanelUI() {
            if (selectedTileIndex === null) return;
            const tile = gameState.tiles[selectedTileIndex];
            const content = document.getElementById('panel-content');
            if (!content) return;

            if (!tile.unlocked) {
                const req = getRequiredRankForExpansion();
                const cost = getExpandCost(gameState.rank);
                const ok = gameState.rank >= req;
                const afford = checkAfford(cost);
                content.innerHTML = `
                <div style="text-align:center;">
                    <p><strong>Êú™ÈñãÊãì„ÅÆÂúüÂú∞</strong></p>
                    <div style="background:#eee; padding:10px; border-radius:5px; text-align:left; font-size:0.9em;">
                        Êù°‰ª∂: „É©„É≥„ÇØ${req} (${ok ? '‚úÖ' : '‚ùå'})<br>
                        Ë≤ªÁî®: ${formatCostWithColor(cost)}
                    </div>
                    <button class="action-btn" onclick="actExpand()" ${ok && afford ? '' : 'disabled'}>Êã°Âºµ</button>
                    ${!ok ? '<p style="color:red;font-size:0.8em">„É©„É≥„ÇØ‰∏çË∂≥</p>' : ''}
                </div>`;
                return;
            }

            if (!tile.type) {
                let html = "";
                if (getActiveBuilders() >= gameState.maxBuilders) {
                    html += `<div style="color:var(--danger-color); font-size:0.9em; font-weight:bold; margin-bottom:5px; text-align:center;">‚ö†Ô∏è Â∑•‰∫ã„Åå„ÅÑ„Å£„Å±„ÅÑ„Åß„ÅôÔºÅ</div>`;
                }

                if (gameState.inventory && gameState.inventory.length > 0) {
                    html += `<div class="inventory-section"><div class="inventory-title">üì¶ ‰øùÁÆ°Â∫´„Åã„ÇâÂÜçË®≠ÁΩÆ</div>`;
                    gameState.inventory.forEach((item, idx) => {
                        const b = BUILDINGS[item.type];
                        const timeSec = getBuildTime(item.type, item.level - 1) / 1000;
                        // Restoration is always allowed (already counted in limit)
                        const disabledAttr = '';
                        const warnText = '';

                        html += `
                        <div class="building-item" style="background:#fff8e1;">
                            <div class="building-info">
                                <strong>${b.icon} ${b.name} (Lv.${item.level}) ${warnText}</strong>
                                <span class="res-cost">‚è≥${formatTime(timeSec)}</span>
                            </div>
                            <button onclick="actRestore(${idx})" style="background-color:#f39c12;" ${disabledAttr}>ÈÖçÁΩÆ</button>
                        </div>
                    `;
                    });
                    html += `</div><div class="inventory-title" style="margin-top:10px;">‚ú® Êñ∞Ë¶èÂª∫Ë®≠</div>`;
                }

                for (let k in BUILDINGS) {
                    const b = BUILDINGS[k];
                    const c = getCost(k, 0);
                    const afford = checkAfford(c);
                    // Use helper for color check
                    const costStr = formatCostWithColor(c);

                    const canBuild = checkBuildingLimit(k);
                    const disabledAttr = (afford && canBuild) ? '' : 'disabled';

                    let limitNum = 4;
                    // Ê≠£Á¢∫„Å™Âà∂ÈôêÊï∞„ÇíË°®Á§∫„Åô„Çã„Åü„ÇÅ„ÅÆ„É≠„Ç∏„ÉÉ„ÇØ‰∏ÄËá¥
                    const kIdx = BUILDING_KEYS.indexOf(k);
                    if (['well', 'inn', 'clocktower', 'bank', 'granary', 'lumber_hub', 'stone_plant'].includes(k)) {
                        limitNum = 2;
                    } else if (kIdx >= LIMIT_START_INDEX) {
                        limitNum = 4;
                    } else {
                        limitNum = 999; // Âà∂Èôê„Å™„Åó
                    }

                    const limitText = canBuild ? '' : `<br><span style="color:red; font-size:0.8em;">‚ö†Ô∏è ‰∏äÈôê(${limitNum}„Å§)„Å´ÈÅî„Åó„Å¶„ÅÑ„Åæ„Åô</span>`;

                    html += `
                    <div class="building-item">
                        <div class="building-info">
                            <strong>${b.icon} ${b.name}</strong>
                            <p style="font-size:0.8em; color:#666; margin:2px 0;">${b.desc}</p>
                            <span class="res-cost">${costStr}</span>
                            <span class="res-cost">‚è≥${formatTime(getBuildTime(k, 0) / 1000)}</span>
                            ${limitText}
                        </div>
                        <button onclick="actBuild('${k}')" ${disabledAttr}>Âª∫Ë®≠</button>
                    </div>`;
                }
                content.innerHTML = html;
                return;
            }

            const b = BUILDINGS[tile.type];
            if (tile.finishTime) {
                const rem = Math.max(0, (tile.finishTime - Date.now()));

                const prodDiff = getBuildingEffectHtml(tile.type, tile.level, tile.level + 1);

                const c = getCost(tile.type, tile.level);
                let refund = [];
                for (let r in c) if (c[r] > 0) refund.push(`${(r == 'money' ? 'üí∞' : r == 'food' ? 'üåæ' : r == 'wood' ? 'üå≤' : r == 'stone' ? 'ü™®' : r == 'iron' ? 'üî©' : 'üíß')}${Math.floor(c[r] * 0.5).toLocaleString()}`);

                content.innerHTML = `
                <div style="text-align:center;">
                    <h3>${b.name} (Lv.${tile.level} ‚ûû ${tile.level + 1})</h3>
                    <div style="background:#f9f9f9; padding:5px; border-radius:5px; margin:5px 0; font-size:0.9em;">
                        <strong>Â∑•‰∫ãÂæå„ÅÆÊÄßËÉΩ:</strong>
                        ${prodDiff}
                    </div>
                    <div style="color:var(--accent-color); font-size:1.4em; font-weight:bold; margin:10px 0;">${formatTime(rem / 1000)}</div>
                    <p>Â∑•‰∫ã‰∏≠...</p>
                    <button class="action-btn store-btn" onclick="actStore()">üì¶ ÂõûÂèéÔºà‰øùÁÆ°Â∫´„Å∏Ôºâ</button>
                    <button class="action-btn" style="background-color:var(--danger-color); margin-top:5px;" onclick="actCancelBuild()">üö´ Â∑•‰∫ã‰∏≠Ê≠¢ (ËøîÈÇÑ: ${refund.join(' ')})</button>
                </div>`;
            } else {
                const next = tile.level + 1;
                const c = getCost(tile.type, tile.level);
                const afford = checkAfford(c);
                const caps = getStorageCapacity(tile.type, tile.level, selectedTileIndex);
                // Use helper for upgrade cost
                const costStr = formatCostWithColor(c);

                const prodInfo = getBuildingEffectHtml(tile.type, tile.level);

                let storeInfo = "";
                for (let r in b.prod) if (b.prod[r] > 0) {
                    storeInfo += `<div>${(r == 'money' ? 'üí∞' : r == 'food' ? 'üåæ' : r == 'wood' ? 'üå≤' : r == 'stone' ? 'ü™®' : r == 'iron' ? 'üî©' : 'üíß')} ${Math.floor(tile.stored[r])}/${Math.floor(caps[r])}</div>`;
                }

                // Consumption Info for Stone Plant
                let consumeInfo = "";
                if (tile.type === 'stone_plant') {
                    const costScale = tile.level * Math.pow(1.05, tile.level - 1);
                    const mCost = (b.consume.money || 0) * costScale;
                    const fCost = (b.consume.food || 0) * costScale;
                    const wCost = (b.consume.wood || 0) * costScale;
                    consumeInfo = `
                        <div style="border-top:1px dashed #ccc; margin-top:5px; padding-top:5px; font-size:0.9em;">
                            <strong>Ê∂àË≤ª„Ç≥„Çπ„Éà:</strong><br>
                            üí∞-${Math.floor(mCost)}/s üåæ-${Math.floor(fCost)}/s üå≤-${Math.floor(wCost)}/s
                        </div>
                    `;
                }

                const buildersBusy = getActiveBuilders() >= gameState.maxBuilders;

                // Special Actions (Toggle)
                let extraBtns = "";
                if (tile.type === 'stone_plant') {
                    const isActive = tile.isActive;
                    extraBtns += `
                        <button class="action-btn" onclick="actTogglePlant()" style="background-color:${isActive ? '#e74c3c' : '#2ecc71'}; margin-bottom:5px;">
                            ${isActive ? '‚è∏ ÂÅúÊ≠¢„Åô„Çã' : '‚ñ∂ Á®ºÂÉçÈñãÂßã'}
                        </button>
                    `;
                    if (isActive) {
                        consumeInfo += `<div style="color:#2ecc71; font-weight:bold; font-size:0.9em; margin-top:2px;">‚úÖ Á®ºÂÉç‰∏≠</div>`;
                    } else {
                        consumeInfo += `<div style="color:#95a5a6; font-weight:bold; font-size:0.9em; margin-top:2px;">‚èπ ÂÅúÊ≠¢‰∏≠</div>`;
                    }
                }

                content.innerHTML = `
                <div style="text-align:center;">
                    <h3>${b.name} (Lv.${tile.level})</h3>
                    <p style="font-size:0.85em; color:#666; margin:0 0 10px 0;">${b.desc}</p>
                    <div style="background:#f0f0f0; padding:5px; border-radius:5px; margin-bottom:5px;">
                        <strong>ÁèæÂú®ÊÄßËÉΩ:</strong><br>${prodInfo}
                        ${consumeInfo}
                    </div>
                    ${storeInfo ? `<div style="background:#e8f4f8; padding:5px; border-radius:5px; margin-bottom:10px;">
                        <strong>Ë≤ØËîµÂ∫´:</strong><br>${storeInfo}
                    </div>` : ''}
                    <div style="text-align:left; font-size:0.9em; margin-bottom:5px;">
                         <strong>LvUPË≤ªÁî®:</strong> ${costStr}<br>
                         <strong>ÊôÇÈñì:</strong> ${formatTime(getBuildTime(tile.type, tile.level) / 1000)}
                    </div>
                    ${buildersBusy ? '<p style="color:red; font-size:0.9em;">‚ö†Ô∏è Â∑•‰∫ãÊû†„Åå„ÅÑ„Å£„Å±„ÅÑ„Åß„Åô</p>' : ''}
                    ${extraBtns}
                    <button class="action-btn" onclick="actBuild('${tile.type}')" ${afford && !buildersBusy ? '' : 'disabled'}>„É¨„Éô„É´„Ç¢„ÉÉ„Éó</button>
                    <button class="action-btn store-btn" onclick="actStore()">üì¶ ÂõûÂèéÔºà‰øùÁÆ°Â∫´„Å∏Ôºâ</button>
                </div>`;
            }
        }

        // --- Multi-tile Helper Functions ---
        function getBuildingSize(type) {
            const b = BUILDINGS[type];
            return { w: b.w || 1, h: b.h || 1 };
        }

        function getGridPos(index) {
            const s = gameState.gridSize;
            return { x: index % s, y: Math.floor(index / s) };
        }

        function getIndexFromPos(x, y) {
            const s = gameState.gridSize;
            if (x < 0 || y < 0 || x >= s || y >= s) return -1;
            return y * s + x;
        }

        function checkPlacement(index, type, rot = 0) {
            const size = getBuildingSize(type);
            const w = (rot % 2 === 0) ? size.w : size.h;
            const h = (rot % 2 === 0) ? size.h : size.w;
            const origin = getGridPos(index);

            for (let dy = 0; dy < h; dy++) {
                for (let dx = 0; dx < w; dx++) {
                    const tx = origin.x + dx;
                    const ty = origin.y + dy;
                    const tidx = getIndexFromPos(tx, ty);
                    if (tidx === -1) return false; // Out of bounds

                    // Check occupancy
                    // Target tile (index) is assumed to be the one we clicked, so it's nominally "available" (checked by UI)
                    // But we must ensure other tiles are also available.
                    // Also, must ensure tiles are Unlocked.
                    const t = gameState.tiles[tidx];
                    if (!t.unlocked) return false;
                    if (t.type || t.finishTime) {
                        // If checking the origin tile itself, it's fine (we are building on it)
                        // But wait, if we are upgrading, this function is not called for size check usually.
                        // If new build, origin tile must be empty.
                        // The UI calls actBuild only on selectedTileIndex.
                        // We should ensure we don't overwrite existing stuff unless we mean to.
                        // For new build, all tiles must be empty.
                        return false;
                    }
                }
            }
            return true;
        }

        function setMultiTile(index, type, rot = 0) {
            const size = getBuildingSize(type);
            const w = (rot % 2 === 0) ? size.w : size.h;
            const h = (rot % 2 === 0) ? size.h : size.w;
            const origin = getGridPos(index);

            for (let dy = 0; dy < h; dy++) {
                for (let dx = 0; dx < w; dx++) {
                    const tidx = getIndexFromPos(origin.x + dx, origin.y + dy);
                    const t = gameState.tiles[tidx];
                    if (dx === 0 && dy === 0) {
                        // Master
                        t.type = type;
                        t.rotation = rot;
                        t.mas = true; // master flag
                    } else {
                        // Slave
                        t.type = type + '_part';
                        t.masterIndex = index;
                    }
                }
            }
        }

        function clearMultiTile(index) {
            const t = gameState.tiles[index];
            if (!t.type) return;

            // If slave, redirect to master
            if (t.type.endsWith('_part')) {
                // Should have been handled by caller, but safety check
                if (t.masterIndex !== undefined) clearMultiTile(t.masterIndex);
                return;
            }

            // Master: clear self and all parts
            // We need to know the size/rotation to find parts?
            // Or just scan? Scanning is slow.
            // Using currently stored rotation and type.
            const size = getBuildingSize(t.type);
            const rot = t.rotation || 0;
            const w = (rot % 2 === 0) ? size.w : size.h;
            const h = (rot % 2 === 0) ? size.h : size.w;
            const origin = getGridPos(index);

            for (let dy = 0; dy < h; dy++) {
                for (let dx = 0; dx < w; dx++) {
                    const tidx = getIndexFromPos(origin.x + dx, origin.y + dy);
                    if (tidx !== -1) {
                        const part = gameState.tiles[tidx];
                        part.type = null;
                        part.level = 0;
                        part.finishTime = null;
                        part.stored = {};
                        part.mas = undefined;
                        part.masterIndex = undefined;
                        part.rotation = 0;
                    }
                }
            }
        }

        window.actCancelBuild = function () {
            if (selectedTileIndex === null) return;
            const t = gameState.tiles[selectedTileIndex];
            if (!t.finishTime) return;

            showConfirmModal("Â∑•‰∫ã„Çí‰∏≠Ê≠¢„Åó„Åæ„Åô„ÅãÔºü\nË≤ªÁî®„ÅÆ‰∏ÄÈÉ®(50%)„ÅåËøîÈÇÑ„Åï„Çå„Åæ„Åô„ÄÇ", () => {
                const c = getCost(t.type, t.level);
                let refundTxt = "";
                for (let r in c) {
                    const amount = Math.floor(c[r] * 0.5);
                    if (amount > 0) {
                        gameState.resources[r] += amount;
                        const icon = (r == 'money' ? 'üí∞' : r == 'food' ? 'üåæ' : r == 'wood' ? 'üå≤' : r == 'stone' ? 'ü™®' : r == 'iron' ? 'üî©' : 'üíß');
                        refundTxt += `${icon}+${amount.toLocaleString()} `;
                    }
                }

                t.finishTime = null;
                if (t.level === 0) {
                    clearMultiTile(selectedTileIndex);
                }
                SoundManager.playSE('cancel');

                saveGame();
                sync3DState();
                updatePanelUI();
                updateHeader();
                showToast(`Â∑•‰∫ã„Çí‰∏≠Ê≠¢„Åó„Åæ„Åó„Åü ${refundTxt}`);
            });
        }

        window.actBuild = function (type) {
            if (selectedTileIndex === null) return;

            if (getActiveBuilders() >= gameState.maxBuilders) {
                showToast("‚ö†Ô∏è Â§ßÂ∑•„ÅåÂÖ®Âì°‰ΩúÊ•≠‰∏≠„Åß„Åô");
                return;
            }

            const t = gameState.tiles[selectedTileIndex];
            const lv = t.type === type ? t.level : 0;

            let targetIndex = selectedTileIndex;
            let detectedRotation = 0;

            if (lv === 0) {
                if (!checkBuildingLimit(type)) {
                    showToast("‚ö†Ô∏è „Åì„ÅÆÊñΩË®≠„ÅØ„Åì„Çå‰ª•‰∏äÂª∫Ë®≠„Åß„Åç„Åæ„Åõ„Çì");
                    return;
                }

                const reqRank = getUnlockRank(type);
                if (gameState.rank < reqRank) {
                    showToast(`‚ö†Ô∏è ${BUILDINGS[type].name}„ÅØ„É©„É≥„ÇØ${reqRank}„Åã„ÇâÂª∫Ë®≠ÂèØËÉΩ„Åß„Åô`);
                    return;
                }

                // Smart Placement Logic (Updated)
                // Priority:
                // 1. Closest to Origin (dx=0, dy=0) -> "Build starting here"
                // 2. Default Rotation (0) -> "Vertical/Standard"
                let placed = false;
                const size0 = getBuildingSize(type);

                // Allow rotation trial
                const allowedRotations = [0];
                if (size0.w !== size0.h) allowedRotations.push(1);

                // Generate all possible candidates: {r, dx, dy}
                let candidates = [];

                for (let r of allowedRotations) {
                    const w = (r % 2 === 0) ? size0.w : size0.h;
                    const h = (r % 2 === 0) ? size0.h : size0.w;

                    for (let dy = -(h - 1); dy <= 0; dy++) {
                        for (let dx = -(w - 1); dx <= 0; dx++) {
                            candidates.push({ r: r, dx: dx, dy: dy });
                        }
                    }
                }

                // Sort candidates
                candidates.sort((a, b) => {
                    const distA = Math.abs(a.dx) + Math.abs(a.dy);
                    const distB = Math.abs(b.dx) + Math.abs(b.dy);
                    if (distA !== distB) return distA - distB;
                    return a.r - b.r;
                });

                // Execute Search
                const origin = getGridPos(selectedTileIndex);

                for (let cand of candidates) {
                    const w = (cand.r % 2 === 0) ? size0.w : size0.h;
                    const h = (cand.r % 2 === 0) ? size0.h : size0.w;

                    const tx = origin.x + cand.dx;
                    const ty = origin.y + cand.dy;
                    const tidx = getIndexFromPos(tx, ty);

                    if (tidx !== -1 && checkPlacement(tidx, type, cand.r)) {
                        // Double check coverage
                        if (origin.x >= tx && origin.x < tx + w &&
                            origin.y >= ty && origin.y < ty + h) {

                            targetIndex = tidx;
                            detectedRotation = cand.r;
                            placed = true;
                            break;
                        }
                    }
                }

                if (!placed) {
                    showToast("‚ö†Ô∏è ÈÖçÁΩÆ„Åß„Åç„Åæ„Åõ„Çì(„Çπ„Éö„Éº„Çπ‰∏çË∂≥/ÈöúÂÆ≥Áâ©)");
                    return;
                }
            }

            const c = getCost(type, lv);
            if (checkAfford(c)) {
                payCost(c);

                if (lv === 0) {
                    setMultiTile(targetIndex, type, detectedRotation);
                    // Update UI focus to master
                    if (targetIndex !== selectedTileIndex) {
                        selectedTileIndex = targetIndex; // Update global selection
                    }
                }

                // Master tile properties
                const tMaster = gameState.tiles[targetIndex]; // Re-fetch in case changed
                tMaster.finishTime = Date.now() + getBuildTime(type, lv);
                tMaster.stored = {}; // Reset storage
                SoundManager.playSE('build');

                saveGame();
                sync3DState();

                // Refresh UI with new selection
                if (lv === 0 && targetIndex !== selectedTileIndex) {
                    showPanel(targetIndex);
                } else {
                    updatePanelUI();
                }
                updateHeader();
            }


        }

        window.actStore = function () {
            if (selectedTileIndex === null) return;
            const t = gameState.tiles[selectedTileIndex];
            if (!t.type) return;

            showConfirmModal("„Åì„ÅÆÊñΩË®≠„Çí‰øùÁÆ°Â∫´„Å´Êàª„Åó„Åæ„Åô„ÅãÔºü", () => {
                try {
                    collectResource(selectedTileIndex);
                    gameState.inventory.push({ type: t.type, level: t.level });
                    clearMultiTile(selectedTileIndex);

                    saveGame();
                    sync3DState();
                    updatePanelUI();
                    updateHeader();
                } catch (err) {
                    console.error("actStore Error", err);
                    showToast("‚ö†Ô∏è „Ç∑„Çπ„ÉÜ„É†„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü");
                }
            });
        };

        window.actRestore = function (invIndex) {
            console.log("actRestore called", invIndex);
            if (selectedTileIndex === null) return;

            if (getActiveBuilders() >= gameState.maxBuilders) {
                showToast("‚ö†Ô∏è Â§ßÂ∑•„ÅåÂÖ®Âì°‰ΩúÊ•≠‰∏≠„Åß„Åô");
                return;
            }

            if (invIndex < 0 || invIndex >= gameState.inventory.length) {
                showToast("‚ö†Ô∏è „Ç¢„Ç§„ÉÜ„É†„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì");
                return;
            }

            const item = gameState.inventory[invIndex];

            // Placement Check with Rotation
            let bestRot = -1;
            // Try all 4 rotations to find one that fits
            // Prefer 0 (default) -> 1 -> 2 -> 3
            for (let r = 0; r < 4; r++) {
                if (checkPlacement(selectedTileIndex, item.type, r)) {
                    bestRot = r;
                    break;
                }
            }

            if (bestRot === -1) {
                showToast("‚ö†Ô∏è „Åì„Åì„Å´„ÅØÈÖçÁΩÆ„Åß„Åç„Åæ„Åõ„Çì(„Çπ„Éö„Éº„Çπ‰∏çË∂≥/ÈöúÂÆ≥Áâ©)");
                return;
            }

            try {
                // Remove from inventory ONLY if valid
                gameState.inventory.splice(invIndex, 1);

                // Use setMultiTile with the found rotation
                setMultiTile(selectedTileIndex, item.type, bestRot);

                const tNew = gameState.tiles[selectedTileIndex];
                tNew.level = Math.max(0, item.level - 1);
                tNew.finishTime = Date.now() + getBuildTime(item.type, tNew.level);
                tNew.stored = {};

                SoundManager.playSE('build');
                saveGame();
                sync3DState();
                updatePanelUI();
                updateHeader();
                showToast("‰øùÁÆ°Â∫´„Åã„ÇâÈÖçÁΩÆ„Åó„Åæ„Åó„Åü");
            } catch (e) {
                console.error("actRestore Error", e);
                showToast("‚ö†Ô∏è „Ç∑„Çπ„ÉÜ„É†„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü");
                // On error, we technically lost the item since we spliced it. 
                // But in a real crash loop, it's safer to just log. 
                // Ideally we'd rollback splice, but we're inside the Try block that failed.
            }
        };


        function getAdjacentTiles(index) {
            const size = gameState.gridSize;
            const row = Math.floor(index / size);
            const col = index % size;
            const adj = [];

            // ‰∏ä‰∏ãÂ∑¶Âè≥
            if (row > 0) adj.push(gameState.tiles[(row - 1) * size + col]);
            if (row < size - 1) adj.push(gameState.tiles[(row + 1) * size + col]);
            if (col > 0) adj.push(gameState.tiles[row * size + col - 1]);
            if (col < size - 1) adj.push(gameState.tiles[row * size + col + 1]);

            return adj;
        }

        window.actTogglePlant = function () {
            if (selectedTileIndex === null) return;
            const tile = gameState.tiles[selectedTileIndex];
            if (tile.type !== 'stone_plant') return;

            tile.isActive = !tile.isActive;
            SoundManager.playSE('select');

            if (tile.isActive) showToast("üè≠ Á®ºÂÉç„ÇíÈñãÂßã„Åó„Åæ„Åó„Åü");
            else showToast("‚èπ ÂÅúÊ≠¢„Åó„Åæ„Åó„Åü");

            saveGame();
            updatePanelUI();
            // Optional: Update visual effects (smoke etc) -> sync3DState handled by next loop or manual call?
            // sync3DState logic for stone_plant effect is not yet implemented in 3D, but status is saved.
        };

        window.actExpand = function () {
            if (selectedTileIndex === null) return;
            const c = getExpandCost(gameState.rank);
            if (checkAfford(c)) {
                payCost(c);
                gameState.tiles[selectedTileIndex].unlocked = true;
                SoundManager.playSE('build'); // Land construction sound
                saveGame();

                checkAndExpandWorld();

                sync3DState();
                updatePanelUI();
            }
        }

        window.openMenu = function () {
            SoundManager.playSE('select');
            const modal = document.getElementById('modal-menu');
            const content = document.getElementById('menu-content');

            const builderCost = getBuilderCost();
            const canBuyBuilder = gameState.resources.money >= builderCost;
            const currentUid = currentUser ? currentUser.uid : "Êú™Êé•Á∂ö(„Ç™„Éï„É©„Ç§„É≥)";

            const sharedUid = localStorage.getItem('kingdomBuilder_sharedId');
            const displayUid = sharedUid ? `${sharedUid} (ÈÄ£Êê∫‰∏≠)` : currentUid;

            content.innerHTML = `
            <div class="shop-item">
                <button class="action-btn" onclick="openBuildingList()" style="width:100%; margin-bottom:10px; background-color:#3498db;">
                    üìã ÊñΩË®≠‰∏ÄË¶ß (ÊâÄÊúâ)
                </button>
                <button class="action-btn" onclick="showCurrentEffects()" style="width:100%; margin-bottom:10px; background-color:#1abc9c;">
                    üìä ÁèæÂú®„ÅÆÂäπÊûú
                </button>
                <button class="action-btn" onclick="openCatalog()" style="width:100%; margin-bottom:10px; background-color:#9b59b6;">
                    üìñ Âª∫Ë®≠„Ç´„Çø„É≠„Ç∞
                </button>
            </div>

            <div class="shop-item">
                <button class="action-btn" onclick="startMoveMode()" style="width:100%; margin-bottom:10px; background-color:#f39c12;">
                    üèóÔ∏è ÊñΩË®≠„ÇíÁßªÂãï
                </button>
            </div>

            <div class="shop-item">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <div>
                        <strong>üë∑ Â§ßÂ∑•„ÅÆÂ¢óÂì°</strong><br>
                        <span style="font-size:0.9em; color:#666;">ÁèæÂú®„ÅÆ‰∫∫Êï∞: ${gameState.maxBuilders}‰∫∫</span>
                    </div>
                    <div style="text-align:right;">
                        <span style="font-size:1.1em; font-weight:bold; color:#e67e22;">üí∞${builderCost.toLocaleString()}</span>
                    </div>
                </div>
                <button class="action-btn" onclick="actBuyBuilder()" ${canBuyBuilder ? '' : 'disabled'}>
                    Ë≥ºÂÖ•„Åô„Çã
                </button>
            </div>
            
            <div class="shop-item">
                <strong>üîÑ IDÈÄ£Êê∫ (ÂêåÊúü„Éó„É¨„Ç§)</strong>
                <p style="font-size:0.8em; color:#666; margin:5px 0;">
                    ÁèæÂú®„ÅÆID („Åì„ÅÆID„ÇíÂà•Á´ØÊú´„Å´ÂÖ•Âäõ):<br>
                    <input type="text" value="${sharedUid || currentUid}" readonly style="width:100%; padding:5px; background:#eee; border:1px solid #ddd; border-radius:4px;" onclick="this.select();document.execCommand('copy');showToast('ID„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü')">
                </p>
                <div style="margin-top:10px; border-top:1px dashed #ccc; padding-top:10px;">
                    <p style="font-size:0.8em; color:#666; margin:0 0 5px 0;">Âà•Á´ØÊú´„ÅÆID„ÇíÂÖ•Âäõ„Åó„Å¶ÈÄ£Êê∫:</p>
                    <div style="display:flex; gap:5px;">
                        <input type="text" id="restore-uid-input" placeholder="ÈÄ£Êê∫„Åô„ÇãID„ÇíÂÖ•Âäõ" style="flex:1; padding:5px; border:1px solid #ddd; border-radius:4px;">
                        <button onclick="actLinkID()" style="padding:5px 10px; font-size:0.9em;">ÈÄ£Êê∫</button>
                    </div>
                    ${sharedUid ? '<div style="margin-top:5px;"><button onclick="actUnlinkID()" style="width:100%; background-color:#e74c3c;">ÈÄ£Êê∫„ÇíËß£Èô§„Åô„Çã</button></div>' : ''}
                </div>
            </div>

            <div class="shop-item">
                <strong>‚öôÔ∏è Ë®≠ÂÆö</strong>
                <div style="margin-top:5px;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;">
                        <span>üéµ BGM</span>
                        <span id="label-bgm-vol">${Math.floor(SoundManager.config.bgmVolume * 100)}%</span>
                    </div>
                    <input type="range" min="0" max="100" value="${SoundManager.config.bgmVolume * 100}" 
                        style="width:100%"
                        oninput="let v = this.value / 100; SoundManager.setBGMVolume(v); document.getElementById('label-bgm-vol').innerText = this.value + '%';">
                </div>
                <div style="margin-top:10px;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;">
                        <span>üîä ÂäπÊûúÈü≥</span>
                        <span id="label-se-vol">${Math.floor(SoundManager.config.seVolume * 100)}%</span>
                    </div>
                    <input type="range" min="0" max="100" value="${SoundManager.config.seVolume * 100}" 
                        style="width:100%"
                        oninput="let v = this.value / 100; SoundManager.setSEVolume(v); document.getElementById('label-se-vol').innerText = this.value + '%';">
                </div>
            </div>

            <div class="shop-item">
                <strong>üìù „Ç≤„Éº„É†„Å´„Å§„ÅÑ„Å¶</strong>
                <p style="font-size:0.9em; color:#666;">
                    ÁèæÂú®„ÅÆ„Éû„ÉÉ„Éó„Çµ„Ç§„Ç∫: ${gameState.gridSize}x${gameState.gridSize}<br>
                    ÂÖ®„Å¶ÈñãÊãì„Åô„Çã„Å®‰∏ñÁïå„ÅåÂ∫É„Åå„Çä„Åæ„ÅôÔºÅ<br>
                    „Éá„Éº„Çø„ÅØ„ÇØ„É©„Ç¶„Éâ„Å´‰øùÂ≠ò„Åï„Çå„Å¶„ÅÑ„Åæ„Åô‚òÅÔ∏è
                </p>
            </div>
        `;

            modal.style.display = 'flex';
        };


        window.openCatalog = function () {
            SoundManager.playSE('select');
            closeModal('modal-menu');
            const modal = document.getElementById('modal-catalog');
            const content = document.getElementById('catalog-content');

            let html = '<div class="catalog-grid">';

            for (let k in BUILDINGS) {
                const b = BUILDINGS[k];
                const reqRank = getUnlockRank(k);
                const isLocked = gameState.rank < reqRank;

                if (isLocked) {
                    html += `
                        <div class="catalog-item" style="opacity:0.6; cursor:not-allowed;" onclick="showToast('‚ö†Ô∏è „É©„É≥„ÇØ${reqRank}„ÅßËß£Êîæ„Åï„Çå„Åæ„Åô')">
                            <div class="catalog-icon">üîí</div>
                            <div class="catalog-name">Rank ${reqRank}</div>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="catalog-item" onclick="showCatalogDetail('${k}')">
                            <div class="catalog-icon">${b.icon}</div>
                            <div class="catalog-name">${b.name}</div>
                        </div>
                    `;
                }
            }

            html += '</div>';
            html += `
                <div style="margin-top:15px; padding:10px; background:white; border-radius:8px; font-size:0.9em; color:#7f8c8d; text-align:center; border:1px dashed #ccc;">
                    ÊñΩË®≠„Ç¢„Ç§„Ç≥„É≥„Çí„Çø„ÉÉ„Éó„Åô„Çã„Å®<br>Ë©≥Á¥∞Ë™¨Êòé„ÇíÁ¢∫Ë™ç„Åß„Åç„Åæ„Åô
                </div>
            `;

            content.innerHTML = html;
            modal.style.display = 'flex';
        };

        window.showCatalogDetail = function (type) {
            SoundManager.playSE('select');
            const b = BUILDINGS[type];
            const content = document.getElementById('catalog-content');

            // Lv.1„Åß„ÅÆÂäπÊûú„ÇíË°®Á§∫
            const prodHtml = getBuildingEffectHtml(type, 1);

            const costStr = formatCostWithColor(b.cost);

            const typeIndex = BUILDING_KEYS.indexOf(type);
            const isStandardLimited = (typeIndex >= LIMIT_START_INDEX && typeIndex !== -1);
            const isSpecialLimited = ['well', 'inn', 'clocktower', 'bank', 'granary', 'lumber_hub', 'stone_plant'].includes(type);

            let limitStr = 'ÁÑ°Âà∂Èôê (ÂúüÂú∞‰æùÂ≠ò)';
            if (isSpecialLimited) limitStr = '2„Å§„Åæ„Åß';
            else if (isStandardLimited) limitStr = '4„Å§„Åæ„Åß';

            content.innerHTML = `
                <button class="back-btn" onclick="openCatalog()">
                    <span>‚óÄ</span> ‰∏ÄË¶ß„Å´Êàª„Çã
                </button>
                
                <div class="detail-header">
                    <div class="detail-icon">${b.icon}</div>
                    <div class="detail-title">
                        <h4>${b.name}</h4>
                        <span class="detail-category">Âª∫Ë®≠ÂèØËÉΩÊñΩË®≠</span>
                    </div>
                </div>
                
                <div class="detail-desc">
                    ${b.desc}
                    <div style="margin-top:10px; font-size:0.85em; color:#a1887f; border-top:1px solid #f9e79f; padding-top:5px;">
                        üí° „Éí„É≥„Éà: „É¨„Éô„É´„Ç¢„ÉÉ„Éó„ÅßÁîüÁî£Âäõ„ÅåÂ§ßÂπÖ„Å´Âêë‰∏ä„Åó„Åæ„Åô„ÄÇ
                    </div>
                </div>
                
                <div class="detail-stats-grid">
                    <div class="stat-card">
                        <span class="stat-label">ÁîüÁî£ËÉΩÂäõ / ÂäπÊûú (Lv.1)</span>
                        <div class="stat-content">
                            ${prodHtml}
                        </div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-label">Âª∫Ë®≠„Ç≥„Çπ„Éà</span>
                        <div class="stat-content">
                            ${costStr || 'ÁÑ°Êñô'}
                        </div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-label">Âü∫Êú¨Âª∫Ë®≠ÊôÇÈñì</span>
                        <div class="stat-content">
                            ‚è≥ ${formatTime(b.baseTime / 1000)}
                        </div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-label">ÊúÄÂ§ßË®≠ÁΩÆÊï∞</span>
                        <div class="stat-content">
                            ${limitStr}
                        </div>
                    </div>
                </div>
            `;
        };

        window.showCurrentEffects = function (includeConstruction = false) {
            closeModal('modal-menu');
            SoundManager.playSE('select');

            // Calculate stats
            const stats = {
                money: { prod: 0, mult: 1 },
                food: { prod: 0, mult: 1 },
                wood: { prod: 0, mult: 1 },
                stone: { prod: 0, mult: 1 },
                iron: { prod: 0, mult: 1 },
                water: { prod: 0, mult: 1 }
            };

            // Global Multipliers Calculation (Mirrors gameLogicLoop)
            const getBoost = (type) => {
                let add = 0;
                const targets = gameState.tiles.filter(t => {
                    if (t.type !== type) return false;
                    if (t.level > 0) return true; // Active or Upgrading
                    if (includeConstruction && t.finishTime) return true; // Under construction (New)
                    return false;
                });

                targets.forEach(t => {
                    let l = t.level;
                    if (includeConstruction && t.finishTime) {
                        l = (t.level === 0) ? 1 : t.level + 1;
                    } else if (l === 0) {
                        l = 1; // Fallback for safety if somehow logic slips, but usually filtered out
                    }
                    add += (0.27 + l * 0.03);
                });
                return 1.0 + add;
            };

            const bankMult = getBoost('bank');
            const granaryMult = getBoost('granary');
            const lumberMult = getBoost('lumber_hub');

            // Clocktower
            let globalSpeed = 1.0;
            const clocks = gameState.tiles.filter(t => {
                if (t.type !== 'clocktower') return false;
                // Real mode: Must NOT be constructing
                if (!includeConstruction && t.finishTime) return false;

                if (t.level > 0) return true;
                if (includeConstruction && t.finishTime) return true;
                return false;
            });
            clocks.forEach(t => {
                let l = t.level;
                if (includeConstruction && t.finishTime) {
                    l = (t.level === 0) ? 1 : t.level + 1;
                }
                if (l === 0) l = 1;
                globalSpeed += (0.02 + (l - 1) * 0.006);
            });


            // Iterate tiles for production
            gameState.tiles.forEach((tile, i) => {
                let isActive = false;
                let level = tile.level;

                if (tile.unlocked && tile.type) {
                    // Logic:
                    // 1. If includeConstruction is TRUE:
                    //    - Active if Level > 0 OR finishTime exists.
                    //    - Level is Target Level (Level+1).
                    // 2. If includeConstruction is FALSE:
                    //    - Active ONLY if Level > 0 AND !finishTime. (Production stops during upgrade).

                    if (includeConstruction) {
                        if (tile.level > 0 || tile.finishTime) {
                            isActive = true;
                            if (tile.finishTime) {
                                level = (tile.level === 0) ? 1 : tile.level + 1;
                            } else {
                                level = tile.level;
                            }
                        }
                    } else {
                        // Real Mode: No production if constructing/upgrading
                        if (tile.level > 0 && !tile.finishTime) {
                            isActive = true;
                            level = tile.level;
                        }
                    }
                }

                if (isActive) {
                    const b = BUILDINGS[tile.type];
                    if (!b) return;

                    let mult = globalSpeed;

                    // Adjacency Helpers
                    const countAdj = (type) => {
                        const adj = getAdjacentTiles(i);
                        // Filter logic similar to global boost
                        const valid = [...new Set(adj)].filter(t => {
                            if (!t || t.type !== type) return false;
                            if (t.level > 0) return true;
                            if (includeConstruction && t.finishTime) return true;
                            return false;
                        });
                        return valid;
                    };

                    const getMaxLvl = (list) => list.reduce((max, t) => {
                        let l = t.level;
                        if (includeConstruction && t.finishTime) l = (t.level === 0) ? 1 : t.level + 1;
                        if (l === 0) l = 1;
                        return Math.max(max, l);
                    }, 0);

                    // 1. Well -> Farm
                    if (tile.type === 'farm') {
                        const wells = countAdj('well');
                        const maxLvl = getMaxLvl(wells);
                        if (maxLvl > 0) mult *= (1 + 0.3 + (maxLvl - 1) * 0.03);
                    }

                    // 2. Inn -> Market/House (Assuming innate production always active if adjacent)
                    if (tile.type === 'inn') {
                        const markets = countAdj('market');
                        const houses = countAdj('house');
                        if (markets.length === 0 || houses.length === 0) mult = 0;
                    }

                    // 3. Forest -> Lumber
                    if (tile.type === 'forest') {
                        const adj = getAdjacentTiles(i);
                        const slaveOffset = (tile.rotation % 2 === 0) ? gameState.gridSize : 1;
                        const slaveIdx = i + slaveOffset;
                        if (gameState.tiles[slaveIdx] && gameState.tiles[slaveIdx].masterIndex === i) {
                            getAdjacentTiles(slaveIdx).forEach(t => adj.push(t));
                        }
                        const unique = [...new Set(adj)];
                        const lumbers = unique.filter(t => {
                            if (!t || t.type !== 'lumber') return false;
                            if (t.level > 0) return true;
                            // Feature request: "Count constructing Lumberjacks" logic should involve MAIN loop too
                            // This matches gameLogicLoop which now counts finishTime unconditionally.
                            if (t.finishTime) return true;
                            return false;
                        });
                        if (lumbers.length > 0) mult *= (1 + 0.2 * lumbers.length);
                    }

                    for (let r in b.prod) {
                        if (b.prod[r] > 0) {
                            let finalMult = mult;
                            if (r === 'money' && ['house', 'market', 'blacksmith', 'inn'].includes(tile.type)) finalMult *= bankMult;
                            if (r === 'food' && ['farm'].includes(tile.type)) finalMult *= granaryMult;
                            if (r === 'wood' && ['lumber', 'forest'].includes(tile.type)) finalMult *= lumberMult;

                            const rawAmount = b.prod[r] * level * Math.pow(1.05, level - 1);
                            const actualAmount = rawAmount * finalMult;

                            stats[r].prod += actualAmount;
                            if (!stats[r].base) stats[r].base = 0;
                            stats[r].base += rawAmount;
                        }
                    }

                    // Handles Consumption (e.g. Stone Plant)
                    if (b.consume && isActive) {
                        // Check if specific conditions met (e.g. stone_plant isActive flag)
                        // For stone_plant, it needs to be toggled ON
                        let isConsuming = true;
                        if (tile.type === 'stone_plant' && !tile.isActive) isConsuming = false;

                        if (isConsuming) {
                            const costScale = level * Math.pow(1.05, level - 1);
                            for (let r in b.consume) {
                                if (b.consume[r] > 0) {
                                    const amount = b.consume[r] * costScale;
                                    // Consumption is negative production
                                    if (!stats[r]) stats[r] = { prod: 0, mult: 1, base: 0 };
                                    stats[r].prod -= amount;
                                    // We don't touch 'base' or 'mult' for consumption typically, or maybe base negative?
                                    // Let's just affect the final prod total.
                                }
                            }
                        }
                    }
                }
            });

            // Build UI
            const modal = document.getElementById('modal-building-list');
            const content = document.getElementById('building-list-content');

            let html = `
                <div style="text-align:center; margin-bottom:15px;">
                    <h3>üìä ÁèæÂú®„ÅÆÂäπÊûú‰∏ÄË¶ß</h3>
                    <p style="font-size:0.9em; color:#666;">ÂÖ®ÊñΩË®≠„ÅÆÂêàË®àÁîüÁî£Âäõ„Å®ÈÅ©Áî®ÂÄçÁéá</p>
                    <button class="action-btn" onclick="showCurrentEffects(${!includeConstruction})" style="background-color:${includeConstruction ? '#e74c3c' : '#2ecc71'}; width:auto; padding:5px 15px; font-size:0.9em; margin-top:5px;">
                        ${includeConstruction ? 'Âª∫Ë®≠‰∏≠„ÇíÂê´„ÇÅ„Å™„ÅÑ' : 'Âª∫Ë®≠‰∏≠„ÇíÂê´„ÇÅ„Çã (ÊΩúÂú®ËÉΩÂäõ)'}
                    </button>
                    ${includeConstruction ? '<p style="color:#e67e22; font-size:0.8em; margin-top:2px;">‚ÄªÂª∫Ë®≠‰∏≠„ÅÆÊñΩË®≠„ÅåÂÆåÊàê„Åó„Åü„Å®‰ªÆÂÆö„Åó„ÅüÊï∞ÂÄ§„Åß„Åô</p>' : ''}
                </div>
                
                <table style="width:100%; border-collapse: collapse; font-size:0.95em;">
                    <tr style="background:#f0f0f0; border-bottom:2px solid #ddd;">
                        <th style="padding:8px; text-align:left;">Á¥†Êùê</th>
                        <th style="padding:8px; text-align:right;">ÂêàË®àÁîüÁî£/Áßí</th>
                        <th style="padding:8px; text-align:right;">ÂÄçÁéá</th>
                    </tr>
            `;

            const resKeys = ['money', 'food', 'wood', 'stone', 'iron', 'water'];
            const labels = { money: '„ÅäÈáë', food: 'È£üÊñô', wood: 'Êú®Êùê', stone: 'Áü≥Êùê', iron: 'ÈâÑ', water: 'Ê∞¥' };
            const icons = { money: 'üí∞', food: 'üåæ', wood: 'üå≤', stone: 'ü™®', iron: 'üî©', water: 'üíß' };

            resKeys.forEach(key => {
                const s = stats[key];
                // Show if producing (base > 0), consuming (prod < 0), or if it's money (always show)
                if (s.base > 0 || s.prod !== 0 || key === 'money') {
                    // Logic Change: Display effective GLOBAL multiplier, not average.
                    // For Money: globalSpeed * bankMult
                    // For Food: globalSpeed * granaryMult
                    // For Wood: globalSpeed * lumberMult
                    // For others: globalSpeed

                    let displayMult = globalSpeed;
                    if (key === 'money') displayMult *= bankMult;
                    if (key === 'food') displayMult *= granaryMult;
                    if (key === 'wood') displayMult *= lumberMult;

                    html += `
                        <tr style="border-bottom:1px solid #eee;">
                            <td style="padding:8px;">${icons[key]} ${labels[key]}</td>
                            <td style="padding:8px; text-align:right; font-weight:bold;">${s.prod.toFixed(1)}/s</td>
                            <td style="padding:8px; text-align:right; color:#2980b9;">x${displayMult.toFixed(2)}</td>
                        </tr>
                    `;
                }
            });

            html += `</table>
                <div style="margin-top:20px; text-align:center;">
                    <button onclick="openMenu()" style="padding:8px 20px; border:none; background:#eee; border-radius:5px;">Êàª„Çã</button>
                </div>
            `;

            content.innerHTML = html;
            document.getElementById('modal-building-list').style.display = 'flex';
        };

        window.openBuildingList = function () {
            SoundManager.playSE('select');
            closeModal('modal-menu');
            const modal = document.getElementById('modal-building-list');
            const content = document.getElementById('building-list-content');

            let html = '<div style="font-weight:bold; margin-bottom:5px; color:#2c3e50;">üåç „Éû„ÉÉ„Éó‰∏ä„ÅÆÊñΩË®≠</div>';

            let mapBuildings = [];
            gameState.tiles.forEach((t, i) => {
                if (t.type && !t.type.endsWith('_part')) {
                    mapBuildings.push({ tile: t, index: i });
                }
            });

            const getResScore = (type) => {
                const b = BUILDINGS[type];
                if (b.prod.money) return 1;
                if (b.prod.food) return 2;
                if (b.prod.wood) return 3;
                if (b.prod.stone) return 4;
                if (b.prod.iron) return 5;
                return 6;
            };
            const sortFn = (a, b) => {
                const typeA = a.tile ? a.tile.type : a.type;
                const lvlA = a.tile ? a.tile.level : a.level;
                const typeB = b.tile ? b.tile.type : b.type;
                const lvlB = b.tile ? b.tile.level : b.level;

                const sA = getResScore(typeA);
                const sB = getResScore(typeB);

                if (sA !== sB) return sA - sB;
                return lvlB - lvlA;
            };

            mapBuildings.sort(sortFn);

            if (mapBuildings.length === 0) {
                html += '<p style="color:#999; font-size:0.9em;">ÊñΩË®≠„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì</p>';
            } else {
                mapBuildings.forEach(item => {
                    const b = BUILDINGS[item.tile.type];
                    const level = item.tile.level;

                    const prodStr = getBuildingEffectHtml(item.tile.type, level);

                    html += `
                    <div class="building-item" style="background:white; margin-bottom:5px;">
                        <div class="building-info">
                            <strong>${b.icon} ${b.name} (Lv.${level})</strong>
                            <span style="font-size:0.8em; color:#666;">${prodStr}</span>
                        </div>
                        <button onclick="focusTile(${item.index})" style="padding:5px 10px; font-size:0.8em;">Ë©≥Á¥∞</button>
                    </div>
                `;
                });
            }

            html += '<div style="font-weight:bold; margin-top:15px; margin-bottom:5px; color:#7f8c8d; border-top:1px dashed #ccc; padding-top:10px;">üì¶ ‰øùÁÆ°Â∫´„ÅÆÊñΩË®≠</div>';

            if (gameState.inventory.length === 0) {
                html += '<p style="color:#999; font-size:0.9em;">‰øùÁÆ°Â∫´„ÅØÁ©∫„Åß„Åô</p>';
            } else {
                let sortedInv = [...gameState.inventory];
                sortedInv.sort(sortFn);

                sortedInv.forEach(item => {
                    const b = BUILDINGS[item.type];
                    // Inventory items also show effect
                    const prodStr = getBuildingEffectHtml(item.type, item.level);

                    html += `
                    <div class="building-item" style="background:#f5f5f5; color:#666;">
                        <div class="building-info">
                            <strong>${b.icon} ${b.name} (Lv.${item.level})</strong>
                            <span style="font-size:0.8em;">${prodStr}</span>
                        </div>
                        <span style="font-size:0.8em; background:#eee; padding:3px 6px; border-radius:4px;">‰øùÁÆ°‰∏≠</span>
                    </div>
                `;
                });
            }

            content.innerHTML = html;
            modal.style.display = 'flex';
        };

        window.focusTile = function (index) {
            closeModal('modal-building-list');
            selectTile(index);

            const tObj = tileMeshes[index];
            if (tObj && camera) {
                const targetX = tObj.mesh.position.x;
                const targetZ = tObj.mesh.position.z;

                camera.position.x = targetX + 20;
                camera.position.z = targetZ + 20;
                camera.updateProjectionMatrix();
            }
        };

        window.actLinkID = function () {
            SoundManager.playSE('select');
            const input = document.getElementById('restore-uid-input');
            const targetUid = input.value.trim();
            if (!targetUid) return showToast("‚ö†Ô∏è ID„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ");

            if (!confirm("‚ö†Ô∏è IDÈÄ£Êê∫„É¢„Éº„Éâ\n\nÂÖ•Âäõ„Åó„ÅüID„ÅÆ„Éá„Éº„Çø„Çí„ÄéÂÖ±Êúâ„Äè„Åó„Å¶„Éó„É¨„Ç§„Åó„Åæ„Åô„ÄÇ\nË§áÊï∞„ÅÆÁ´ØÊú´„ÅßÂêå„Åò„Éá„Éº„Çø„ÇíÂêåÊúü„Åß„Åç„Åæ„Åô„ÄÇ\n(‚ÄªFirebase„ÅÆ„É´„Éº„É´Ë®≠ÂÆö„ÅåÂøÖË¶Å„Åß„Åô)\n\nÂàá„ÇäÊõø„Åà„Åæ„Åô„ÅãÔºü")) return;

            localStorage.setItem('kingdomBuilder_sharedId', targetUid);
            location.reload();
        };

        window.actUnlinkID = function () {
            SoundManager.playSE('cancel');
            if (!confirm("ÈÄ£Êê∫„ÇíËß£Èô§„Åó„ÄÅÊú¨Êù•„ÅÆËá™ÂàÜ„ÅÆID„Å´Êàª„Çä„Åæ„Åô„ÅãÔºü")) return;
            localStorage.removeItem('kingdomBuilder_sharedId');
            location.reload();
        }

        window.actBuyBuilder = function () {
            const cost = getBuilderCost();
            if (gameState.resources.money >= cost) {
                gameState.resources.money -= cost;
                gameState.maxBuilders++;
                SoundManager.playSE('collect'); // Investment sound
                saveGame();
                updateHeader();
                openMenu();
            }
        };

        function updateHeader() {
            for (let k in gameState.resources) document.getElementById('display-' + k).innerText = Math.floor(gameState.resources[k]).toLocaleString();
            document.getElementById('display-rank').innerText = gameState.rank;
            document.getElementById('display-next-xp').innerText = (getNextRankXP(gameState.rank) - gameState.xp).toLocaleString();
            document.getElementById('display-xp-bar').style.width = Math.min(100, (gameState.xp / getNextRankXP(gameState.rank)) * 100) + '%';

            const active = getActiveBuilders();
            const max = gameState.maxBuilders;
            const builderEl = document.getElementById('display-builders');
            builderEl.innerText = `${active}/${max}`;
            builderEl.style.color = active >= max ? 'red' : '#2c3e50';
        }

        function onWindowResize() {
            const c = document.getElementById('game-container');
            if (!c) return;
            const width = c.clientWidth || window.innerWidth;
            const height = c.clientHeight || window.innerHeight;
            const aspect = width / height;
            const d = 10;

            if (camera && renderer) {
                camera.left = -d * aspect;
                camera.right = d * aspect;
                camera.top = d;
                camera.bottom = -d;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
        }

        function processOfflineProgress() {
            try {
                const now = Date.now();
                const totalOfflineSec = (now - gameState.lastSaveTime) / 1000;

                if (totalOfflineSec > 10) {
                    let rep = ""; let built = 0; let earn = {};
                    const completionTimes = new Map();

                    // 1. Event Pre-scan: Identify completions and update levels
                    gameState.tiles.forEach((t, i) => {
                        if (t.finishTime && t.finishTime <= now) {
                            completionTimes.set(i, t.finishTime);
                            t.level++;
                            t.finishTime = null;
                            built++;
                            gameState.xp += Math.floor(getBuildTime(t.type, t.level - 1) / 1000);
                        }
                    });

                    // 2. Calculate Weighted Global Buffs (using completion data)
                    const globalBuffs = getWeightedGlobalBuffs(totalOfflineSec, gameState.lastSaveTime, completionTimes);
                    const offlineCtx = { totalSeconds: totalOfflineSec, lastSaveTime: gameState.lastSaveTime, completionTimes };

                    // 3. Production Loop
                    gameState.tiles.forEach((t, i) => {
                        let activeSeconds = totalOfflineSec;
                        const finishedAt = completionTimes.get(i); // Check if this tile finished

                        if (finishedAt) {
                            // Finished during offline
                            const finishDelayV = (finishedAt - gameState.lastSaveTime) / 1000;
                            activeSeconds = totalOfflineSec - finishDelayV;
                            if (activeSeconds < 0) activeSeconds = 0;
                        } else if (t.finishTime) {
                            // Still building
                            activeSeconds = 0;
                        }

                        // Production Logic
                        if (t.type && t.level > 0 && !t.finishTime) {
                            const b = BUILDINGS[t.type];

                            // Stone Plant Offline Simulation
                            if (t.type === 'stone_plant') {
                                if (t.isActive) {
                                    const costScale = t.level * Math.pow(1.05, t.level - 1);
                                    // Base Cons: M:50, F:20, W:20
                                    const mCost = (b.consume.money || 0) * costScale;
                                    const fCost = (b.consume.food || 0) * costScale;
                                    const wCost = (b.consume.wood || 0) * costScale;

                                    // Max run time limited by resources
                                    let maxTime = activeSeconds;
                                    if (mCost > 0) maxTime = Math.min(maxTime, gameState.resources.money / mCost);
                                    if (fCost > 0) maxTime = Math.min(maxTime, gameState.resources.food / fCost);
                                    if (wCost > 0) maxTime = Math.min(maxTime, gameState.resources.wood / wCost);

                                    if (maxTime > 0) {
                                        // Consume
                                        gameState.resources.money -= mCost * maxTime;
                                        gameState.resources.food -= fCost * maxTime;
                                        gameState.resources.wood -= wCost * maxTime;

                                        // Produce Stone (4x spec = 20 base)
                                        const pVal = (b.prod.stone || 0) * t.level * Math.pow(1.05, t.level - 1);
                                        const prodTotal = pVal * maxTime;

                                        const caps = getStorageCapacity(t.type, t.level, i, globalBuffs);
                                        const current = t.stored.stone || 0;
                                        const space = Math.max(0, caps.stone - current);
                                        const actualAdd = Math.min(prodTotal, space);

                                        t.stored.stone = current + actualAdd;
                                        if (!earn.stone) earn.stone = 0;
                                        earn.stone += actualAdd;

                                        // If ran out of resources (or close enough), turn off
                                        if (maxTime < activeSeconds - 1) { // -1 tolerance
                                            t.isActive = false;
                                        }
                                    } else {
                                        t.isActive = false;
                                    }
                                }
                                return; // Skip standard building logic
                            }

                            // Use index 'i' for adjacency checks. Pass globalBuffs!
                            const caps = getStorageCapacity(t.type, t.level, i, globalBuffs);

                            // Check Efficiency
                            const efficiency = getTileProductionMultiplier(i, globalBuffs, true, offlineCtx); // Pass ctx

                            if (efficiency > 0 && activeSeconds > 0) {
                                for (let r in b.prod) if (b.prod[r] > 0) {
                                    if (!earn[r]) earn[r] = 0;

                                    let finalMult = efficiency;
                                    if (r === 'money' && ['house', 'market', 'blacksmith', 'inn'].includes(t.type)) finalMult *= globalBuffs.bank;
                                    if (r === 'food' && ['farm'].includes(t.type)) finalMult *= globalBuffs.granary;
                                    if (r === 'wood' && ['lumber', 'forest'].includes(t.type)) finalMult *= globalBuffs.lumber_hub;

                                    // Use activeSeconds for production duration
                                    const add = Math.min(caps[r] - (t.stored[r] || 0), b.prod[r] * t.level * Math.pow(1.05, t.level - 1) * finalMult * activeSeconds);
                                    if (add > 0) { t.stored[r] = (t.stored[r] || 0) + add; earn[r] += add; }
                                }
                            }
                        }
                    });
                    if (built > 0) rep += `<div>üèóÔ∏è ${built}‰ª∂ÂÆå‰∫Ü</div>`;
                    for (let r in earn) if (earn[r] > 1) rep += `<div>+${Math.floor(earn[r]).toLocaleString()} ${r}</div>`;
                    if (rep) { document.getElementById('offline-report').innerHTML = rep; document.getElementById('modal-offline').style.display = 'flex'; }
                    addXP(0); // „É©„É≥„ÇØ„Ç¢„ÉÉ„Éó„ÉÅ„Çß„ÉÉ„ÇØ
                    gameState.lastSaveTime = now;
                    saveGame(); // „Ç™„Éï„É©„Ç§„É≥ÁµåÈÅéÂàÜ„Çí‰øùÂ≠ò
                }
            } catch (e) {
                console.error(e);
            }
        }

    </script>
</body>

</html>
