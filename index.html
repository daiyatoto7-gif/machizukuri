<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kingdom Builder 3D (Visual Update)</title>

    <!-- „Éá„Éê„ÉÉ„Ç∞Áî®„Çπ„Çø„Ç§„É´ -->
    <style>
        #debug-log {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: auto;
            max-height: 100px;
            overflow-y: scroll;
            background: rgba(0, 0, 0, 0.7);
            color: lime;
            font-family: monospace;
            font-size: 10px;
            z-index: 9999;
            pointer-events: none;
            padding: 5px;
            box-sizing: border-box;
            display: none;
        }

        .error-msg {
            color: #ff5555;
        }
    </style>

    <!-- Three.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

    <style>
        :root {
            --bg-color: #f0f2f5;
            --panel-bg: #ffffff;
            --accent-color: #3498db;
            --text-color: #2c3e50;
            --xp-color: #f1c40f;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            overflow: hidden;
            user-select: none;
            height: 100vh;
            width: 100vw;
        }

        /* „Ç≠„É£„É≥„Éê„Çπ„ÅÆ„Çø„ÉÉ„ÉÅ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÁÑ°ÂäπÂåñ„Åó„Å¶„Éñ„É©„Ç¶„Ç∂„Çπ„ÇØ„É≠„Éº„É´„ÇíÈò≤„Åê */
        canvas {
            touch-action: none;
        }

        header {
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            padding: 5px 0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            position: fixed;
            top: 0;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }

        header>* {
            pointer-events: auto;
        }

        .status-bar {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .rank-badge {
            background: var(--accent-color);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.9em;
        }

        .xp-container {
            width: 150px;
            height: 10px;
            background: #eee;
            border-radius: 5px;
            overflow: hidden;
        }

        .xp-fill {
            height: 100%;
            background: var(--xp-color);
            width: 0%;
            transition: width 0.5s;
        }

        .resource-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 0.85em;
            justify-content: center;
            padding: 0 10px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
        }

        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
            /* ËÉåÊôØ„ÇíÁ©∫„Å®Âú∞Âπ≥Á∑ö„Çí„Ç§„É°„Éº„Ç∏„Åó„Åü„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„Å´Â§âÊõ¥ */
            background: linear-gradient(to bottom, #87CEEB 0%, #E0F7FA 60%, #A9DFBF 100%);
        }

        #ui-overlay-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            overflow: hidden;
        }

        .overlay-item {
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .tile-timer {
            font-size: 10px;
            font-weight: bold;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 2px 4px;
            border-radius: 4px;
            margin-bottom: 2px;
            white-space: nowrap;
        }

        .progress-bar-container {
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #2ecc71;
            width: 0%;
            transition: width 0.2s linear;
        }

        .harvest-bubble {
            background: white;
            border: 2px solid #f39c12;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            animation: bounce 1s infinite alternate;
            cursor: pointer;
        }

        @keyframes bounce {
            from {
                transform: translateY(0);
            }

            to {
                transform: translateY(-5px);
            }
        }

        .lock-icon {
            font-size: 24px;
            opacity: 0.6;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .float-text {
            position: absolute;
            color: #27ae60;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 0 #fff;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
            z-index: 100;
        }

        @keyframes floatUp {
            0% {
                transform: translate(-50%, -50%);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -150%);
                opacity: 0;
            }
        }

        #control-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            max-height: 40vh;
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            z-index: 30;
            display: none;
            flex-direction: column;
        }

        #control-panel.active {
            display: flex;
        }

        #panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--bg-color);
            padding-bottom: 10px;
            margin-bottom: 10px;
        }

        #panel-title {
            margin: 0;
            font-size: 1.1em;
            color: var(--accent-color);
        }

        /* Èñâ„Åò„Çã„Éú„Çø„É≥„ÅÆ„Çø„ÉÉ„ÉóÈ†òÂüü„ÇíÊã°Â§ß */
        .close-btn {
            cursor: pointer;
            font-weight: bold;
            padding: 10px 15px;
            color: #999;
            font-size: 1.2em;
            margin: -10px -10px -10px 0;
        }

        .close-btn:hover {
            color: #666;
        }

        #panel-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
        }

        .building-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #eee;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .building-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .res-cost {
            font-size: 0.85em;
            color: #666;
        }

        button {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            background-color: var(--accent-color);
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 0.9em;
        }

        button.action-btn {
            width: 100%;
            padding: 12px;
            font-size: 1em;
            margin-top: 5px;
        }

        button.store-btn {
            background-color: var(--text-color);
            margin-top: 10px;
        }

        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }

        .inventory-section {
            margin-top: 15px;
            border-top: 2px dashed #eee;
            padding-top: 10px;
        }

        .inventory-title {
            font-size: 0.9em;
            font-weight: bold;
            color: #7f8c8d;
            margin-bottom: 5px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* „É°„Éã„É•„Éº„Éú„Çø„É≥: Âõ∫ÂÆöÈÖçÁΩÆ (Âè≥‰∏ä„Å´Â§âÊõ¥) */
        #menu-btn {
            position: fixed;
            top: 15px;
            right: 15px;
            /* Âè≥ÂÅ¥„Å´ÈÖçÁΩÆ„Åó„Å¶„É©„É≥„ÇØË°®Á§∫„Å®Ë¢´„Çâ„Å™„ÅÑ„Çà„ÅÜ„Å´ */
            background: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            z-index: 50;
            pointer-events: auto;
        }

        #menu-btn:hover {
            background: #f0f0f0;
        }

        /* „É°„Éã„É•„Éº„Ç≥„É≥„ÉÜ„É≥„ÉÑ„Çπ„Çø„Ç§„É´ */
        .shop-item {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            text-align: left;
        }

        #toast-notification {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: bold;
            z-index: 100;
            display: none;
            pointer-events: none;
            animation: fadeInOut 3s forwards;
            white-space: nowrap;
        }

        @keyframes fadeInOut {
            0% {
                opacity: 0;
                top: 90px;
            }

            10% {
                opacity: 1;
                top: 80px;
            }

            90% {
                opacity: 1;
                top: 80px;
            }

            100% {
                opacity: 0;
                top: 70px;
            }
        }

        /* „Ç¢„ÇØ„Ç∑„Éß„É≥„É¢„Éº„Éâ„Éê„Éº (ÁßªÂãï„É¢„Éº„ÉâÁî®) */
        #action-mode-bar {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 25px;
            border-radius: 30px;
            z-index: 100;
            align-items: center;
            gap: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            width: max-content;
        }

        /* „É≠„Éº„ÉâÁîªÈù¢ */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #dcecf5 0%, #b0c4de 100%);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s;
        }

        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--accent-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* „Ç´„Çø„É≠„Ç∞Áî®„Çπ„Çø„Ç§„É´ */
        .catalog-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 12px;
            padding: 10px;
        }

        .catalog-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            padding: 15px 5px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .catalog-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border-color: var(--accent-color);
        }

        .catalog-icon {
            font-size: 2.5em;
            filter: drop-shadow(0 2px 2px rgba(0, 0, 0, 0.1));
        }

        .catalog-name {
            font-size: 0.85em;
            font-weight: bold;
            color: var(--text-color);
        }

        .catalog-detail {
            padding: 10px;
            animation: fadeIn 0.3s;
            text-align: left;
        }

        .detail-header {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
            border-bottom: 2px solid #f0f2f5;
            padding-bottom: 15px;
        }

        .detail-icon {
            font-size: 3.5em;
            background: white;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .detail-title h4 {
            margin: 0 0 5px 0;
            font-size: 1.4em;
            color: var(--accent-color);
        }

        .detail-category {
            font-size: 0.8em;
            color: #95a5a6;
            background: #f0f2f5;
            padding: 2px 8px;
            border-radius: 10px;
        }

        .detail-desc {
            background-color: #fff8e1;
            /* Ë™≠„Åø„ÇÑ„Åô„ÅÑ„ÇØ„É™„Éº„É†Ëâ≤ */
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            line-height: 1.8;
            font-size: 1em;
            color: #5d4037;
            border-left: 5px solid #f1c40f;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .detail-stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .stat-card {
            background: white;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #eee;
        }

        .stat-label {
            font-size: 0.75em;
            color: #7f8c8d;
            font-weight: bold;
            margin-bottom: 5px;
            display: block;
            text-transform: uppercase;
        }

        .stat-content {
            font-size: 0.95em;
            font-weight: bold;
            color: var(--text-color);
        }

        .back-btn {
            background: transparent;
            color: #7f8c8d;
            border: 1px solid #ccc;
            margin-bottom: 10px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .back-btn:hover {
            background: #f0f2f5;
        }
    </style>
</head>

<body>

    <div id="debug-log"></div>
    <div id="toast-notification"></div>

    <div id="loading-screen">
        <div class="loader"></div>
        <div id="loading-text" style="font-weight:bold; color:#2c3e50;">Connecting to Cloud...</div>
    </div>

    <div id="menu-btn" onclick="openMenu()">‚â°</div>

    <header>
        <div class="status-bar">
            <div class="rank-badge">RANK <span id="display-rank">1</span></div>
            <div class="xp-container">
                <div class="xp-fill" id="display-xp-bar"></div>
            </div>
            <div style="font-size:0.8em; color:#7f8c8d;">Next: <span id="display-next-xp">0</span> XP</div>
        </div>
        <div class="resource-bar">
            <div class="res-item">üí∞ <span id="display-money">0</span></div>
            <div class="res-item">üåæ <span id="display-food">0</span></div>
            <div class="res-item">üå≤ <span id="display-wood">0</span></div>
            <div class="res-item">ü™® <span id="display-stone">0</span></div>
            <div class="res-item">üî© <span id="display-iron">0</span></div>
            <div class="res-item">üíß <span id="display-water">0</span></div>
            <div class="res-item" style="border-left:1px solid #ddd; padding-left:10px; color:#e67e22;">üë∑ <span
                    id="display-builders">0/4</span></div>
        </div>
    </header>

    <div id="game-container"></div>
    <div id="ui-overlay-layer"></div>

    <div id="control-panel">
        <div id="panel-header">
            <h2 id="panel-title">„Çø„Ç§„É´ÈÅ∏Êäû</h2>
            <div class="close-btn" onclick="closePanel()">‚úï</div>
        </div>
        <div id="panel-content"></div>
    </div>

    <!-- ÁßªÂãï„É¢„Éº„ÉâÁî®„ÅÆ„Ç¨„Ç§„Éâ„Éê„Éº -->
    <div id="action-mode-bar">
        <span id="action-mode-text">ÁßªÂãï„Åô„ÇãÊñΩË®≠„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</span>
        <div style="display:flex; gap:10px;">
            <button id="action-rotate-btn" class="action-btn" onclick="actRotate()"
                style="background-color:#3498db; display:none; padding:5px 15px;">üîÑ ÂõûËª¢</button>
            <button class="action-btn" onclick="cancelMoveMode()"
                style="background-color:#e74c3c; padding:5px 15px;">ÁµÇ‰∫Ü</button>
        </div>
    </div>

    <div id="modal-offline" class="modal">
        <div class="modal-content">
            <h3>„Åä„Åã„Åà„Çä„Å™„Åï„ÅÑÔºÅ</h3>
            <p>‰∏çÂú®„ÅÆÈñì„Å´ÁîüÁî£„Åï„Çå„ÅüË≥áÊ∫ê„Åå<br>Ë≤ØËîµÂ∫´„Å´‰øùÁÆ°„Åï„Çå„Åæ„Åó„Åü„ÄÇ</p>
            <div style="text-align:left; background:#f9f9f9; padding:10px; border-radius:5px; margin:10px 0;">
                <div id="offline-report"></div>
            </div>
            <button onclick="closeModal('modal-offline')" class="action-btn">ÂÜçÈñã„Åô„Çã</button>
        </div>
    </div>

    <div id="modal-levelup" class="modal">
        <div class="modal-content">
            <h3 style="color:var(--accent-color);">üéâ „É©„É≥„ÇØ„Ç¢„ÉÉ„ÉóÔºÅ üéâ</h3>
            <p style="font-size:1.2em; font-weight:bold;">RANK <span id="levelup-rank"></span> „Å´„Å™„Çä„Åæ„Åó„ÅüÔºÅ</p>
            <button onclick="closeModal('modal-levelup')" class="action-btn">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <div id="modal-menu" class="modal">
        <div class="modal-content">
            <h3 style="margin-top:0;">„É°„Éã„É•„Éº</h3>
            <div id="menu-content" style="max-height:60vh; overflow-y:auto;"></div>
            <button onclick="closeModal('modal-menu')" class="action-btn"
                style="background-color:#95a5a6; margin-top:20px;">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <!-- ÊñΩË®≠‰∏ÄË¶ßÁî®„É¢„Éº„ÉÄ„É´ -->
    <div id="modal-building-list" class="modal">
        <div class="modal-content"
            style="max-width:500px; max-height:80vh; overflow:hidden; display:flex; flex-direction:column;">
            <h3 style="margin-top:0;">üìã ÊñΩË®≠‰∏ÄË¶ß</h3>
            <div id="building-list-content" style="flex:1; overflow-y:auto; text-align:left;"></div>
            <button onclick="closeModal('modal-building-list')" class="action-btn"
                style="background-color:#95a5a6; margin-top:10px;">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <div id="modal-catalog" class="modal">
        <div class="modal-content"
            style="max-width:500px; max-height:80vh; overflow:hidden; display:flex; flex-direction:column; background-color:#f8f9fa;">
            <h3 style="margin-top:0; color:#2c3e50;">üìñ Âª∫Ë®≠„Ç´„Çø„É≠„Ç∞</h3>
            <div id="catalog-content" style="flex:1; overflow-y:auto; text-align:left; padding:5px;"></div>
            <button onclick="closeModal('modal-catalog')" class="action-btn"
                style="background-color:#95a5a6; margin-top:10px;">Èñâ„Åò„Çã</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, doc, setDoc, getDoc, collection } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';

        // Global Firebase Variables
        let firebaseConfig;
        let appId;
        let offlineMode = false; // „ÇØ„É©„Ç¶„Éâ„Ç®„É©„ÉºÊôÇ„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Éï„É©„Ç∞

        // Áí∞Â¢ÉÂà§ÂÆö
        if (typeof __firebase_config !== 'undefined') {
            firebaseConfig = JSON.parse(__firebase_config);
            appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        } else {
            firebaseConfig = {
                apiKey: "AIzaSyBzJkeWGrzm5pFKAuX_Vkk-w1w4tsKHsDo",
                authDomain: "kingdom-builder-cdfb9.firebaseapp.com",
                projectId: "kingdom-builder-cdfb9",
                storageBucket: "kingdom-builder-cdfb9.firebasestorage.app",
                messagingSenderId: "672874506084",
                appId: "1:672874506084:web:573a57495e5a350d4fbc71",
                measurementId: "G-F6JMJJR146"
            };
            appId = firebaseConfig.projectId;
        }

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let currentUser = null;
        let userDocRef = null;
        let currentDocId = null;

        // --- Firebase Init ---
        async function initFirebase() {
            const loadingText = document.getElementById('loading-text');

            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Auth failed:", error);
                if (error.code === 'auth/requests-from-referer-blocked' || error.message.includes('referer')) {
                    console.warn("Domain restricted: Switching to Offline Mode.");
                    offlineMode = true;
                    loadingText.innerText = "Offline Mode (Cloud Disabled)";
                    setTimeout(loadGameFromCloud, 1000);
                    return;
                }
                try {
                    await signInAnonymously(auth);
                } catch (e) {
                    console.error("Retry Auth Failed, using offline", e);
                    offlineMode = true;
                    loadingText.innerText = "Offline Mode";
                    setTimeout(loadGameFromCloud, 1000);
                    return;
                }
            }

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUser = user;

                    const sharedId = localStorage.getItem('kingdomBuilder_sharedId');
                    if (sharedId) {
                        currentDocId = sharedId;
                        console.log("Using Shared ID:", currentDocId);
                    } else {
                        currentDocId = user.uid;
                    }

                    userDocRef = doc(db, 'artifacts', appId, 'users', currentDocId, 'gameData', 'saveSlot1');

                    loadingText.innerText = "Loading Kingdom...";
                    await loadGameFromCloud();
                }
            });
        }

        // --- Cloud Load & Save Logic ---
        async function loadGameFromCloud() {
            try {
                let data = null;
                let loadedFrom = "";

                if (!offlineMode && userDocRef) {
                    try {
                        const snap = await getDoc(userDocRef);
                        if (snap.exists()) {
                            data = snap.data();
                            loadedFrom = "Cloud";
                        }
                    } catch (e) {
                        console.warn("Cloud read failed, falling back to local:", e);
                    }
                }

                if (!data) {
                    const backup = localStorage.getItem('kingdomBuilderSave');
                    if (backup) {
                        try {
                            data = JSON.parse(backup);
                            loadedFrom = "Local Backup";
                        } catch (e) { }
                    }
                }

                if (!data) {
                    const legacyKeys = ['kingdomBuilderSave', 'kb_save_data', 'gameState'];
                    for (const key of legacyKeys) {
                        const localRaw = localStorage.getItem(key);
                        if (localRaw) {
                            try {
                                const localData = JSON.parse(localRaw);
                                if (localData && (localData.resources || localData.tiles)) {
                                    data = localData;
                                    loadedFrom = "Legacy Migration";
                                    showToast("üì¶ Âè§„ÅÑ„Éá„Éº„Çø„ÇíÂºï„ÅçÁ∂ô„Åé„Åæ„Åó„ÅüÔºÅ");
                                    break;
                                }
                            } catch (e) { }
                        }
                    }
                }

                if (data) {
                    gameState = { ...gameState, ...data };
                    processOfflineProgress();
                    console.log(`Loaded game from: ${loadedFrom}`);
                    saveGameToCloud(true);
                } else {
                    console.log("New User: Creating initial state.");
                    saveGameToCloud(true);
                }

            } catch (e) {
                console.error("Load failed:", e);
                showToast("„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü");
            }

            initGame();

            const loader = document.getElementById('loading-screen');
            if (loader) {
                loader.style.opacity = 0;
                setTimeout(() => loader.style.display = 'none', 500);
            }
        }

        async function saveGameToCloud(silent = false) {
            gameState.lastSaveTime = Date.now();

            try {
                const dataToSave = JSON.parse(JSON.stringify(gameState));
                localStorage.setItem('kingdomBuilderSave', JSON.stringify(dataToSave));

                if (!offlineMode && currentUser && userDocRef) {
                    await setDoc(userDocRef, dataToSave);
                    if (!silent) showToast("‚òÅÔ∏è ‰øùÂ≠ò„Åó„Åæ„Åó„Åü");
                } else {
                    if (!silent) showToast("üíæ ‰øùÂ≠ò„Åó„Åæ„Åó„Åü („Ç™„Éï„É©„Ç§„É≥)");
                }
            } catch (e) {
                console.error("Save failed:", e);
                if (!silent && !offlineMode) showToast("‚ö†Ô∏è „ÇØ„É©„Ç¶„Éâ‰øùÂ≠òÂ§±Êïó(„É≠„Éº„Ç´„É´„Å´‰øùÂ≠ò)");
            }
        }

        window.saveGame = saveGameToCloud;

        window.onload = function () {
            try {
                initFirebase();
            } catch (e) {
                console.error("Firebase init crash:", e);
                document.getElementById('loading-text').innerText = "Offline Mode";
                offlineMode = true;
                setTimeout(() => {
                    loadGameFromCloud();
                }, 1000);
            }
        };


        // --- Game Logic ---

        function log(msg, isError = false) {
            const el = document.getElementById('debug-log');
            if (!el) return;
            const line = document.createElement('div');
            line.textContent = `> ${msg}`;
            if (isError) {
                line.className = 'error-msg';
                el.style.display = 'block';
                console.error(msg);
            } else {
                console.log(msg);
            }
            el.appendChild(line);
            el.scrollTop = el.scrollHeight;
        }

        function showToast(msg) {
            const t = document.getElementById('toast-notification');
            t.innerText = msg;
            t.style.display = 'none';
            void t.offsetWidth; // trigger reflow
            t.style.display = 'block';
        }

        window.onerror = function (message, source, lineno, colno, error) {
            log(`Global Error: ${message} at line ${lineno}`, true);
            return false;
        };

        const CONFIG = {
            initialGridSize: 5,
            fps: 30,
            autoSaveInterval: 10000,
            initialUnlocked: [6, 7, 8, 11, 12, 13],
            storageHours: 8,
            collectCooldown: 30000,
            initialMaxBuilders: 4
        };

        const BUILDINGS = {
            house: { name: "Ê∞ëÂÆ∂", icon: "üè†", desc: "‰ΩèÊ∞ë„Åå‰Ωè„ÇÄÂÆ∂„ÄÇ„ÅäÈáë„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { money: 2 }, cost: { money: 20, food: 10 }, baseTime: 2000 },
            farm: { name: "Áïë", icon: "üåæ", desc: "‰ΩúÁâ©„ÇíËÇ≤„Å¶„Åæ„Åô„ÄÇÈ£üÊñô„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { food: 2 }, cost: { money: 30, wood: 10 }, baseTime: 2000 },
            lumber: { name: "‰ºêÊé°ÊâÄ", icon: "üå≤", desc: "Êú®„ÇíÂàá„ÇäÂá∫„Åó„Åæ„Åô„ÄÇÊú®Êùê„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { wood: 1 }, cost: { money: 50, food: 20 }, baseTime: 3000 },
            quarry: { name: "Êé°Áü≥Â†¥", icon: "ü™®", desc: "Áü≥„ÇíÂàá„ÇäÂá∫„Åó„Åæ„Åô„ÄÇÁü≥Êùê„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { stone: 1 }, cost: { money: 100, food: 50, wood: 50 }, baseTime: 4000 },
            mine: { name: "Èâ±Â±±", icon: "üî©", desc: "Âú∞‰∏ãË≥áÊ∫ê„ÇíÊéò„Çä„Åæ„Åô„ÄÇÈâÑ„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { iron: 1 }, cost: { money: 200, food: 100, wood: 100, stone: 50 }, baseTime: 5000 },
            market: { name: "Â∏ÇÂ†¥", icon: "‚öñÔ∏è", desc: "‰∫§Êòì„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇÂ§ßÈáè„ÅÆ„ÅäÈáë„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { money: 10 }, cost: { money: 500, food: 200, wood: 200, stone: 50 }, baseTime: 6000 },
            blacksmith: { name: "ÈçõÂÜ∂Â±ã", icon: "‚öîÔ∏è", desc: "Ê≠¶ÂÖ∑„Çí‰Ωú„Çä„Åæ„Åô„ÄÇ„ÅäÈáë„Å®ÈâÑ„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ", prod: { money: 5, iron: 2 }, cost: { money: 800, food: 300, wood: 300, stone: 200, iron: 100 }, baseTime: 7000 },

            // Êñ∞Ë¶èËøΩÂä†ÊñΩË®≠ („Ç≥„Çπ„Éà„ÅØÊ∞ëÂÆ∂Lv12Áõ∏ÂΩì x 10ÂÄç)
            well: {
                name: "‰∫ïÊà∏", icon: "üíß",
                desc: "„ÄêËæ≤Ê•≠ÊîØÊè¥„ÄëÊ∞¥„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇÈö£Êé•„Åô„Çã„ÄåÁïë„Äç„ÅÆÁîüÁî£ÂäπÁéá„Çí„Ç¢„ÉÉ„Éó„Åï„Åõ„Åæ„Åô(Lv1: 1.3ÂÄç)„ÄÇ",
                prod: { water: 5 },
                cost: { money: 30000, food: 10000, wood: 10000, stone: 5000, iron: 2000 },
                baseTime: 100000
            },
            inn: {
                name: "ÂÆøÂ±ã", icon: "üè®",
                desc: "„ÄêÂïÜÊ•≠„Éè„Éñ„Äë„ÄåÂ∏ÇÂ†¥„Äç„Å®„ÄåÊ∞ëÂÆ∂„Äç„ÅÆ‰∏°Êñπ„Å´Èö£Êé•„Åô„Çã„Å®Á®ºÂÉç„Åó„ÄÅÂ§öÈ°ç„ÅÆ„ÅäÈáë„ÇíÁîüÁî£„Åó„Åæ„Åô„ÄÇ",
                prod: { money: 60 }, // Êù°‰ª∂‰ªò„ÅçÈ´òÁîüÁî£ (‚ÄªÁîüÁî£Èáè„ÅØ„Åù„ÅÆ„Åæ„Åæ)
                cost: { money: 30000, food: 10000, wood: 10000, stone: 5000, iron: 2000 },
                baseTime: 120000
            },
            clocktower: {
                name: "ÊôÇË®àÂ°î", icon: "üï∞Ô∏è",
                desc: "„ÄêÂÖ®‰ΩìÂä†ÈÄü„ÄëË°ó„ÅÆ„Ç∑„É≥„Éú„É´„ÄÇÂÖ®ÊñΩË®≠„ÅÆÁîüÁî£ÈÄüÂ∫¶„Çí2%Âä†ÈÄü„Åó„Åæ„Åô(LvUP„Åß+0.1%)„ÄÇ",
                prod: {}, // Áõ¥Êé•ÁîüÁî£„Å™„Åó(ÂÖ®‰Ωì„Éê„Éï)
                cost: { money: 100000, food: 50000, wood: 50000, stone: 20000, iron: 10000 },
                baseTime: 200000
            },
            forest: {
                name: "Ê£ÆÊûó", icon: "üå≥",
                desc: "„ÄêÊûóÊ•≠„ÄëÂ∫ÉÂ§ß„Å™Ê£ÆÊûó„ÄÇ2„Éû„ÇπÂç†Êúâ(1x2)„ÄÇ‰ºêÊé°ÊâÄ„ÅåÈö£Êé•„Åô„Çã„Å®ÁîüÁî£Èáè+20%„ÄÇ",
                prod: { wood: 15 },
                cost: { money: 100000, food: 40000, wood: 10000, water: 10000 },
                baseTime: 300000,
                w: 1, h: 2 // 1x2 size
            }
        };

        const BUILDING_KEYS = Object.keys(BUILDINGS);
        const LIMIT_START_INDEX = BUILDING_KEYS.indexOf('market');

        function getBuildingCount(type) {
            const onMap = gameState.tiles.filter(t => t.type === type).length;
            const inInventory = gameState.inventory.filter(i => i.type === type).length;
            return onMap + inInventory;
        }

        function checkBuildingLimit(type) {
            // ÁâπÂà•Âà∂Èôê: ‰∫ïÊà∏„ÉªÂÆøÂ±ã„ÉªÊôÇË®àÂ°î„ÅØ2„Å§„Åæ„Åß
            if (['well', 'inn', 'clocktower'].includes(type)) {
                if (getBuildingCount(type) >= 2) return false;
            }

            const typeIndex = BUILDING_KEYS.indexOf(type);
            if (typeIndex >= LIMIT_START_INDEX && typeIndex !== -1) {
                // „Åù„ÅÆ‰ªñ„ÅÆ‰∏äÁ¥öÊñΩË®≠„ÅØ4„Å§„Åæ„Åß
                if (getBuildingCount(type) >= 4) {
                    return false;
                }
            }
            return true;
        }

        for (let k in BUILDINGS) {
            const b = BUILDINGS[k];
            for (let r of ['money', 'food', 'wood', 'stone', 'iron', 'water']) {
                if (!b.prod[r]) b.prod[r] = 0;
                if (!b.cost[r]) b.cost[r] = 0;
            }
        }

        let gameState = {
            rank: 1, xp: 0,
            resources: { money: 200, food: 100, wood: 50, stone: 0, iron: 0, water: 0 },
            tiles: [],
            inventory: [],
            maxBuilders: CONFIG.initialMaxBuilders,
            gridSize: CONFIG.initialGridSize,
            lastSaveTime: Date.now()
        };

        let selectedTileIndex = null;

        // UI State for Move Mode
        let moveMode = { active: false, sourceIndex: null };

        let scene, camera, renderer;
        let raycaster, mouse;
        let tileMeshes = [];
        let pedestrians = [];
        let environmentGroup = null; // ËÉåÊôØ„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÁî®„Ç∞„É´„Éº„Éó

        let pointerDownPos = new THREE.Vector2();
        let lastPointerPos = new THREE.Vector2();
        let isDragging = false;
        let isPanning = false;

        // Áü≥Áï≥„ÉÜ„ÇØ„Çπ„ÉÅ„É£ÁîüÊàê (ÊîπËâØÁâà)
        function createCobblestoneTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // „Éô„Éº„ÇπÔºàÁõÆÂú∞„ÅÆËâ≤ÔºöÊøÉ„ÅÑ„Ç∞„É¨„ÉºÔºâ
            ctx.fillStyle = '#555';
            ctx.fillRect(0, 0, 512, 512);

            const rows = 8; // Ë°åÊï∞„ÇíÂ¢ó„ÇÑ„Åó„Å¶Áü≥„ÇíÂ∞è„Åï„Åè
            const cols = 8;
            const cellW = 512 / cols;
            const cellH = 512 / rows;

            // Áü≥„ÇíÊèèÁîª
            for (let y = 0; y < rows; y++) {
                // Ë°å„Åî„Å®„Å´„Ç™„Éï„Çª„ÉÉ„Éà„Çí„Åö„Çâ„ÅôÔºà„É¨„É≥„Ç¨Á©ç„ÅøÈ¢®Ôºâ
                const offset = (y % 2 === 0) ? 0 : cellW / 2;

                for (let x = -1; x < cols; x++) {
                    let sx = x * cellW + offset;
                    let sy = y * cellH;

                    // „É©„É≥„ÉÄ„É†„Å™‰ΩçÁΩÆ„Åö„Çå
                    sx += (Math.random() - 0.5) * 10;
                    sy += (Math.random() - 0.5) * 10;

                    // Áü≥„ÅÆ„Çµ„Ç§„Ç∫ÔºàÂ∞ë„Åó„É©„É≥„ÉÄ„É†„Å´‰∏çÊèÉ„ÅÑ„Å´„Åô„ÇãÔºâ
                    const w = cellW - 8 + (Math.random() - 0.5) * 8;
                    const h = cellH - 8 + (Math.random() - 0.5) * 8;

                    // Ëâ≤„ÅÆ„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥ÔºàËá™ÁÑ∂„Å™Áü≥„ÅÆËâ≤Âë≥Ôºâ
                    const gray = 140 + Math.random() * 60;
                    const r = gray + (Math.random() * 20 - 10);
                    const g = gray + (Math.random() * 20 - 10);
                    const b = gray + (Math.random() * 20 - 10);
                    ctx.fillStyle = `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;

                    // Ëßí‰∏∏„ÅÆÁü≥„ÇíÊèèÁîª
                    drawRoundedRect(ctx, sx, sy, w, h, 10);
                    ctx.fill();

                    // „Éè„Ç§„É©„Ç§„Éà„Å®„Ç∑„É£„Éâ„Ç¶„ÅßÁ´ã‰ΩìÊÑü„ÇíÂá∫„Åô
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = 'rgba(255,255,255,0.15)'; // „Éè„Ç§„É©„Ç§„Éà
                    ctx.stroke();
                }
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            // Áü≥„ÇíÁ¥∞„Åã„Åè„Åó„Åü„ÅÆ„Åß„É™„Éî„Éº„ÉàÂõûÊï∞„ÇíÊ∏õ„Çâ„Åô
            tex.repeat.set(1, 1);
            return tex;
        }

        // Ëßí‰∏∏Áü©ÂΩ¢ÊèèÁîª„Éò„É´„Éë„Éº
        function drawRoundedRect(ctx, x, y, w, h, r) {
            if (w < 2 * r) r = w / 2;
            if (h < 2 * r) r = h / 2;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function initGame() {
            log("Game initializing...");

            if (typeof THREE === 'undefined') {
                document.body.innerHTML = '<div style="padding:20px;text-align:center;color:red;"><h3>„Ç®„É©„Éº: 3D„É©„Ç§„Éñ„É©„É™„ÅåË™≠„ÅøËæº„ÇÅ„Åæ„Åõ„Çì„ÄÇ</h3><p>ÂÜçË™≠„ÅøËæº„Åø„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p></div>';
                return;
            }

            migrateXPSystem();

            if (!gameState.maxBuilders) gameState.maxBuilders = CONFIG.initialMaxBuilders;
            if (!gameState.gridSize) gameState.gridSize = CONFIG.initialGridSize;

            const totalTiles = gameState.gridSize * gameState.gridSize;
            if (gameState.tiles.length !== totalTiles) {
                if (gameState.tiles.length === 0) {
                    gameState.tiles = Array(totalTiles).fill(null).map((_, i) => ({
                        type: null, level: 0, finishTime: null,
                        unlocked: CONFIG.initialUnlocked.includes(i),
                        stored: {},
                        lastCollectTime: 0
                    }));
                } else {
                    const currentLen = gameState.tiles.length;
                    for (let i = currentLen; i < totalTiles; i++) {
                        gameState.tiles.push({
                            type: null, level: 0, finishTime: null,
                            unlocked: false,
                            stored: {},
                            lastCollectTime: 0
                        });
                    }
                }
            } else {
                gameState.tiles.forEach(t => {
                    if (!t.stored) t.stored = {};
                    if (t.lastCollectTime === undefined) t.lastCollectTime = 0;
                });
            }
            if (!gameState.inventory) gameState.inventory = [];

            try {
                init3D();
            } catch (e) {
                log(`3D Init Error: ${e.message}`, true);
                showToast("3DË°®Á§∫„ÅÆÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ");
                return;
            }

            updateHeader();

            requestAnimationFrame(animate3D);
            setInterval(gameLogicLoop, 1000);
            setInterval(() => window.saveGame(true), CONFIG.autoSaveInterval);
            setInterval(updatePanelUI, 500);

            log("Game loop started.");
        }

        function migrateXPSystem() {
            if (gameState.xpMigrationDone) return;
            if (gameState.rank < 12) {
                gameState.xpMigrationDone = true;
                return;
            }

            console.log("Migrating XP system for Rank 12+ user...");
            let totalXP = gameState.xp;
            const getLegacyXP = (r) => {
                const base = r * 500;
                if (r >= 10) return base * 4;
                return base;
            };
            for (let r = 1; r < gameState.rank; r++) {
                totalXP += getLegacyXP(r);
            }
            let newRank = 1;
            while (true) {
                const req = getNextRankXP(newRank);
                if (totalXP >= req) {
                    totalXP -= req;
                    newRank++;
                } else {
                    break;
                }
            }
            if (newRank !== gameState.rank) {
                console.log(`Rank migrated: ${gameState.rank} -> ${newRank}`);
                showToast(`„É©„É≥„ÇØË™øÊï¥: ${gameState.rank}‚Üí${newRank}`);
                gameState.rank = newRank;
                gameState.xp = totalXP;
            }
            gameState.xpMigrationDone = true;
            saveGame(true);
        }

        function init3D() {
            const container = document.getElementById('game-container');
            if (!container) throw new Error("Game container not found");

            let width = container.clientWidth;
            let height = container.clientHeight;

            if (width === 0 || height === 0) {
                width = window.innerWidth;
                height = window.innerHeight;
            }

            scene = new THREE.Scene();

            const aspect = width / height;
            const d = 10;

            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(20, 20, 20);
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });

            const pixelRatio = Math.max(window.devicePixelRatio, 2.0);
            renderer.setPixelRatio(pixelRatio);

            renderer.setSize(width, height);
            renderer.shadowMap.enabled = true;
            renderer.setClearColor(0x000000, 0);
            container.innerHTML = '';
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            // „ÉÜ„ÇØ„Çπ„ÉÅ„É£„Å®„Éû„ÉÜ„É™„Ç¢„É´„ÅÆÂàùÊúüÂåñ
            MATERIALS.cobblestone = new THREE.MeshStandardMaterial({
                map: createCobblestoneTexture(),
                roughness: 0.8, // Â∞ë„Åó„Å§„ÇÑ„ÇíÂá∫„Åô
                color: 0xffffff
            });
            MATERIALS.grassLocked = new THREE.MeshStandardMaterial({ color: 0x27ae60, roughness: 1.0 });

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            createTiles();
            initPedestrians();
            createSurroundingEnvironment(); // ËÉåÊôØÁîüÊàê

            window.addEventListener('resize', onWindowResize, false);

            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            renderer.domElement.addEventListener('pointerup', onPointerUp, false);
            renderer.domElement.addEventListener('pointermove', onPointerMove, false);

            renderer.domElement.addEventListener('wheel', onMouseWheel, { passive: false });
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });

            setTimeout(onWindowResize, 100);
        }

        // „Éû„ÉÜ„É™„Ç¢„É´ÂÆöÁæ©Ôºà„ÉÜ„ÇØ„Çπ„ÉÅ„É£ÁîüÊàêÂæå„Å´‰ΩøÁî®Ôºâ
        const MATERIALS = {
            roof: new THREE.MeshStandardMaterial({ color: 0xe74c3c, roughness: 0.8 }),
            wall: new THREE.MeshStandardMaterial({ color: 0xf39c12, roughness: 0.9 }),
            leaf: new THREE.MeshStandardMaterial({ color: 0x2ecc71, roughness: 1.0 }), // Êòé„Çã„ÅÑÁ∑ë
            darkLeaf: new THREE.MeshStandardMaterial({ color: 0x27ae60, roughness: 1.0 }), // Êöó„ÅÑÁ∑ëÔºàÊ£ÆÁî®Ôºâ
            stone: new THREE.MeshStandardMaterial({ color: 0x7f8c8d, roughness: 0.6 }),
            mountain: new THREE.MeshStandardMaterial({ color: 0x95a5a6, roughness: 0.9 }), // Â±±Áî®
            snow: new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 }), // Èõ™Áî®
            dark: new THREE.MeshStandardMaterial({ color: 0x34495e, roughness: 0.5 }),
            tent: new THREE.MeshStandardMaterial({ color: 0x3498db, roughness: 0.9 }),
            grass: new THREE.MeshStandardMaterial({ color: 0x27ae60, roughness: 1.0 }),
            wood: new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 }),
            window: new THREE.MeshStandardMaterial({ color: 0x87CEEB, emissive: 0x112233, roughness: 0.2 }),
            dirt: new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 1.0 }),
            metal: new THREE.MeshStandardMaterial({ color: 0xbdc3c7, metalness: 0.8, roughness: 0.2 }),
            gold: new THREE.MeshStandardMaterial({ color: 0xf1c40f, metalness: 0.6, roughness: 0.3 }),
            water: new THREE.MeshStandardMaterial({ color: 0x3498db, transparent: true, opacity: 0.7 }),
            graySheet: new THREE.MeshStandardMaterial({ color: 0x95a5a6, roughness: 0.9, side: THREE.DoubleSide })
            // cobblestone „Å® grassLocked „ÅØ init3D ÂÜÖ„ÅßËøΩÂä†
        };

        // Â∑•‰∫ãÁèæÂ†¥Ôºà„Ç∑„Éº„ÉàÔºã‰ΩúÊ•≠Âì°Ôºâ‰ΩúÊàê
        function createConstructionSite() {
            const group = new THREE.Group();

            // Ë∂≥Â†¥(Scaffolding)„ÅÆÊßãÁØâ
            // 4Êú¨„ÅÆÈâÑÈ™®ÊîØÊü±„Å®„ÄÅ„Åù„ÅÆÈñì„ÅÆ„Ç∞„É¨„Éº„ÅÆÂπï
            const width = 2.4; // ÂÖ®‰Ωì„ÅÆÂπÖ (1.6 * sqrt(2) * 2 ‚âí 4.5 „Å†„Åå„ÄÅBox„Å®„Åó„Å¶ËÄÉ„Åà„Çã)
            // ÂçäÂæÑ1.6Á®ãÂ∫¶„ÅÆ‰ΩçÁΩÆ„Å´Êü±„ÇíÁΩÆ„Åè„ÄÇÊ≠£ÊñπÂΩ¢ÈÖçÁΩÆ„Å™„Çâ„ÄÅx,z = +/- 1.13Á®ãÂ∫¶
            const dist = 1.2;
            // „Åï„Çâ„Å´È´ò„Åï„Çí30%‰Ωé„Åè„Åô„Çã (0.85 * 0.7 ‚âí 0.6)
            const height = 0.6;

            // ÊîØÊü± (ÈâÑ)
            const poleGeo = new THREE.CylinderGeometry(0.05, 0.05, height, 8);
            const poles = [
                { x: dist, z: dist },
                { x: -dist, z: dist },
                { x: dist, z: -dist },
                { x: -dist, z: -dist }
            ];
            poles.forEach(p => {
                const pole = new THREE.Mesh(poleGeo, MATERIALS.metal);
                pole.position.set(p.x, height / 2, p.z);
                group.add(pole);
            });

            // Âπï („Ç∞„É¨„Éº„ÅÆÂ∏É) - ÊîØÊü±„ÅÆÈñì„Å´Âºµ„Çã
            // 4Êûö„ÅÆÂ£Å„Çí‰Ωú„Çã
            const sheetGeo = new THREE.PlaneGeometry(dist * 2, height * 0.9);
            const sides = [
                { x: 0, z: dist, ry: 0 },
                { x: 0, z: -dist, ry: Math.PI },
                { x: dist, z: 0, ry: Math.PI / 2 },
                { x: -dist, z: 0, ry: -Math.PI / 2 }
            ];
            sides.forEach(s => {
                const sheet = new THREE.Mesh(sheetGeo, MATERIALS.graySheet);
                sheet.position.set(s.x, height / 2, s.z);
                sheet.rotation.y = s.ry;
                group.add(sheet);
            });

            // ‰ΩúÊ•≠Âì°
            const worker = new THREE.Group();
            worker.position.set(0, 0, 1.0); // ÊñΩË®≠(0.7Á®ãÂ∫¶)„Çà„ÇäÂ§ñ„ÄÅ„Ç∑„Éº„Éà(1.2)„Çà„ÇäÂÜÖÂÅ¥„Å´ÈÖçÁΩÆ

            // ‰Ωì
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.25, 8), new THREE.MeshStandardMaterial({ color: 0xecf0f1 }));
            body.position.y = 0.125;
            worker.add(body);

            // È†≠
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), new THREE.MeshStandardMaterial({ color: 0xf1c40f })); // „Éò„É´„É°„ÉÉ„ÉàÈªÑËâ≤
            head.position.y = 0.3;
            worker.add(head);

            // „Éè„É≥„Éû„Éº
            const hammer = new THREE.Group();
            hammer.position.set(0.1, 0.2, 0.1);
            const handle = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.15, 0.02), MATERIALS.wood);
            handle.position.y = 0.075;
            hammer.add(handle);
            const headH = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, 0.05), MATERIALS.metal);
            headH.position.set(0, 0.15, 0);
            hammer.add(headH);

            hammer.rotation.z = -Math.PI / 4;
            hammer.userData = { anim: 'hammerWork', speed: 0.2 };
            worker.add(hammer);

            group.add(worker);
            return group;
        }

        // Âë®Âõ≤„ÅÆÁí∞Â¢ÉÔºàÂ±±„ÇÑÊ£ÆÔºâ„ÇíÁîüÊàê„Åô„ÇãÈñ¢Êï∞
        function createSurroundingEnvironment() {
            if (environmentGroup) scene.remove(environmentGroup);
            environmentGroup = new THREE.Group();
            scene.add(environmentGroup);

            const currentSize = gameState.gridSize * 2; // „Ç∞„É™„ÉÉ„Éâ„ÅÆÂÄç„ÅÆÁØÑÂõ≤„ÇíÂÆâÂÖ®Âú∞Â∏Ø„Å®„Åô„Çã
            const range = 60; // ÁîüÊàêÁØÑÂõ≤„ÅÆÂçäÂæÑ

            // „Éò„É´„Éë„Éº: Êú®„Çí‰ΩúÊàê
            const createTree = (x, z, scale = 1) => {
                const g = new THREE.Group();
                g.position.set(x, 0, z);
                g.scale.set(scale, scale, scale);

                // Âππ
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.15, 0.5, 5),
                    MATERIALS.wood
                );
                trunk.position.y = 0.25;
                trunk.castShadow = true;
                g.add(trunk);

                // Ëëâ (3ÊÆµ)
                const l1 = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.6, 5), MATERIALS.darkLeaf);
                l1.position.y = 0.6;
                l1.castShadow = true;
                g.add(l1);

                const l2 = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.5, 5), MATERIALS.darkLeaf);
                l2.position.y = 0.9;
                l2.castShadow = true;
                g.add(l2);

                return g;
            };

            // „Éò„É´„Éë„Éº: Â±±„Çí‰ΩúÊàê
            const createMountain = (x, z, height, radius) => {
                const g = new THREE.Group();
                g.position.set(x, 0, z);

                // Êú¨‰Ωì
                const m = new THREE.Mesh(
                    new THREE.ConeGeometry(radius, height, 5),
                    MATERIALS.mountain
                );
                m.position.y = height / 2;
                m.castShadow = true;
                m.receiveShadow = true;
                g.add(m);

                // Èõ™Ëß£„ÅëÔºàÈ†Ç‰∏äÔºâ
                const s = new THREE.Mesh(
                    new THREE.ConeGeometry(radius * 0.3, height * 0.3, 5),
                    MATERIALS.snow
                );
                s.position.y = height * 0.85;
                g.add(s);

                return g;
            };

            // ÈÖçÁΩÆ„É≠„Ç∏„ÉÉ„ÇØ
            for (let i = 0; i < 150; i++) {
                const angle = Math.random() * Math.PI * 2;
                // „Ç∞„É™„ÉÉ„Éâ„ÅÆÂ§ñÂÅ¥„Åã„ÇâÈÅ†„Åè„Åæ„ÅßÈÖçÁΩÆ
                // offset=3„Å™„ÅÆ„Åß„ÄÅ„Çµ„Ç§„Ç∫„ÇÇÂ§ß„Åç„Åè„Å™„Å£„Å¶„ÅÑ„Çã„ÄÇ
                // ÂçäÂæÑË®àÁÆó: (currentSize / 2 * 3) + ‰ΩôË£ï
                const dist = (currentSize * 1.5) + 8 + Math.random() * range;

                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;

                // Â••ÂÅ¥ÔºàÂåóÂÅ¥Ôºâ„Å´„ÅØÂ±±„ÇíÂ§ö„ÇÅ„Å´ÈÖçÁΩÆ
                if (z < -10 && Math.random() > 0.6) {
                    const h = 3 + Math.random() * 5; // È´ò„Åï„ÇíÊäë„Åà„Çã
                    const r = 2 + Math.random() * 3; // ÂπÖ„ÇíÊäë„Åà„Çã
                    environmentGroup.add(createMountain(x, z, h, r));
                } else {
                    // Êú®„ÇíÈÖçÁΩÆ
                    const scale = 0.8 + Math.random() * 0.8; // „Çµ„Ç§„Ç∫„ÇíÂ∞è„Åï„Åè„Åô„Çã
                    const tree = createTree(x, z, scale);
                    // „É©„É≥„ÉÄ„É†„Å´Â∞ë„ÅóÂÇæ„Åë„Çã
                    tree.rotation.z = (Math.random() - 0.5) * 0.1;
                    tree.rotation.x = (Math.random() - 0.5) * 0.1;
                    environmentGroup.add(tree);
                }
            }

            // Âú∞Èù¢„Å®„Å™„ÇãÂ∑®Â§ß„Å™ÂÜÜÁõ§Ôºà„Éó„É¨„Ç§„Ç®„É™„Ç¢„ÅÆ‰∏ãÔºâ
            const bigGround = new THREE.Mesh(
                new THREE.CircleGeometry(range + 30, 32),
                new THREE.MeshStandardMaterial({ color: 0x3c5c35, roughness: 1.0 }) // ÊøÉ„ÅÑÁ∑ë„ÅÆÂú∞Èù¢
            );
            bigGround.rotation.x = -Math.PI / 2;
            bigGround.position.y = -0.1; // „Çø„Ç§„É´„ÅÆÂú∞Èù¢„Çà„Çä„Åï„Çâ„Å´‰∏ã
            bigGround.receiveShadow = true;
            environmentGroup.add(bigGround);
        }

        // --- Sound Manager (Web Audio API) ---
        const SoundManager = {
            ctx: null,
            bgmNode: null,
            masterGain: null,
            bgmGain: null,
            nextNoteTime: 0,
            isPlaying: false,
            timerID: null,
            config: {
                bgmVolume: parseFloat(localStorage.getItem('kb_config_bgm_vol') || '0.5'),
                seVolume: parseFloat(localStorage.getItem('kb_config_se_vol') || '0.5')
            },

            init: function () {
                if (this.ctx) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;

                this.ctx = new AudioContext();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 1.0;
                this.masterGain.connect(this.ctx.destination);

                if (this.config.bgmVolume > 0) this.playBGM();
            },

            resume: function () {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
                if (!this.ctx) this.init();
            },

            setBGMVolume: function (val) {
                this.config.bgmVolume = val;
                localStorage.setItem('kb_config_bgm_vol', val);
                if (this.bgmGain) {
                    this.bgmGain.gain.cancelScheduledValues(0);
                    this.bgmGain.gain.value = val * 0.3;
                }
                if (val > 0 && !this.isPlaying) {
                    this.playBGM();
                } else if (val === 0 && this.isPlaying) {
                    this.stopBGM();
                }
            },

            setSEVolume: function (val) {
                this.config.seVolume = val;
                localStorage.setItem('kb_config_se_vol', val);
            },

            // --- BGM Sequencer ---
            playBGM: function () {
                if (this.isPlaying || !this.ctx) return;
                this.resume();

                // If volume is 0, don't start
                if (this.config.bgmVolume <= 0) return;

                this.isPlaying = true;
                this.nextNoteTime = this.ctx.currentTime + 0.1;

                // Master BGM Gain for volume control
                this.bgmGain = this.ctx.createGain();
                this.bgmGain.gain.value = this.config.bgmVolume * 0.3;
                this.bgmGain.connect(this.masterGain);

                this.melodyIndex = 0;
                this.scheduler();
            },

            stopBGM: function () {
                this.isPlaying = false;
                if (this.timerID) clearTimeout(this.timerID);
                if (this.bgmGain) {
                    this.bgmGain.disconnect();
                    this.bgmGain = null;
                }
            },

            scheduler: function () {
                if (!this.isPlaying) return;
                // Schedule ahead 0.1s
                while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
                    this.scheduleNote(this.nextNoteTime);
                    this.nextNoteTime += 0.4; // Tempo
                }
                this.timerID = setTimeout(() => this.scheduler(), 25);
            },

            melodyIndex: 0,
            scheduleNote: function (time) {
                // Calming pentatonic melody loop
                // C4, D4, E4, G4, A4 ... 
                const notes = [
                    261.63, 293.66, 329.63, 392.00, // C D E G
                    440.00, 392.00, 329.63, 293.66, // A G E D
                    261.63, -1, 329.63, -1,         // C - E -
                    392.00, 261.63, 293.66, -1      // G C D -
                ];

                const freq = notes[this.melodyIndex % notes.length];
                this.melodyIndex++;
                if (freq <= 0) return;

                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                // Soft Triangle (Electric Piano like)
                osc.type = 'triangle';
                osc.frequency.value = freq;

                // Envelope
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(1.0, time + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.6);

                osc.connect(gain);
                gain.connect(this.bgmGain);

                osc.start(time);
                osc.stop(time + 0.6);
            },

            playSE: function (type) {
                if (this.config.seVolume <= 0) return;
                this.resume();
                if (!this.ctx) return;

                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.connect(gain);
                gain.connect(this.masterGain);

                const vol = this.config.seVolume;

                if (type === 'select') {
                    // High blip
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(800, t);
                    osc.frequency.exponentialRampToValueAtTime(1200, t + 0.1);
                    gain.gain.setValueAtTime(0.3 * vol, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                    osc.start(t);
                    osc.stop(t + 0.1);

                } else if (type === 'build') {
                    // Low thud
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(150, t);
                    osc.frequency.exponentialRampToValueAtTime(40, t + 0.2);
                    gain.gain.setValueAtTime(0.5 * vol, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                    osc.start(t);
                    osc.stop(t + 0.2);

                } else if (type === 'collect') {
                    // Coin / Shimmer
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(1200, t);
                    gain.gain.setValueAtTime(0.3 * vol, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                    osc.start(t);
                    osc.stop(t + 0.15);

                    const osc2 = this.ctx.createOscillator();
                    const gain2 = this.ctx.createGain();
                    osc2.connect(gain2);
                    gain2.connect(this.masterGain);
                    osc2.type = 'sine';
                    osc2.frequency.setValueAtTime(1800, t + 0.05);
                    gain2.gain.setValueAtTime(0.3 * vol, t + 0.05);
                    gain2.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                    osc2.start(t + 0.05);
                    osc2.stop(t + 0.2);

                } else if (type === 'levelup') {
                    // Fanfare
                    const notes = [523.25, 659.25, 783.99, 1046.50];
                    notes.forEach((freq, i) => {
                        const o = this.ctx.createOscillator();
                        const g = this.ctx.createGain();
                        o.connect(g);
                        g.connect(this.masterGain);
                        o.type = 'triangle';
                        o.frequency.value = freq;
                        g.gain.setValueAtTime(0.2 * vol, t + i * 0.1);
                        g.gain.exponentialRampToValueAtTime(0.01, t + i * 0.1 + 0.3);
                        o.start(t + i * 0.1);
                        o.stop(t + i * 0.1 + 0.3);
                    });

                } else if (type === 'error') {
                    // Buzz
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, t);
                    osc.frequency.linearRampToValueAtTime(100, t + 0.15);
                    gain.gain.setValueAtTime(0.2 * vol, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
                    osc.start(t);
                    osc.stop(t + 0.15);
                } else if (type === 'cancel') {
                    // Descending
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(600, t);
                    osc.frequency.linearRampToValueAtTime(300, t + 0.2);
                    gain.gain.setValueAtTime(0.2 * vol, t);
                    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                    osc.start(t);
                    osc.stop(t + 0.2);
                }
            }
        };

        // Click to resume
        const initAudio = () => { SoundManager.resume(); };
        document.addEventListener('click', initAudio, { once: true });
        document.addEventListener('touchstart', initAudio, { once: true });

        function createTiles() {
            tileMeshes.forEach(t => {
                scene.remove(t.mesh);
                scene.remove(t.groundMesh);
                t.overlayEl.remove();
            });
            tileMeshes = [];

            // ÂúüÂè∞„ÅØ„ÄåË¶ã„Åà„Å™„ÅÑ„Éí„ÉÉ„Éà„Éú„ÉÉ„ÇØ„Çπ„Äç„Å´Â§âÊõ¥
            const geometry = new THREE.BoxGeometry(2.1, 0.75, 2.1);
            const invisibleMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0 });

            // Âú∞Èù¢„ÇíÂ∞ë„ÅóÂ§ß„Åç„Åè„Åó„Å¶ÈöôÈñì„Çí„Å™„Åè„Åô
            const groundGeo = new THREE.PlaneGeometry(3.1, 3.1);
            // groundMat„ÅØÂÄãÂà•„Ç§„É≥„Çπ„Çø„É≥„Çπ„Å®„Åó„Å¶ÁîüÊàê

            const offset = 3;
            const size = gameState.gridSize;
            const start = -offset * (size - 1) / 2;

            for (let i = 0; i < size * size; i++) {
                const row = Math.floor(i / size);
                const col = i % size;
                const x = start + col * offset;
                const z = start + row * offset;

                // Âú∞Èù¢ÔºàÂàùÊúü„Éû„ÉÜ„É™„Ç¢„É´„ÅØ‰ªÆ„ÄÅsync3DState„ÅßÊõ¥Êñ∞Ôºâ
                const groundMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.position.set(x, -0.05, z); // „Å°„Çâ„Å§„ÅçÈò≤Ê≠¢„ÅÆ„Åü„ÇÅÂ∞ë„Åó‰∏ã„Åí„Çã
                ground.receiveShadow = true;
                scene.add(ground);

                // ÈÄèÊòé„Å™„Éí„ÉÉ„ÉàÂà§ÂÆöÁî®„Éú„ÉÉ„ÇØ„Çπ
                const mesh = new THREE.Mesh(geometry, invisibleMat.clone());
                mesh.position.set(x, 0, z);
                mesh.userData = { index: i, type: 'tile' };
                scene.add(mesh);

                const bGroup = new THREE.Group();
                // Âª∫Áâ©„ÅØÂú∞Èù¢(y=0)„Åã„ÇâÁõ¥Êé•Âª∫„Å¶„Çã
                bGroup.position.set(0, 0, 0);
                mesh.add(bGroup);

                const overlay = document.createElement('div');
                overlay.className = 'overlay-item';
                document.getElementById('ui-overlay-layer').appendChild(overlay);

                const particles = new ParticleSystem(mesh.position, scene);

                tileMeshes.push({
                    mesh: mesh,
                    groundMesh: ground,
                    buildingGroup: bGroup,
                    overlayEl: overlay,
                    particles: particles,
                    currentType: null
                });
            }
            sync3DState();
            createSurroundingEnvironment(); // „Çø„Ç§„É´ÁîüÊàêÊôÇ„Å´„ÇÇÁí∞Â¢É„ÇíÊõ¥Êñ∞Ôºà„Çµ„Ç§„Ç∫Êã°ÂºµÂØæÂøúÔºâ
        }

        class Person {
            constructor(scene) {
                this.scene = scene;
                this.mesh = new THREE.Group();
                const bodyColor = Math.random() * 0xffffff;
                const bodyGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.25, 8);
                const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0.125;
                this.mesh.add(body);
                const headGeo = new THREE.SphereGeometry(0.1, 8, 8);
                const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 0.35;
                this.mesh.add(head);
                this.mesh.castShadow = true;
                scene.add(this.mesh);
                this.active = false;
                this.mesh.visible = false;
                this.isStopped = false;
                this.stopTimer = 0;
                this.canTurn = true;
                this.reset();
            }
            getNearestRoadCoord(val) {
                const size = gameState.gridSize;
                const offset = 3;
                const tileStart = -offset * (size - 1) / 2;
                const roadStart = tileStart + 1;
                const index = Math.round((val - roadStart) / offset);
                return roadStart + index * offset;
            }
            reset() {
                const isVertical = Math.random() < 0.5;
                const size = gameState.gridSize;
                const offset = 3;
                const tileStart = -offset * (size - 1) / 2;
                const roadStart = tileStart + 1;
                const roadCount = Math.max(1, size - 1);
                const roadIndex = Math.floor(Math.random() * roadCount);
                const laneCenter = roadStart + roadIndex * offset;
                const jitter = (Math.random() - 0.5) * 0.4;
                const lane = laneCenter + jitter;
                this.baseSpeed = (0.02 + Math.random() * 0.02) * 0.25;
                this.speed = this.baseSpeed;
                let sx, sz, dx, dz;
                const spawnDist = size + 5;
                if (isVertical) {
                    sx = lane;
                    sz = (Math.random() < 0.5 ? -spawnDist : spawnDist);
                    dx = 0; dz = sz > 0 ? -1 : 1;
                } else {
                    sz = lane;
                    sx = (Math.random() < 0.5 ? -spawnDist : spawnDist);
                    dx = sx > 0 ? -1 : 1; dz = 0;
                }
                this.mesh.position.set(sx, 0, sz);
                this.direction = new THREE.Vector3(dx, 0, dz);
                this.active = true;
                this.isStopped = false;
                this.canTurn = true;
                this.updateVisibility();
            }
            isOnGreenRoad(x, z, isVertical) {
                const size = gameState.gridSize;
                const offset = 2;
                const start = -offset * (size - 1) / 2;
                const checkTile = (wx, wz) => {
                    const col = Math.round((wx - start) / offset);
                    const row = Math.round((wz - start) / offset);
                    if (col < 0 || col >= size || row < 0 || row >= size) return false;
                    const idx = row * size + col;
                    return gameState.tiles[idx] && gameState.tiles[idx].unlocked;
                };
                let t1_unlocked = false;
                let t2_unlocked = false;
                if (isVertical) {
                    t1_unlocked = checkTile(x - 1, Math.round(z));
                    t2_unlocked = checkTile(x + 1, Math.round(z));
                } else {
                    t1_unlocked = checkTile(Math.round(x), z - 1);
                    t2_unlocked = checkTile(Math.round(x), z + 1);
                }
                return (!t1_unlocked && !t2_unlocked);
            }
            update() {
                if (!this.active) {
                    if (Math.random() < 0.01) this.reset();
                    return;
                }
                if (this.isStopped) {
                    this.stopTimer--;
                    if (this.stopTimer <= 0) {
                        this.isStopped = false;
                    }
                    this.updateVisibility();
                    return;
                }
                if (Math.random() < 0.005) {
                    this.isStopped = true;
                    this.stopTimer = 30 + Math.random() * 60;
                    return;
                }
                const nearestRoadX = this.getNearestRoadCoord(this.mesh.position.x);
                const nearestRoadZ = this.getNearestRoadCoord(this.mesh.position.z);
                const distX = Math.abs(this.mesh.position.x - nearestRoadX);
                const distZ = Math.abs(this.mesh.position.z - nearestRoadZ);
                const intersectionThreshold = 0.1;
                const isAtIntersection = (distX < intersectionThreshold && distZ < intersectionThreshold);
                if (isAtIntersection) {
                    if (this.canTurn) {
                        if (Math.random() < 0.5) {
                            const dirs = [
                                new THREE.Vector3(1, 0, 0),
                                new THREE.Vector3(-1, 0, 0),
                                new THREE.Vector3(0, 0, 1),
                                new THREE.Vector3(0, 0, -1)
                            ];
                            this.direction = dirs[Math.floor(Math.random() * dirs.length)];
                            this.mesh.position.x = nearestRoadX;
                            this.mesh.position.z = nearestRoadZ;
                        }
                        this.canTurn = false;
                    }
                } else {
                    if (Math.max(distX, distZ) > 0.4) {
                        this.canTurn = true;
                    }
                }
                this.mesh.position.addScaledVector(this.direction, this.speed);
                const limit = gameState.gridSize * 1.5 + 5;
                if (Math.abs(this.mesh.position.x) > limit || Math.abs(this.mesh.position.z) > limit) {
                    this.reset();
                    return;
                }
                this.updateVisibility();
                this.mesh.position.y = Math.abs(Math.sin(Date.now() * 0.005)) * 0.05;
            }
            updateVisibility() {
                const isVertical = (this.direction.z !== 0);
                if (this.isOnGreenRoad(this.mesh.position.x, this.mesh.position.z, isVertical)) {
                    this.mesh.visible = false;
                } else {
                    this.mesh.visible = true;
                }
            }
        }

        function initPedestrians() {
            if (pedestrians.length === 0) {
                for (let i = 0; i < 15; i++) {
                    pedestrians.push(new Person(scene));
                }
            } else {
                pedestrians.forEach(p => p.reset());
            }
        }

        class ParticleSystem {
            constructor(position, scene) {
                this.origin = position.clone().add(new THREE.Vector3(0, 1, 0));
                this.particles = [];
                this.scene = scene;
                this.active = false;
                this.geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                this.mat = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true });
            }
            update() {
                if (!this.active && this.particles.length === 0) return;
                if (this.active && Math.random() < 0.2) {
                    const mesh = new THREE.Mesh(this.geo, this.mat.clone());
                    const offset = new THREE.Vector3((Math.random() - 0.5) * 1.5, 0, (Math.random() - 0.5) * 1.5);
                    mesh.position.copy(this.origin).add(offset);
                    this.scene.add(mesh);
                    this.particles.push({
                        mesh: mesh,
                        vel: new THREE.Vector3(0, 0.05 + Math.random() * 0.05, 0),
                        life: 1.0
                    });
                }
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.mesh.position.add(p.vel);
                    p.mesh.rotation.x += 0.1;
                    p.mesh.rotation.y += 0.1;
                    p.life -= 0.02;
                    p.mesh.material.opacity = p.life;
                    if (p.life <= 0) {
                        this.scene.remove(p.mesh);
                        this.particles.splice(i, 1);
                    }
                }
            }
        }

        function createBuildingMesh(type, level) {
            const group = new THREE.Group();
            // „Éô„Éº„Çπ„Çπ„Ç±„Éº„É´Ë™øÊï¥
            const scale = 1 + (level > 1 ? Math.log(level) * 0.1 : 0);
            group.scale.set(scale, scale, scale);

            const tier = level < 5 ? 1 : level < 10 ? 2 : 3;

            const createBox = (w, h, d, mat, x, y, z, rotY = 0) => {
                const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
                m.position.set(x, y, z);
                if (rotY) m.rotation.y = rotY;
                m.castShadow = true;
                m.receiveShadow = true;
                return m;
            };
            const createCyl = (rt, rb, h, mat, x, y, z, rotY = 0, seg = 8) => {
                const m = new THREE.Mesh(new THREE.CylinderGeometry(rt, rb, h, seg), mat);
                m.position.set(x, y, z);
                if (rotY) m.rotation.y = rotY;
                m.castShadow = true;
                return m;
            };
            const createCone = (r, h, mat, x, y, z, rotY = 0) => {
                const m = new THREE.Mesh(new THREE.ConeGeometry(r, h, 4), mat);
                m.position.set(x, y, z);
                m.rotation.y = rotY;
                m.castShadow = true;
                return m;
            };

            switch (type) {
                case 'wild': // Êú™ÈñãÊãìÂú∞
                    // Ëçâ
                    for (let i = 0; i < 8; i++) {
                        const r = 0.1 + (i % 3) * 0.05;
                        const x = Math.sin(i * 2.5) * 0.5;
                        const z = Math.cos(i * 2.5) * 0.5;
                        group.add(createCone(0.1, 0.3, MATERIALS.grass, x, 0.15, z, Math.random()));
                    }
                    // Â≤©„ÇÑÊú®
                    group.add(createBox(0.3, 0.2, 0.3, MATERIALS.stone, 0.4, 0.1, 0.4, 0.5));
                    group.add(createCyl(0.05, 0.08, 0.4, MATERIALS.wood, -0.3, 0.2, -0.3)); // Âππ
                    group.add(createCone(0.3, 0.6, MATERIALS.leaf, -0.3, 0.5, -0.3)); // Ëëâ
                    break;

                case 'house':
                    // ÂÆ∂„ÅÆÊú¨‰ΩìÔºàÂú∞Èù¢„Åã„ÇâÔºâ
                    group.add(createBox(0.8, 0.6, 0.8, MATERIALS.wall, 0, 0.3, 0));

                    if (tier >= 2) {
                        group.add(createBox(0.8, 0.5, 0.5, MATERIALS.wall, 0, 0.85, 0));
                        const roof = createCone(0.8, 0.6, MATERIALS.roof, 0, 1.4, 0, Math.PI / 4);
                        roof.scale.z = 0.8;
                        group.add(roof);
                        group.add(createBox(0.2, 0.2, 0.05, MATERIALS.window, 0.2, 0.9, 0.26));
                        group.add(createBox(0.2, 0.2, 0.05, MATERIALS.window, -0.2, 0.9, 0.26));
                    } else {
                        group.add(createCone(0.7, 0.5, MATERIALS.roof, 0, 0.85, 0, Math.PI / 4));
                    }

                    group.add(createBox(0.25, 0.4, 0.05, MATERIALS.wood, 0, 0.2, 0.4)); // Door
                    group.add(createBox(0.2, 0.2, 0.05, MATERIALS.window, 0.2, 0.4, 0.41)); // Window

                    const chimH = tier >= 2 ? 1.4 : 0.8;
                    group.add(createBox(0.15, 0.6, 0.15, MATERIALS.stone, 0.25, chimH, -0.1));

                    if (tier >= 3) {
                        group.add(createBox(0.05, 0.3, 0.05, MATERIALS.wood, 0.5, 0.15, 0.5));
                        group.add(createBox(0.05, 0.3, 0.05, MATERIALS.wood, 0.6, 0.15, 0.5));
                        group.add(createBox(0.05, 0.3, 0.05, MATERIALS.wood, -0.5, 0.15, 0.5));
                        group.add(createCyl(0.05, 0.05, 0.3, MATERIALS.wood, -0.5, 0.15, 0.3));
                        group.add(createCone(0.2, 0.4, MATERIALS.leaf, -0.5, 0.4, 0.3));
                    }

                    if (level > 0) {
                        const smokeNode = new THREE.Object3D();
                        smokeNode.position.set(0.25, chimH + 0.3, -0.1);
                        smokeNode.userData = { anim: 'smoke' };
                        group.add(smokeNode);
                    }
                    break;

                case 'farm':
                    // Áïë„ÅÆÂúü (Â∞ë„ÅóÁõõ„Çä‰∏ä„Åí„Çã)
                    group.add(createBox(1.0, 0.1, 1.0, MATERIALS.dirt, 0, 0.05, 0));

                    const cropRows = tier >= 3 ? 3 : 2;
                    const cropCols = tier >= 3 ? 3 : 2;

                    for (let i = 0; i < cropRows; i++) {
                        for (let j = 0; j < cropCols; j++) {
                            const cx = (i - (cropRows - 1) / 2) * 0.3;
                            const cz = (j - (cropCols - 1) / 2) * 0.3;
                            const cropGroup = new THREE.Group();
                            cropGroup.position.set(cx, 0.1, cz);

                            if (tier === 1) {
                                cropGroup.add(createCone(0.05, 0.2, MATERIALS.leaf, 0, 0.1, 0));
                            } else {
                                cropGroup.add(createCyl(0.02, 0.02, 0.4, MATERIALS.gold, 0, 0.2, 0));
                                cropGroup.add(createBox(0.1, 0.1, 0.1, MATERIALS.gold, 0, 0.4, 0));
                            }

                            cropGroup.userData = { anim: 'sway', speed: 2.0 + Math.random(), offset: Math.random() * 10 };
                            group.add(cropGroup);
                        }
                    }

                    if (tier >= 2) {
                        const scarecrow = new THREE.Group();
                        scarecrow.position.set(0.4, 0.1, 0.4);
                        scarecrow.add(createCyl(0.03, 0.03, 0.6, MATERIALS.wood, 0, 0.3, 0)); // Ê£í
                        scarecrow.add(createBox(0.3, 0.05, 0.05, MATERIALS.wood, 0, 0.4, 0)); // ËÖï
                        scarecrow.add(createBox(0.1, 0.1, 0.1, MATERIALS.white, 0, 0.55, 0)); // È†≠
                        scarecrow.rotation.y = -0.2;
                        group.add(scarecrow);
                    }

                    if (tier >= 3) {
                        const windmillBase = createCyl(0.15, 0.2, 0.8, MATERIALS.wall, -0.4, 0.4, -0.4);
                        group.add(windmillBase);
                        const roof = createCone(0.25, 0.3, MATERIALS.roof, -0.4, 0.95, -0.4);
                        group.add(roof);

                        const blades = new THREE.Group();
                        blades.position.set(-0.4, 0.9, -0.25);
                        blades.add(createBox(0.8, 0.05, 0.02, MATERIALS.white, 0, 0, 0));
                        blades.add(createBox(0.05, 0.8, 0.02, MATERIALS.white, 0, 0, 0));
                        blades.userData = { anim: 'rotateZ', speed: 0.02 };
                        group.add(blades);
                    }
                    break;

                case 'lumber':
                    group.add(createBox(0.4, 0.5, 0.4, MATERIALS.wood, -0.3, 0.25, -0.3));
                    group.add(createCone(0.4, 0.4, MATERIALS.leaf, -0.3, 0.7, -0.3));

                    group.add(createCyl(0.1, 0.15, 0.5, MATERIALS.wood, 0.3, 0.25, 0.3));
                    group.add(createCone(0.3, 0.6, MATERIALS.leaf, 0.3, 0.6, 0.3));

                    if (tier >= 2) {
                        group.add(createCyl(0.12, 0.12, 0.15, MATERIALS.wood, 0.3, 0.075, -0.2));
                        group.add(createCyl(0.08, 0.08, 0.6, MATERIALS.wood, -0.2, 0.08, 0.3, Math.PI / 2));
                        group.add(createCyl(0.08, 0.08, 0.6, MATERIALS.wood, -0.2, 0.08, 0.45, Math.PI / 2));
                        group.add(createCyl(0.08, 0.08, 0.6, MATERIALS.wood, -0.2, 0.2, 0.375, Math.PI / 2));
                    }

                    if (tier >= 3) {
                        const sawBase = createBox(0.4, 0.2, 0.1, MATERIALS.wood, 0, 0.1, 0);
                        group.add(sawBase);
                        const blade = createBox(0.3, 0.01, 0.3, MATERIALS.metal, 0, 0.22, 0);
                        blade.userData = { anim: 'sawMove' };
                        group.add(blade);
                    }
                    break;

                case 'quarry':
                    group.add(createBox(0.5, 0.4, 0.5, MATERIALS.stone, -0.2, 0.2, -0.2));
                    group.add(createBox(0.4, 0.3, 0.4, MATERIALS.stone, 0.2, 0.15, 0.1));

                    if (tier >= 2) {
                        const craneBase = createCyl(0.05, 0.05, 0.6, MATERIALS.wood, 0.3, 0.3, -0.3);
                        group.add(craneBase);

                        const craneGroup = new THREE.Group();
                        craneGroup.position.set(0.3, 0.6, -0.3);
                        const arm = createBox(0.5, 0.05, 0.05, MATERIALS.wood, -0.25, 0, 0);
                        craneGroup.add(arm);
                        const string = createCyl(0.01, 0.01, 0.4, MATERIALS.white, -0.45, -0.2, 0);
                        craneGroup.add(string);
                        const stoneBlock = createBox(0.15, 0.15, 0.15, MATERIALS.stone, -0.45, -0.45, 0);
                        craneGroup.add(stoneBlock);

                        craneGroup.userData = { anim: 'rotateY', speed: 0.005 };
                        group.add(craneGroup);
                    }

                    if (tier >= 3) {
                        group.add(createBox(0.8, 0.02, 0.15, MATERIALS.dark, 0, 0.02, 0.4));
                        const cart = new THREE.Group();
                        cart.position.set(0, 0.1, 0.4);
                        cart.add(createBox(0.2, 0.15, 0.2, MATERIALS.wood, 0, 0, 0));
                        cart.add(createBox(0.15, 0.1, 0.15, MATERIALS.stone, 0, 0.05, 0));
                        cart.userData = { anim: 'shuttleX', range: 0.3, speed: 0.02 };
                        group.add(cart);
                    }
                    break;

                case 'mine':
                    group.add(createBox(0.6, 0.6, 0.3, MATERIALS.dirt, 0, 0.3, -0.2));
                    group.add(createBox(0.4, 0.4, 0.1, MATERIALS.dark, 0, 0.2, -0.05)); // Á©¥
                    group.add(createCyl(0.05, 0.05, 0.6, MATERIALS.wood, 0.25, 0.3, -0.05));
                    group.add(createCyl(0.05, 0.05, 0.6, MATERIALS.wood, -0.25, 0.3, -0.05));
                    group.add(createBox(0.6, 0.1, 0.1, MATERIALS.wood, 0, 0.55, -0.05));

                    if (tier >= 2) {
                        const lantern = createBox(0.08, 0.12, 0.08, MATERIALS.gold, 0.32, 0.45, 0);
                        lantern.userData = { anim: 'blink', speed: 0.1 };
                        group.add(lantern);
                    }

                    if (tier >= 3) {
                        const drillGroup = new THREE.Group();
                        drillGroup.position.set(-0.2, 0.15, 0.3);
                        drillGroup.add(createBox(0.3, 0.2, 0.3, MATERIALS.metal, 0, 0, 0));
                        const bit = createCone(0.1, 0.3, MATERIALS.dark, 0, 0, 0.25, -Math.PI / 2);
                        bit.userData = { anim: 'spinX', speed: 0.5 };
                        drillGroup.add(bit);
                        group.add(drillGroup);
                    }
                    break;

                case 'market':
                    const createStall = (x, z, color) => {
                        const g = new THREE.Group();
                        g.position.set(x, 0, z);
                        g.add(createBox(0.4, 0.3, 0.3, MATERIALS.wood, 0, 0.15, 0)); // Âè∞
                        const r = createCyl(0, 0.3, 0.2, color, 0, 0.5, 0, 0, 4);
                        r.rotation.y = Math.PI / 4;
                        g.add(r);
                        g.add(createCyl(0.02, 0.02, 0.4, MATERIALS.wood, 0.18, 0.3, 0.13));
                        g.add(createCyl(0.02, 0.02, 0.4, MATERIALS.wood, -0.18, 0.3, 0.13));
                        g.add(createCyl(0.02, 0.02, 0.4, MATERIALS.wood, 0.18, 0.3, -0.13));
                        g.add(createCyl(0.02, 0.02, 0.4, MATERIALS.wood, -0.18, 0.3, -0.13));
                        return g;
                    };

                    group.add(createStall(0, 0, 0, MATERIALS.tent));

                    if (tier >= 2) {
                        group.add(createStall(0.4, 0.3, MATERIALS.roof));
                        group.add(createBox(0.15, 0.15, 0.15, MATERIALS.wood, -0.3, 0.075, 0.3));
                        group.add(createBox(0.15, 0.15, 0.15, MATERIALS.wood, -0.4, 0.075, 0.2));
                    }

                    if (tier >= 3) {
                        group.add(createStall(-0.4, -0.2, MATERIALS.grass));
                        const fountain = new THREE.Group();
                        fountain.position.set(0, 0.1, 0.5);
                        fountain.add(createCyl(0.3, 0.2, 0.1, MATERIALS.stone, 0, 0, 0));
                        fountain.add(createCyl(0.1, 0.1, 0.3, MATERIALS.stone, 0, 0.15, 0));
                        const water = createBox(0.05, 0.05, 0.05, MATERIALS.water, 0, 0.35, 0);
                        water.userData = { anim: 'bounceY', speed: 0.1, range: 0.05 };
                        fountain.add(water);
                        group.add(fountain);
                    }
                    break;

                case 'blacksmith':
                    group.add(createBox(0.7, 0.5, 0.5, MATERIALS.dark, 0, 0.25, -0.1));
                    group.add(createBox(0.2, 0.8, 0.2, MATERIALS.stone, 0.3, 0.4, -0.1));
                    const smokeB = new THREE.Object3D();
                    smokeB.position.set(0.3, 0.9, -0.1);
                    smokeB.userData = { anim: 'smoke' };
                    group.add(smokeB);

                    if (tier >= 2) {
                        const furnace = createBox(0.3, 0.3, 0.3, MATERIALS.stone, -0.3, 0.15, 0.3);
                        group.add(furnace);
                        const fire = createBox(0.15, 0.1, 0.15, MATERIALS.gold, -0.3, 0.2, 0.35);
                        fire.userData = { anim: 'blink', speed: 0.2 };
                        group.add(fire);
                    }

                    if (tier >= 3) {
                        const anvil = createBox(0.2, 0.15, 0.1, MATERIALS.metal, 0.1, 0.075, 0.3);
                        group.add(anvil);

                        const hammerGroup = new THREE.Group();
                        hammerGroup.position.set(0.25, 0.25, 0.3);
                        hammerGroup.add(createBox(0.05, 0.2, 0.05, MATERIALS.wood, 0, 0, 0));
                        hammerGroup.add(createBox(0.1, 0.05, 0.05, MATERIALS.metal, 0, 0.1, 0));
                        hammerGroup.userData = { anim: 'hammer', speed: 0.1 };
                        hammerGroup.rotation.z = Math.PI / 4;
                        group.add(hammerGroup);
                    }
                    break;

                case 'well':
                    const wellBase = createCyl(0.3, 0.3, 0.3, MATERIALS.stone, 0, 0.15, 0, 0, 8);
                    group.add(wellBase);
                    const waterInside = createCyl(0.25, 0.25, 0.31, MATERIALS.water, 0, 0.15, 0, 0, 8);
                    group.add(waterInside);

                    if (tier >= 2) {
                        // Roof
                        group.add(createBox(0.1, 0.6, 0.1, MATERIALS.wood, 0.25, 0.4, 0));
                        group.add(createBox(0.1, 0.6, 0.1, MATERIALS.wood, -0.25, 0.4, 0));
                        const roof = createCone(0.5, 0.3, MATERIALS.roof, 0, 0.8, 0);
                        group.add(roof);
                    }
                    if (tier >= 3) {
                        // Bucket
                        const bucket = createCyl(0.1, 0.08, 0.15, MATERIALS.wood, 0, 0.4, 0);
                        bucket.userData = { anim: 'bounceY', speed: 0.15, range: 0.1 };
                        group.add(bucket);
                    }
                    break;

                case 'inn':
                    // L-shape main building 
                    group.add(createBox(0.7, 0.5, 0.4, MATERIALS.wall, 0, 0.25, -0.15));
                    group.add(createBox(0.4, 0.5, 0.5, MATERIALS.wall, 0.15, 0.25, 0.3));

                    // Roofs
                    const roof1 = createCone(0.8, 0.4, MATERIALS.roof, 0, 0.65, -0.15, Math.PI / 4);
                    roof1.scale.z = 0.5;
                    group.add(roof1);

                    if (tier >= 2) {
                        // 2nd floor on main part
                        group.add(createBox(0.7, 0.4, 0.4, MATERIALS.wall, 0, 0.7, -0.15));
                        const roof2 = createCone(0.8, 0.5, MATERIALS.roof, 0, 1.1, -0.15, Math.PI / 4);
                        roof2.scale.z = 0.5;
                        // remove old roof1 (complex to remove, just cover it or let it be)
                        group.add(roof2);

                        // Sign
                        const sign = createBox(0.3, 0.15, 0.05, MATERIALS.wood, -0.3, 0.4, 0.1);
                        sign.rotation.y = -0.3;
                        group.add(sign);
                    }

                    if (tier >= 3) {
                        // Extension / Stable
                        group.add(createBox(0.4, 0.3, 0.3, MATERIALS.wood, -0.4, 0.15, 0.2));
                        const horse = createBox(0.1, 0.1, 0.2, MATERIALS.dirt, -0.4, 0.1, 0.2);
                        group.add(horse);
                    }
                    break;

                case 'clocktower':
                    const towerH = tier >= 3 ? 1.8 : tier >= 2 ? 1.4 : 1.0;
                    group.add(createBox(0.4, towerH, 0.4, MATERIALS.stone, 0, towerH / 2, 0));

                    // Clock face
                    const clockY = towerH - 0.2;
                    group.add(createBox(0.42, 0.42, 0.1, MATERIALS.white, 0, clockY, 0));
                    const hand = createBox(0.05, 0.2, 0.05, MATERIALS.dark, 0, clockY, 0.06);
                    hand.userData = { anim: 'rotateZ', speed: 0.1 };
                    group.add(hand);

                    // Roof
                    const towerRoof = createCone(0.5, 0.6, MATERIALS.dark, 0, towerH + 0.3, 0);
                    group.add(towerRoof);

                    if (tier >= 3) {
                        // Decorative base
                        group.add(createBox(0.6, 0.2, 0.6, MATERIALS.stone, 0, 0.1, 0));
                    }
                    break;

                case 'forest':
                    // Forest Area (1x2). Slave tile at Z+3.0.
                    const addTree = (tx, tz, s) => {
                        const trunk = createCyl(0.1 * s, 0.15 * s, 0.5 * s, MATERIALS.wood, tx, 0.25 * s, tz);
                        group.add(trunk);
                        const l1 = createCone(0.4 * s, 0.6 * s, MATERIALS.darkLeaf, tx, 0.6 * s, tz);
                        group.add(l1);
                        const l2 = createCone(0.3 * s, 0.5 * s, MATERIALS.darkLeaf, tx, 0.9 * s, tz);
                        group.add(l2);
                    };

                    // Cabin at Master center
                    group.add(createBox(0.8, 0.5, 0.7, MATERIALS.wood, 0, 0.25, 0.2));
                    const cabinRoof = createCone(0.9, 0.5, MATERIALS.roof, 0, 0.7, 0.2, Math.PI / 4);
                    cabinRoof.scale.z = 0.8;
                    group.add(cabinRoof);

                    // Scatter trees
                    // Master area
                    addTree(-0.8, -0.8, 0.9);
                    addTree(0.8, -0.6, 0.8);
                    addTree(0.6, 0.8, 0.7);

                    // Slave area (z around 3.0)
                    addTree(0, 3.0, 1.2);
                    addTree(-0.8, 2.5, 0.9);
                    addTree(0.8, 2.5, 0.8);
                    addTree(-0.7, 3.5, 0.7);
                    addTree(0.7, 3.6, 0.8);

                    if (tier >= 2) {
                        addTree(-0.4, 1.5, 0.6); // Gap
                        addTree(0.4, 1.8, 0.7);
                        addTree(0.9, 3.0, 0.6);
                    }
                    if (tier >= 3) {
                        addTree(-0.9, 3.0, 0.6);
                        addTree(0, -1.2, 0.6);
                    }
                    break;
            }
            return group;
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            const time = Date.now() * 0.001;

            tileMeshes.forEach((t, i) => {
                t.particles.update();

                if (t.buildingGroup.visible) {
                    t.buildingGroup.traverse((obj) => {
                        if (obj.userData && obj.userData.anim) {
                            const data = obj.userData;
                            switch (data.anim) {
                                case 'sway':
                                    obj.rotation.z = Math.sin(time * data.speed + data.offset) * 0.1;
                                    break;
                                case 'rotateY':
                                    obj.rotation.y += data.speed;
                                    break;
                                case 'rotateZ':
                                    obj.rotation.z -= data.speed;
                                    break;
                                case 'spinX':
                                    obj.rotation.x += data.speed;
                                    break;
                                case 'blink':
                                    obj.visible = Math.sin(time * 10 * data.speed) > 0;
                                    break;
                                case 'bounceY':
                                    obj.position.y = 0.35 + Math.abs(Math.sin(time * 5)) * data.range;
                                    break;
                                case 'shuttleX':
                                    obj.position.x = Math.sin(time * data.speed * 20) * data.range;
                                    break;
                                case 'sawMove':
                                    obj.position.z = Math.sin(time * 5) * 0.15;
                                    break;
                                case 'hammer':
                                    const cycle = (time * 3) % Math.PI;
                                    obj.rotation.z = Math.PI / 4 + Math.sin(cycle) * Math.PI / 4;
                                    break;
                                case 'smoke':
                                    if (Math.random() < 0.05) {
                                    }
                                    break;
                                case 'hammerWork':
                                    obj.rotation.z = -Math.PI / 4 + Math.abs(Math.sin(time * 10)) * 1.5;
                                    break;
                            }
                        }
                    });
                }
            });

            pedestrians.forEach(p => p.update());
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
            updateOverlayPositions();
        }

        function updateOverlayPositions() {
            if (!camera) return;
            const width = window.innerWidth;
            const height = window.innerHeight;
            const widthHalf = width / 2;
            const heightHalf = height / 2;

            tileMeshes.forEach((t, i) => {
                const pos = t.mesh.position.clone();

                // „Ç¢„Ç§„Ç≥„É≥È´ò„ÅïË™øÊï¥ÔºàÂúüÂè∞ÂâäÈô§„Å´‰º¥„ÅÑÂ∞ë„Åó‰∏ã„Åí„ÇãÔºâ
                if (gameState.tiles[i] && !gameState.tiles[i].unlocked) {
                    pos.y += 0.5;
                } else {
                    pos.y += 1.0;
                }

                pos.project(camera);

                const x = (pos.x * widthHalf) + widthHalf;
                const y = -(pos.y * heightHalf) + heightHalf;

                // ÁßªÂãï„É¢„Éº„Éâ‰∏≠„ÅÆ„Éè„Ç§„É©„Ç§„Éà
                if (moveMode.active) {
                    if (moveMode.sourceIndex === i) {
                        t.overlayEl.innerHTML = `<div style="background:rgba(231, 76, 60, 0.9); color:white; padding:5px 10px; border-radius:15px; font-weight:bold; font-size:0.8em; box-shadow:0 0 10px rgba(231, 76, 60, 0.5);">ÁßªÂãïÂÖÉ</div>`;
                        t.overlayEl.style.display = 'flex';
                    } else if (!t.overlayEl.innerHTML && t.mesh.visible && gameState.tiles[i].unlocked) {
                        // ‰Ωï„ÇÇ„Å™„ÅÑÂ†¥ÊâÄÔºàÁßªÂãïÂÖàÂÄôË£úÔºâ„Å´„Ç¨„Ç§„Éâ„ÇíË°®Á§∫„Åï„Åõ„Åü„ÅÑÂ†¥Âêà
                        // „Åì„Åì„Åß„ÅØ„Ç∑„É≥„Éó„É´„Å´„Åô„Çã„Åü„ÇÅ„ÄÅ„ÇΩ„Éº„ÇπÈÅ∏ÊäûÂæå„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑÔºà„ÇØ„É™„ÉÉ„ÇØ„ÅßÂèçÂøú„Åï„Åõ„ÇãÔºâ
                    }
                }

                if (x < -100 || x > width + 100 || y < -100 || y > height + 100) {
                    t.overlayEl.style.display = 'none';
                } else {
                    t.overlayEl.style.display = 'flex';
                    t.overlayEl.style.left = `${x}px`;
                    t.overlayEl.style.top = `${y}px`;
                }
            });
        }

        function sync3DState() {
            const reqRank = getRequiredRankForExpansion();

            gameState.tiles.forEach((tile, i) => {
                const tObj = tileMeshes[i];
                const mesh = tObj.mesh; // ÈÄèÊòé„Éí„ÉÉ„Éà„Éú„ÉÉ„ÇØ„Çπ
                const overlay = tObj.overlayEl;
                const ground = tObj.groundMesh;

                if (!tile.unlocked) {
                    // Êú™ÈñãÊãìÂú∞
                    ground.material = MATERIALS.grassLocked;
                    tObj.buildingGroup.visible = true;
                    tObj.particles.active = false;

                    const stateKey = `wild`;
                    if (tObj.currentType !== stateKey) {
                        while (tObj.buildingGroup.children.length > 0) {
                            tObj.buildingGroup.remove(tObj.buildingGroup.children[0]);
                        }
                        const newModel = createBuildingMesh('wild', 0);
                        tObj.buildingGroup.add(newModel);
                        tObj.currentType = stateKey;
                    }

                    const canUnlock = gameState.rank >= reqRank;
                    if (canUnlock) {
                        overlay.innerHTML = `<div class="lock-icon">üîí</div>`;
                    } else {
                        overlay.innerHTML = "";
                    }
                } else {
                    // ÈñãÊãìÂú∞ÔºàÁü≥Áï≥Ôºâ
                    ground.material = MATERIALS.cobblestone;

                    if (tile.type) {
                        tObj.buildingGroup.visible = true;
                        const isBuilding = !!tile.finishTime;
                        const stateKey = `${tile.type}_${tile.level}_${isBuilding ? 'b' : ''}`;
                        if (tObj.currentType !== stateKey) {
                            while (tObj.buildingGroup.children.length > 0) {
                                tObj.buildingGroup.remove(tObj.buildingGroup.children[0]);
                            }

                            // Lv0(Êñ∞Ë¶è)„Å™„ÇâÂª∫Áâ©„Å™„Åó„ÄÅLv1‰ª•‰∏ä„Å™„Çâ„Åù„ÅÆ„É¨„Éô„É´„ÅÆÂª∫Áâ©„ÇíË°®Á§∫
                            if (tile.level > 0) {
                                const newModel = createBuildingMesh(tile.type, tile.level);
                                tObj.buildingGroup.add(newModel);
                            }

                            // Â∑•‰∫ã‰∏≠„Å™„Çâ„Ç∑„Éº„Éà„Å®‰ΩúÊ•≠Âì°„ÇíËøΩÂä†
                            if (isBuilding) {
                                const construction = createConstructionSite();
                                tObj.buildingGroup.add(construction);
                            }

                            tObj.currentType = stateKey;
                        }

                        // ÂõûËª¢„ÅÆÈÅ©Áî® (0, 1, 2, 3 -> 0, -90, -180, -270)
                        if (tile.rotation) {
                            tObj.buildingGroup.rotation.y = -Math.PI / 2 * tile.rotation;
                        } else {
                            tObj.buildingGroup.rotation.y = 0;
                        }

                        if (tile.finishTime) {
                            tObj.particles.active = true;
                            const remaining = Math.max(0, (tile.finishTime - Date.now()));
                            const total = getBuildTime(tile.type, tile.level);
                            const percent = Math.min(100, Math.max(0, 100 - (remaining / total * 100)));

                            overlay.innerHTML = `
                            <div class="tile-timer">${formatTimeShort(remaining / 1000)}</div>
                            <div class="progress-bar-container"><div class="progress-fill" style="width:${percent}%"></div></div>
                        `;
                        } else {
                            tObj.particles.active = false;

                            let content = "";
                            let hasResource = false;
                            let maxRes = ""; let maxVal = 0;
                            const canCollect = (Date.now() - (tile.lastCollectTime || 0)) >= CONFIG.collectCooldown;

                            if (tile.stored && canCollect) {
                                for (let r in tile.stored) {
                                    if (tile.stored[r] >= 1) {
                                        hasResource = true;
                                        if (tile.stored[r] > maxVal) { maxVal = tile.stored[r]; maxRes = r; }
                                    }
                                }
                            }
                            if (hasResource) {
                                const icon = (maxRes == 'money' ? 'üí∞' : maxRes == 'food' ? 'üåæ' : maxRes == 'wood' ? 'üå≤' : maxRes == 'stone' ? 'ü™®' : maxRes == 'iron' ? 'üî©' : 'üíß');
                                content = `<div class="harvest-bubble" onclick="collectResourceUI(${i}, event)">${icon}</div>`;
                            }
                            overlay.innerHTML = content;
                        }
                    } else {
                        tObj.buildingGroup.visible = false;
                        tObj.particles.active = false;
                        tObj.currentType = null;
                        overlay.innerHTML = "";
                    }
                }

                // ÈÅ∏ÊäûÊôÇ„ÅÆ„Éè„Ç§„É©„Ç§„Éà (Âú∞Èù¢„ÇíÂÖâ„Çâ„Åõ„Çã)
                let isHighlight = (selectedTileIndex === i) || (moveMode.active && moveMode.sourceIndex === i);

                if (isHighlight) {
                    // „Éû„ÉÜ„É™„Ç¢„É´„ÅåÂÖ±Êúâ„Åï„Çå„Å¶„ÅÑ„Çã„ÅÆ„Åß‰∏ÄÊôÇÁöÑ„Å´„ÇØ„É≠„Éº„É≥„Åó„Å¶ÂÖâ„Çâ„Åõ„Çã
                    // Ê≥®ÊÑè: „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ„ÅÆ„Åü„ÇÅ„Å´„ÅØÂà•ÈÄîSelectionBox„Çí‰Ωø„ÅÜ„ÅÆ„ÅåËâØ„ÅÑ„Åå„ÄÅÁ∞°ÊòìÂÆüË£Ö„Å®„Åó„Å¶
                    if (ground.material.uuid === MATERIALS.cobblestone.uuid || ground.material.uuid === MATERIALS.grassLocked.uuid) {
                        ground.material = ground.material.clone();
                    }
                    if (moveMode.active && moveMode.sourceIndex === i) {
                        ground.material.emissive.setHex(0xe74c3c); // Ëµ§„ÅèÂÖâ„Çâ„Åõ„ÇãÔºàÁßªÂãïÂÖÉÔºâ
                    } else {
                        ground.material.emissive.setHex(0x3498db); // Èùí„ÅèÂÖâ„Çâ„Åõ„ÇãÔºàÈÄöÂ∏∏ÈÅ∏ÊäûÔºâ
                    }
                    ground.material.emissiveIntensity = 0.4;
                } else {
                    // ÂÖâ„Å£„Å¶„ÅÑ„Å™„ÅÑÁä∂ÊÖã„Å´Êàª„ÅôÔºàÂÖ±Êúâ„Éû„ÉÜ„É™„Ç¢„É´„ÇíÂÜçÂâ≤„ÇäÂΩì„Å¶Ôºâ
                    if (tile.unlocked && ground.material.uuid !== MATERIALS.cobblestone.uuid) {
                        ground.material = MATERIALS.cobblestone;
                    } else if (!tile.unlocked && ground.material.uuid !== MATERIALS.grassLocked.uuid) {
                        ground.material = MATERIALS.grassLocked;
                    }
                }
            });
        }

        function gameLogicLoop() {
            const now = Date.now();
            let dirty = false;

            // „Ç∞„É≠„Éº„Éê„É´„Éê„Éï„ÅÆË®àÁÆó (ÊôÇË®àÂ°î)
            let globalSpeedMultiplier = 1.0;
            const clockTowers = gameState.tiles.filter(t => t.type === 'clocktower' && !t.finishTime && t.level > 0);
            clockTowers.forEach(t => {
                // Lv1: 2%, LvUP: +0.1%
                const bonus = 0.02 + (t.level - 1) * 0.001;
                globalSpeedMultiplier += bonus;
            });

            gameState.tiles.forEach((tile, i) => {
                if (tile.unlocked) {
                    if (tile.finishTime && now >= tile.finishTime) {
                        tile.level++;
                        tile.finishTime = null;
                        const xp = Math.floor(getBuildTime(tile.type, tile.level - 1) / 1000);
                        addXP(xp);
                        dirty = true;
                        if (selectedTileIndex !== null) updatePanelUI();
                    }

                    if (tile.type && tile.level > 0 && !tile.finishTime) {
                        const b = BUILDINGS[tile.type];
                        if (!b) return; // Safety for slave tiles

                        // ÁîüÁî£Âäõ„ÅÆË®àÁÆó
                        // „Éô„Éº„ÇπË®àÁÆó
                        let multiplier = globalSpeedMultiplier;

                        // 1. ‰∫ïÊà∏„ÅÆ„Éê„Éï (Áïë„ÅÆÂë®Âõ≤„Å´‰∫ïÊà∏„Åå„ÅÇ„Çã„Åã)
                        if (tile.type === 'farm') {
                            const adj = getAdjacentTiles(i);
                            const maxWellLevel = adj.reduce((max, t) => {
                                if (t && t.type === 'well' && t.level > 0 && !t.finishTime) {
                                    return Math.max(max, t.level);
                                }
                                return max;
                            }, 0);

                            if (maxWellLevel > 0) {
                                // Lv1: 1.3ÂÄç, +0.02/Lv
                                const bonus = 0.3 + (maxWellLevel - 1) * 0.02;
                                multiplier *= (1 + bonus);
                            }
                        }

                        // 2. ÂÆøÂ±ã„ÅÆÁ®ºÂÉçÊù°‰ª∂ (Â∏ÇÂ†¥„Å®Ê∞ëÂÆ∂„ÅåÈö£Êé•)
                        if (tile.type === 'inn') {
                            const adj = getAdjacentTiles(i);
                            const hasMarket = adj.some(t => t && t.type === 'market');
                            const hasHouse = adj.some(t => t && t.type === 'house');
                            if (!hasMarket || !hasHouse) {
                                multiplier = 0; // Êù°‰ª∂„ÇíÊ∫Ä„Åü„Åï„Å™„ÅÑ„Å®Á®ºÂÉç„Åó„Å™„ÅÑ
                            }
                        }

                        // 3. Ê£Æ„ÅÆ„Ç∑„Éä„Ç∏„Éº (‰ºêÊé°ÊâÄÈö£Êé•)
                        if (tile.type === 'forest') {
                            const adj = getAdjacentTiles(i);
                            // Add slave neighbors
                            const slaveOffset = (tile.rotation % 2 === 0) ? gameState.gridSize : 1;
                            const slaveIdx = i + slaveOffset;
                            if (gameState.tiles[slaveIdx] && gameState.tiles[slaveIdx].masterIndex === i) {
                                const slaveAdj = getAdjacentTiles(slaveIdx);
                                slaveAdj.forEach(t => adj.push(t));
                            }

                            // Unique neighbors (filter duplicates and self/slave)
                            const unique = [...new Set(adj)];
                            const lumberCount = unique.filter(t => t && t.type === 'lumber' && t.level > 0 && !t.finishTime).length;

                            if (lumberCount > 0) {
                                multiplier *= (1 + 0.2 * lumberCount);
                            }
                        }

                        const caps = getStorageCapacity(tile.type, tile.level);
                        for (let r in b.prod) {
                            if (b.prod[r] > 0) {
                                // multiplier„ÇíÈÅ©Áî®
                                const rawAmount = b.prod[r] * tile.level * Math.pow(1.05, tile.level - 1);
                                const amount = rawAmount * multiplier; // per second

                                // ‰øùÂ≠òÁî®„Å´ amount „ÇíÁßíÊèõÁÆó„Åß„ÅØ„Å™„Åè„ÄÅ„Éï„É¨„Éº„É†(loop)ÊèõÁÆó„Åô„Çã„Å™„Çâ„Åì„Åì„ÅßÂâ≤„ÇãÂøÖË¶Å„ÅØ„Å™„ÅÑ„Åå
                                // ÂÖÉ„ÅÆ„É≠„Ç∏„ÉÉ„ÇØ: if(now % 1000 < 100) „ÅßÂëº„Å∞„Çå„Çã„Çè„Åë„Åß„ÅØ„Å™„ÅÑ„ÄÇsetInterval 1000ms „ÅßÂëº„Å∞„Çå„Çã„ÄÇ
                                // „Å™„ÅÆ„Åß amount „ÅØ 1Áßí„ÅÇ„Åü„Çä„ÅÆÁîüÁî£Èáè„Åù„ÅÆ„Åæ„Åæ„ÅßOK„ÄÇ

                                if (!tile.stored[r]) tile.stored[r] = 0;
                                if (tile.stored[r] < caps[r]) {
                                    tile.stored[r] = Math.min(caps[r], tile.stored[r] + amount);
                                    if (Math.floor(tile.stored[r]) >= 1) dirty = true;
                                }
                            }
                        }
                    }
                }
            });

            if (dirty || (now % 1000 < 100)) {
                sync3DState();
            }
            updateHeader();
        }

        function onPointerDown(event) {
            pointerDownPos.set(event.clientX, event.clientY);
            lastPointerPos.set(event.clientX, event.clientY);
            isDragging = false;

            if (event.button === 0 || event.pointerType === 'touch') {
                isPanning = true;
            }
        }

        function onPointerMove(event) {
            if (!isDragging && (Math.abs(event.clientX - pointerDownPos.x) > 5 || Math.abs(event.clientY - pointerDownPos.y) > 5)) {
                isDragging = true;
            }
            if (isPanning) {
                const deltaX = event.clientX - lastPointerPos.x;
                const deltaY = event.clientY - lastPointerPos.y;
                lastPointerPos.set(event.clientX, event.clientY);

                if (touchStartDist > 0) return;

                moveCamera(deltaX, deltaY);
            }
        }

        function onPointerUp(event) {
            isPanning = false;

            if (isDragging) return;

            event.preventDefault();

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const targetObjects = tileMeshes.map(t => t.mesh);
            const intersects = raycaster.intersectObjects(targetObjects, true);

            if (intersects.length > 0) {
                let target = intersects[0].object;
                while (target && target.userData.index === undefined && target.parent) {
                    target = target.parent;
                }

                if (target && target.userData.index !== undefined) {
                    const idx = target.userData.index;

                    // ÁßªÂãï„É¢„Éº„Éâ„ÅÆÂá¶ÁêÜ
                    if (moveMode.active) {
                        handleMoveInput(idx);
                        return;
                    }

                    const collected = collectResource(idx);
                    if (!collected) {
                        selectTile(idx);
                    }
                }
            } else {
                // ËÉåÊôØ„ÇØ„É™„ÉÉ„ÇØ„Å™„Å©„Åß„Éë„Éç„É´„ÇíÈñâ„Åò„ÇãÔºàÁßªÂãï„É¢„Éº„Éâ‰ª•Â§ñÔºâ
                if (!moveMode.active) {
                    closePanel();
                }
            }
        }

        // --- Move Mode Logic ---
        window.startMoveMode = function () {
            closeModal('modal-menu');
            closePanel();
            moveMode.active = true;
            moveMode.sourceIndex = null;

            document.getElementById('action-mode-bar').style.display = 'flex';
            document.getElementById('action-mode-text').innerText = "ÁßªÂãï„Åô„ÇãÊñΩË®≠„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ";

            sync3DState(); // „Éè„Ç§„É©„Ç§„ÉàËß£Èô§„Å™„Å©
        };

        window.actRotate = function () {
            if (moveMode.sourceIndex === null) return;
            const tile = gameState.tiles[moveMode.sourceIndex];
            if (!tile.rotation) tile.rotation = 0;
            tile.rotation = (tile.rotation + 1) % 4;
            sync3DState();
        };

        window.cancelMoveMode = function () {
            moveMode.active = false;
            moveMode.sourceIndex = null;
            document.getElementById('action-mode-bar').style.display = 'none';
            document.getElementById('action-rotate-btn').style.display = 'none'; // Hide rotate button
            sync3DState();
        };

        function handleMoveInput(index) {
            const tile = gameState.tiles[index];

            // Êú™ÈñãÊãìÂú∞„ÅØÂØæË±°Â§ñ
            if (!tile.unlocked) {
                showToast("Êú™ÈñãÊãìÂú∞„ÅØÊìç‰Ωú„Åß„Åç„Åæ„Åõ„Çì");
                return;
            }

            // Redirect slave to master
            if (tile.type && tile.type.endsWith('_part') && tile.masterIndex !== undefined) {
                handleMoveInput(tile.masterIndex);
                return;
            }

            if (moveMode.sourceIndex === null) {
                // „ÇΩ„Éº„ÇπÈÅ∏ÊäûÔºàÊñΩË®≠„Åå„ÅÇ„ÇãÂ†¥ÊâÄ„ÅÆ„ÅøÔºâ
                if (!tile.type && !tile.finishTime) {
                    showToast("ÁßªÂãï„Åï„Åõ„ÇãÊñΩË®≠„Åå„ÅÇ„Çä„Åæ„Åõ„Çì");
                    return;
                }

                // Prevent moving multi-tile
                const size = getBuildingSize(tile.type);
                // Note: getBuildingSize returns {w,h}. If simple building, returns {w:1,h:1}.
                // Forest returns {w:1,h:2} (static). But wait, existing building might be rotated?
                // getBuildingSize helper reads from BUILDINGS config, which is static.
                // It returns the base dimensions.
                // If w>1 or h>1, it's multi-tile.
                if (size.w > 1 || size.h > 1) {
                    showToast("Â§ßÂûãÊñΩË®≠„ÅØÁßªÂãï„Åß„Åç„Åæ„Åõ„Çì(Â£≤Âç¥‚ÜíÂª∫Áõ¥„ÅÆ„Åø)");
                    return;
                }

                moveMode.sourceIndex = index;
                document.getElementById('action-mode-text').innerText = "ÁßªÂãïÂÖà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ";
                document.getElementById('action-rotate-btn').style.display = 'block'; // Show rotate button
                sync3DState(); // „Éè„Ç§„É©„Ç§„ÉàÊõ¥Êñ∞
            } else {
                // „Çø„Éº„Ç≤„ÉÉ„ÉàÈÅ∏Êäû
                if (moveMode.sourceIndex === index) {
                    // Âêå„ÅòÂ†¥ÊâÄ„ÇíÈÅ∏Êäû -> „Ç≠„É£„É≥„Çª„É´ÔºàÈÅ∏ÊäûËß£Èô§Ôºâ
                    moveMode.sourceIndex = null;
                    document.getElementById('action-mode-text').innerText = "ÁßªÂãï„Åô„ÇãÊñΩË®≠„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ";
                    document.getElementById('action-rotate-btn').style.display = 'none'; // Hide rotate button
                    sync3DState();
                    return;
                }

                // „Çø„Éº„Ç≤„ÉÉ„ÉàÈÅ∏Êäû
                if (moveMode.sourceIndex === index) {
                    // Âêå„ÅòÂ†¥ÊâÄ„ÇíÈÅ∏Êäû -> „Ç≠„É£„É≥„Çª„É´ÔºàÈÅ∏ÊäûËß£Èô§Ôºâ
                    moveMode.sourceIndex = null;
                    document.getElementById('action-mode-text').innerText = "ÁßªÂãï„Åô„ÇãÊñΩË®≠„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ";
                    document.getElementById('action-rotate-btn').style.display = 'none'; // Hide rotate button
                    sync3DState();
                    return;
                }

                // ÁßªÂãïÂÆüË°å (Swap)
                swapTiles(moveMode.sourceIndex, index);

                // „É¢„Éº„ÉâÁµÇ‰∫Ü
                cancelMoveMode();
                showToast("ÊñΩË®≠„ÇíÁßªÂãï„Åó„Åæ„Åó„ÅüÔºÅ");
            }
        }

        function swapTiles(idx1, idx2) {
            const t1 = gameState.tiles[idx1];
            const t2 = gameState.tiles[idx2];

            // ÂúüÂú∞(unlocked)‰ª•Â§ñ„ÅÆÂª∫Áâ©„Éá„Éº„Çø„Çí‰∫§Êèõ
            const temp = {
                type: t1.type,
                level: t1.level,
                finishTime: t1.finishTime,
                stored: t1.stored,
                lastCollectTime: t1.lastCollectTime,
                rotation: t1.rotation || 0
            };

            // t1 <- t2
            t1.type = t2.type;
            t1.level = t2.level;
            t1.finishTime = t2.finishTime;
            t1.stored = t2.stored;
            t1.lastCollectTime = t2.lastCollectTime;
            t1.rotation = t2.rotation || 0;

            // t2 <- temp
            t2.type = temp.type;
            t2.level = temp.level;
            t2.finishTime = temp.finishTime;
            t2.stored = temp.stored;
            t2.lastCollectTime = temp.lastCollectTime;
            t2.rotation = temp.rotation;

            saveGame();
            sync3DState();
        }

        // „Ç≥„Çπ„ÉàË°®Á§∫Áî®„Éò„É´„Éë„ÉºÔºà‰∏çË∂≥ÂàÜ„ÇíËµ§Â≠ó„Å´„Åô„ÇãÔºâ
        function formatCostWithColor(cost) {
            let html = [];
            for (let r in cost) {
                if (cost[r] > 0) {
                    const val = cost[r];
                    const has = gameState.resources[r] || 0;
                    const icon = (r == 'money' ? 'üí∞' : r == 'food' ? 'üåæ' : r == 'wood' ? 'üå≤' : r == 'stone' ? 'ü™®' : r == 'iron' ? 'üî©' : 'üíß');

                    if (has < val) {
                        html.push(`<span style="color:red; font-weight:bold;">${icon}${val.toLocaleString()}</span>`);
                    } else {
                        html.push(`${icon}${val.toLocaleString()}`);
                    }
                }
            }
            return html.join(' ');
        }

        // ÊñΩË®≠ÂäπÊûú„ÅÆHTMLÁîüÊàêÔºàUtilityÊñΩË®≠ÂØæÂøúÔºâ
        function getBuildingEffectHtml(type, level, nextLevel = null) {
            const b = BUILDINGS[type];
            let html = "";

            // Helper to generate text for a single level
            const getEffectText = (lvl) => {
                if (lvl === 0) return "ÂäπÊûú„Å™„Åó";

                if (type === 'well') {
                    // Ê∞¥ÁîüÁî£ + Ëæ≤Â†¥„Éê„Éï
                    const buffVal = 1.3 + (lvl - 1) * 0.02;
                    let parts = [`Èö£Êé•Áïëx${buffVal.toFixed(2)}`];

                    // Ê∞¥ÁîüÁî£
                    if (b.prod.water) {
                        const waterVal = b.prod.water * lvl * Math.pow(1.05, lvl - 1);
                        parts.push(`üíß${waterVal.toFixed(1)}/s`);
                    }
                    return parts.join(' / ');
                } else if (type === 'clocktower') {
                    // 2.0 + (lvl-1)*0.1
                    const val = 2.0 + (lvl - 1) * 0.1;
                    return `ÂÖ®‰ΩìÈÄüÂ∫¶ +${val.toFixed(1)}%`;
                } else if (type === 'inn') {
                    // „ÅäÈáëÁîüÁî£ + Êù°‰ª∂
                    // const val = b.prod.money * lvl * Math.pow(1.05, lvl - 1);
                    // Inn„ÅÆË®àÁÆóÂºè: b.prod.money=60. 
                    const val = 60 * lvl * Math.pow(1.05, lvl - 1);
                    return `üí∞${val.toFixed(1)}/s <span style="font-size:0.8em">(Ë¶Å:Â∏ÇÂ†¥&Ê∞ëÂÆ∂)</span>`;
                } else {
                    // ‰∏ÄËà¨ÁîüÁî£ÊñΩË®≠
                    let parts = [];
                    for (let r in b.prod) {
                        if (b.prod[r] > 0) {
                            const val = b.prod[r] * lvl * Math.pow(1.05, lvl - 1);
                            const icon = (r == 'money' ? 'üí∞' : r == 'food' ? 'üåæ' : r == 'wood' ? 'üå≤' : r == 'stone' ? 'ü™®' : r == 'iron' ? 'üî©' : 'üíß');
                            parts.push(`${icon}${val.toFixed(1)}/s`);
                        }
                    }
                    return parts.length ? parts.join(' ') : 'ÂäπÊûú„Å™„Åó';
                }
            };

            const currText = getEffectText(level);

            if (nextLevel !== null) {
                const nextText = getEffectText(nextLevel);
                // Â§âÊõ¥ÈÉ®ÂàÜ„ÇíÂº∑Ë™ø
                // ÂçòÁ¥î„Å´ÊñáÂ≠óÂàóÂÖ®‰Ωì„ÇíÁü¢Âç∞„Åß„Å§„Å™„Åê (‰∫ïÊà∏„ÇÑÊôÇË®àÂ°î„ÅÆ„Çà„ÅÜ„Å´Êï∞ÂÄ§ÈÉ®ÂàÜ„Å†„Åë„ÅåÂ§â„Çè„ÇãÂ†¥Âêà„ÇÇÂê´„ÇÄ)

                // „Åü„Å†„Åó„ÄÅInn„ÇÑÈÄöÂ∏∏ÊñΩË®≠„ÅÆ„Çà„ÅÜ„Å´HTML„Çø„Ç∞„ÇíÂê´„ÇÄÂ†¥Âêà„ÅÆÊØîËºÉ„ÅØÂ∞ë„ÅóÂÜóÈï∑„Å´„Å™„Çã„Åå„ÄÅ„Ç∑„É≥„Éó„É´„Å´
                // "Current -> Next" „Å®„Åô„Çã
                return `<div>${currText} <span style="color:#2ecc71; font-weight:bold;">‚ûû ${nextText}</span></div>`;
            } else {
                return `<div>${currText}</div>`;
            }
        }

        function moveCamera(dx, dy) {
            if (!camera) return;

            const speed = 0.05 / camera.zoom;

            const vec = new THREE.Vector3();
            const quat = camera.quaternion.clone();

            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(quat);
            right.y = 0; right.normalize();

            const up = new THREE.Vector3(0, 1, 0).applyQuaternion(quat);
            up.y = 0; up.normalize();

            camera.position.addScaledVector(right, -dx * speed);
            camera.position.addScaledVector(up, dy * speed);
        }

        function setCameraZoom(val) {
            if (!camera) return;
            const minZoom = 0.5;
            const maxZoom = 2.5;
            camera.zoom = Math.max(minZoom, Math.min(maxZoom, val));
            camera.updateProjectionMatrix();
        }

        function onMouseWheel(event) {
            event.preventDefault();
            const zoomSpeed = 0.001;
            const newZoom = camera.zoom - event.deltaY * zoomSpeed;
            setCameraZoom(newZoom);
        }

        let touchStartDist = 0;
        let touchStartZoom = 1;

        function onTouchStart(event) {
            if (event.touches.length === 2) {
                isPanning = false;
                const dx = event.touches[0].pageX - event.touches[1].pageX;
                const dy = event.touches[0].pageY - event.touches[1].pageY;
                touchStartDist = Math.sqrt(dx * dx + dy * dy);
                touchStartZoom = camera.zoom;
            }
        }

        function onTouchMove(event) {
            if (event.target === renderer.domElement) {
                event.preventDefault();
            }

            if (event.touches.length === 2) {
                const dx = event.touches[0].pageX - event.touches[1].pageX;
                const dy = event.touches[0].pageY - event.touches[1].pageY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (touchStartDist > 0) {
                    const scale = dist / touchStartDist;
                    setCameraZoom(touchStartZoom * scale);
                }
            }
        }

        function onTouchEnd(event) {
            if (event.touches.length < 2) {
                touchStartDist = 0;
            }
        }

        window.collectResourceUI = function (index, e) {
            // ÁßªÂãï„É¢„Éº„Éâ‰∏≠„ÅØË≥áÊ∫êÂõûÂèéUI„ÇíÁÑ°ÂäπÂåñÔºàË™§„Çø„ÉÉ„ÉóÈò≤Ê≠¢Ôºâ
            if (moveMode.active) return;

            e.stopPropagation();
            collectResource(index);
        };

        function selectTile(index) {
            const t = gameState.tiles[index];
            if (t && t.type && t.type.endsWith('_part') && t.masterIndex !== undefined) {
                selectTile(t.masterIndex);
                return;
            }
            selectedTileIndex = index;
            sync3DState();
            showPanel(index);
        }

        window.closePanel = function () {
            selectedTileIndex = null;
            document.getElementById('control-panel').classList.remove('active');
            sync3DState();
        };

        function formatTimeShort(s) { if (s < 60) return `${Math.floor(s)}s`; if (s < 3600) return `${Math.floor(s / 60)}m`; return `${Math.floor(s / 3600)}h`; }
        function formatTime(s) { if (s < 60) return `${Math.floor(s)}Áßí`; if (s < 3600) return `${Math.floor(s / 60)}ÂàÜ${Math.floor(s % 60)}Áßí`; return `${Math.floor(s / 3600)}ÊôÇÈñì`; }

        function getNextRankXP(r) {
            const base = r * 500;
            if (r >= 12) return base * 4 * 3;
            if (r >= 10) return base * 4;
            return base;
        }

        function getBuildTime(t, l) { const tl = l + 1; if (tl === 1) return BUILDINGS[t].baseTime; return Math.floor(BUILDINGS[t].baseTime * Math.pow(tl, 2.8)); }

        function getCost(t, l) {
            let m = Math.pow(1.6, l) * 1.5;
            if (l >= 10) m *= 10;
            const r = {};
            for (let k in BUILDINGS[t].cost) r[k] = Math.floor(BUILDINGS[t].cost[k] * m);
            return r;
        }

        function getStorageCapacity(t, l) { const b = BUILDINGS[t], s = CONFIG.storageHours * 3600, c = {}; for (let r in b.prod) if (b.prod[r] > 0) c[r] = b.prod[r] * l * Math.pow(1.05, l - 1) * s; return c; }

        function getExpandCost(r) {
            const reqRank = getRequiredRankForExpansion();
            const virtualUnlockedCount = reqRank + 2;

            let b = 500 * Math.pow(1.5, virtualUnlockedCount - 4);

            if (reqRank >= 6) b *= 20;

            let cost = {
                money: Math.floor(b),
                food: Math.floor(b * 0.5),
                wood: Math.floor(b * 0.3),
                stone: Math.floor(b * 0.1),
                iron: 0
            };

            if (reqRank >= 12) {
                cost.money *= 20;
                cost.food *= 20;
                cost.wood *= 5;
                cost.stone *= 5;
            }

            return cost;
        }

        function getRequiredRankForExpansion() {
            const unlockedCount = gameState.tiles.filter(t => t.unlocked).length;
            const baseReq = Math.max(2, unlockedCount - 2);

            if (baseReq <= 10) {
                return baseReq;
            } else {
                return 10 + (baseReq - 10) * 2;
            }
        }

        function checkAfford(c) { for (let k in c) if ((gameState.resources[k] || 0) < c[k]) return false; return true; }
        function payCost(c) { for (let k in c) gameState.resources[k] -= c[k]; updateHeader(); }
        function addXP(a) {
            gameState.xp += a;
            while (gameState.xp >= getNextRankXP(gameState.rank)) {
                gameState.xp -= getNextRankXP(gameState.rank);
                gameState.rank++;
                document.getElementById('levelup-rank').innerText = gameState.rank;
                document.getElementById('modal-levelup').style.display = 'flex';
                SoundManager.playSE('levelup');
            }
        }

        function getActiveBuilders() {
            return gameState.tiles.filter(t => t.finishTime !== null).length;
        }

        function getBuilderCost() {
            const current = gameState.maxBuilders;
            const target = current + 1;

            // 10‰∫∫ÁõÆ„Åæ„Åß„ÅØÈÄöÂ∏∏Ë®àÁÆó (20‰∏á * 1.5^(N-5))
            if (target <= 10) {
                const extra = Math.max(0, current - 4);
                return Math.floor(200000 * Math.pow(1.5, extra));
            }

            // 10‰∫∫ÁõÆ„ÅÆ„Ç≥„Çπ„ÉàÔºàÂü∫Ê∫ñÔºâ
            const cost10 = Math.floor(200000 * Math.pow(1.5, 5));

            // 11‰∫∫ÁõÆ„ÅØÂâçÂõû„ÅÆ100ÂÄç
            if (target === 11) {
                return cost10 * 100;
            }

            // 12‰∫∫ÁõÆ‰ª•Èôç„ÅØÂâçÂõû„ÅÆ3ÂÄç
            // C(N) = C(11) * 3^(N-11)
            const cost11 = cost10 * 100;
            return cost11 * Math.pow(3, target - 11);
        }

        function collectResource(index) {
            const t = gameState.tiles[index];
            if (!t || !t.stored) return false;

            const now = Date.now();
            if ((now - (t.lastCollectTime || 0)) < CONFIG.collectCooldown) {
                return false;
            }

            let total = 0, txt = "";
            for (let r in t.stored) {
                const val = Math.floor(t.stored[r]);
                if (val > 0) {
                    gameState.resources[r] += val;
                    t.stored[r] = 0;
                    total += val;
                    const icon = (r == 'money' ? 'üí∞' : r == 'food' ? 'üåæ' : r == 'wood' ? 'üå≤' : r == 'stone' ? 'ü™®' : r == 'iron' ? 'üî©' : 'üíß');
                    txt += `${icon}+${val} `;
                }
            }
            if (total > 0) {
                t.lastCollectTime = now;
                SoundManager.playSE('collect');
                saveGame(); // Âç≥Â∫ß„Å´‰øùÂ≠ò
                updateHeader();
                sync3DState();
                const overlay = tileMeshes[index].overlayEl;
                const el = document.createElement('div');
                el.className = 'float-text';
                el.innerText = txt;
                overlay.appendChild(el);
                setTimeout(() => el.remove(), 1000);
                return true;
            }
            return false;
        }

        function checkAndExpandWorld() {
            const allUnlocked = gameState.tiles.every(t => t.unlocked);
            if (allUnlocked) {
                expandWorldSize();
            }
        }

        function expandWorldSize() {
            const oldSize = gameState.gridSize;
            const newSize = oldSize + 1;
            const newTiles = [];

            for (let i = 0; i < newSize * newSize; i++) {
                const row = Math.floor(i / newSize);
                const col = i % newSize;

                if (row < oldSize && col < oldSize) {
                    const oldIdx = row * oldSize + col;
                    newTiles.push(gameState.tiles[oldIdx]);
                } else {
                    newTiles.push({
                        type: null, level: 0, finishTime: null,
                        unlocked: false,
                        stored: {},
                        lastCollectTime: 0
                    });
                }
            }

            gameState.tiles = newTiles;
            gameState.gridSize = newSize;

            createTiles();
            createSurroundingEnvironment(); // Áí∞Â¢ÉÂÜçÁîüÊàê
            showToast(`üéâ ‰∏ñÁïå„ÅåÂ∫É„Åå„Çä„Åæ„Åó„ÅüÔºÅ (${newSize}x${newSize})`);

            initPedestrians();
            saveGame();
        }

        function showPanel(index) {
            const tile = gameState.tiles[index];
            const p = document.getElementById('control-panel');
            const content = document.getElementById('panel-content');
            p.classList.add('active');
            updatePanelUI();
        }

        function updatePanelUI() {
            if (selectedTileIndex === null) return;
            const tile = gameState.tiles[selectedTileIndex];
            const content = document.getElementById('panel-content');
            if (!content) return;

            if (!tile.unlocked) {
                const req = getRequiredRankForExpansion();
                const cost = getExpandCost(gameState.rank);
                const ok = gameState.rank >= req;
                const afford = checkAfford(cost);
                content.innerHTML = `
                <div style="text-align:center;">
                    <p><strong>Êú™ÈñãÊãì„ÅÆÂúüÂú∞</strong></p>
                    <div style="background:#eee; padding:10px; border-radius:5px; text-align:left; font-size:0.9em;">
                        Êù°‰ª∂: „É©„É≥„ÇØ${req} (${ok ? '‚úÖ' : '‚ùå'})<br>
                        Ë≤ªÁî®: ${formatCostWithColor(cost)}
                    </div>
                    <button class="action-btn" onclick="actExpand()" ${ok && afford ? '' : 'disabled'}>Êã°Âºµ</button>
                    ${!ok ? '<p style="color:red;font-size:0.8em">„É©„É≥„ÇØ‰∏çË∂≥</p>' : ''}
                </div>`;
                return;
            }

            if (!tile.type) {
                let html = "";
                if (getActiveBuilders() >= gameState.maxBuilders) {
                    html += `<div style="color:var(--danger-color); font-size:0.9em; font-weight:bold; margin-bottom:5px; text-align:center;">‚ö†Ô∏è Â∑•‰∫ã„Åå„ÅÑ„Å£„Å±„ÅÑ„Åß„ÅôÔºÅ</div>`;
                }

                if (gameState.inventory && gameState.inventory.length > 0) {
                    html += `<div class="inventory-section"><div class="inventory-title">üì¶ ‰øùÁÆ°Â∫´„Åã„ÇâÂÜçË®≠ÁΩÆ</div>`;
                    gameState.inventory.forEach((item, idx) => {
                        const b = BUILDINGS[item.type];
                        const timeSec = getBuildTime(item.type, item.level - 1) / 1000;
                        const canRestore = checkBuildingLimit(item.type);
                        const disabledAttr = canRestore ? '' : 'disabled';
                        const warnText = canRestore ? '' : '<span style="color:red; font-size:0.8em;">(‰∏äÈôêÂà∞ÈÅî)</span>';

                        html += `
                        <div class="building-item" style="background:#fff8e1;">
                            <div class="building-info">
                                <strong>${b.icon} ${b.name} (Lv.${item.level}) ${warnText}</strong>
                                <span class="res-cost">‚è≥${formatTime(timeSec)}</span>
                            </div>
                            <button onclick="actRestore(${idx})" style="background-color:#f39c12;" ${disabledAttr}>ÈÖçÁΩÆ</button>
                        </div>
                    `;
                    });
                    html += `</div><div class="inventory-title" style="margin-top:10px;">‚ú® Êñ∞Ë¶èÂª∫Ë®≠</div>`;
                }

                for (let k in BUILDINGS) {
                    const b = BUILDINGS[k];
                    const c = getCost(k, 0);
                    const afford = checkAfford(c);
                    // Use helper for color check
                    const costStr = formatCostWithColor(c);

                    const canBuild = checkBuildingLimit(k);
                    const disabledAttr = (afford && canBuild) ? '' : 'disabled';

                    let limitNum = 4;
                    if (['well', 'inn', 'clocktower'].includes(k)) limitNum = 2;

                    const limitText = canBuild ? '' : `<br><span style="color:red; font-size:0.8em;">‚ö†Ô∏è ‰∏äÈôê(${limitNum}„Å§)„Å´ÈÅî„Åó„Å¶„ÅÑ„Åæ„Åô</span>`;

                    html += `
                    <div class="building-item">
                        <div class="building-info">
                            <strong>${b.icon} ${b.name}</strong>
                            <p style="font-size:0.8em; color:#666; margin:2px 0;">${b.desc}</p>
                            <span class="res-cost">${costStr}</span>
                            <span class="res-cost">‚è≥${formatTime(getBuildTime(k, 0) / 1000)}</span>
                            ${limitText}
                        </div>
                        <button onclick="actBuild('${k}')" ${disabledAttr}>Âª∫Ë®≠</button>
                    </div>`;
                }
                content.innerHTML = html;
                return;
            }

            const b = BUILDINGS[tile.type];
            if (tile.finishTime) {
                const rem = Math.max(0, (tile.finishTime - Date.now()));

                const prodDiff = getBuildingEffectHtml(tile.type, tile.level, tile.level + 1);

                const c = getCost(tile.type, tile.level);
                let refund = [];
                for (let r in c) if (c[r] > 0) refund.push(`${(r == 'money' ? 'üí∞' : r == 'food' ? 'üåæ' : r == 'wood' ? 'üå≤' : r == 'stone' ? 'ü™®' : r == 'iron' ? 'üî©' : 'üíß')}${Math.floor(c[r] * 0.5).toLocaleString()}`);

                content.innerHTML = `
                <div style="text-align:center;">
                    <h3>${b.name} (Lv.${tile.level} ‚ûû ${tile.level + 1})</h3>
                    <div style="background:#f9f9f9; padding:5px; border-radius:5px; margin:5px 0; font-size:0.9em;">
                        <strong>Â∑•‰∫ãÂæå„ÅÆÊÄßËÉΩ:</strong>
                        ${prodDiff}
                    </div>
                    <h2 style="color:var(--accent-color)">${formatTime(rem / 1000)}</h2>
                    <p>Â∑•‰∫ã‰∏≠...</p>
                    <button class="action-btn store-btn" onclick="actStore()">üì¶ ÂõûÂèéÔºà‰øùÁÆ°Â∫´„Å∏Ôºâ</button>
                    <button class="action-btn" style="background-color:var(--danger-color); margin-top:5px;" onclick="actCancelBuild()">üö´ Â∑•‰∫ã‰∏≠Ê≠¢ (ËøîÈÇÑ: ${refund.join(' ')})</button>
                </div>`;
            } else {
                const next = tile.level + 1;
                const c = getCost(tile.type, tile.level);
                const afford = checkAfford(c);
                const caps = getStorageCapacity(tile.type, tile.level);
                // Use helper for upgrade cost
                const costStr = formatCostWithColor(c);

                const prodInfo = getBuildingEffectHtml(tile.type, tile.level);

                let storeInfo = "";
                for (let r in b.prod) if (b.prod[r] > 0) {
                    storeInfo += `<div>${(r == 'money' ? 'üí∞' : r == 'food' ? 'üåæ' : r == 'wood' ? 'üå≤' : r == 'stone' ? 'ü™®' : r == 'iron' ? 'üî©' : 'üíß')} ${Math.floor(tile.stored[r])}/${Math.floor(caps[r])}</div>`;
                }
                // If it's a utility building, storage might be empty, but that's fine. 
                // Wait, if it's well/clocktower, they don't have storage. 
                // Currently code assumes b.prod determines storage, but storage is actually mostly separate logic but often linked.
                // Well/Clocktower have b.prod={} so storeInfo will be empty loop. Correct.

                const buildersBusy = getActiveBuilders() >= gameState.maxBuilders;

                content.innerHTML = `
                <div style="text-align:center;">
                    <h3>${b.name} (Lv.${tile.level})</h3>
                    <p style="font-size:0.85em; color:#666; margin:0 0 10px 0;">${b.desc}</p>
                    <div style="background:#f0f0f0; padding:5px; border-radius:5px; margin-bottom:5px;">
                        <strong>ÁèæÂú®ÊÄßËÉΩ:</strong><br>${prodInfo}
                    </div>
                    ${storeInfo ? `<div style="background:#e8f4f8; padding:5px; border-radius:5px; margin-bottom:10px;">
                        <strong>Ë≤ØËîµÂ∫´:</strong><br>${storeInfo}
                    </div>` : ''}
                    <div style="text-align:left; font-size:0.9em; margin-bottom:5px;">
                         <strong>LvUPË≤ªÁî®:</strong> ${costStr}<br>
                         <strong>ÊôÇÈñì:</strong> ${formatTime(getBuildTime(tile.type, tile.level) / 1000)}
                    </div>
                    ${buildersBusy ? '<p style="color:red; font-size:0.9em;">‚ö†Ô∏è Â∑•‰∫ãÊû†„Åå„ÅÑ„Å£„Å±„ÅÑ„Åß„Åô</p>' : ''}
                    <button class="action-btn" onclick="actBuild('${tile.type}')" ${afford && !buildersBusy ? '' : 'disabled'}>„É¨„Éô„É´„Ç¢„ÉÉ„Éó</button>
                    <button class="action-btn store-btn" onclick="actStore()">üì¶ ÂõûÂèéÔºà‰øùÁÆ°Â∫´„Å∏Ôºâ</button>
                </div>`;
            }
        }

        // --- Multi-tile Helper Functions ---
        function getBuildingSize(type) {
            const b = BUILDINGS[type];
            return { w: b.w || 1, h: b.h || 1 };
        }

        function getGridPos(index) {
            const s = gameState.gridSize;
            return { x: index % s, y: Math.floor(index / s) };
        }

        function getIndexFromPos(x, y) {
            const s = gameState.gridSize;
            if (x < 0 || y < 0 || x >= s || y >= s) return -1;
            return y * s + x;
        }

        function checkPlacement(index, type, rot = 0) {
            const size = getBuildingSize(type);
            const w = (rot % 2 === 0) ? size.w : size.h;
            const h = (rot % 2 === 0) ? size.h : size.w;
            const origin = getGridPos(index);

            for (let dy = 0; dy < h; dy++) {
                for (let dx = 0; dx < w; dx++) {
                    const tx = origin.x + dx;
                    const ty = origin.y + dy;
                    const tidx = getIndexFromPos(tx, ty);
                    if (tidx === -1) return false; // Out of bounds

                    // Check occupancy
                    // Target tile (index) is assumed to be the one we clicked, so it's nominally "available" (checked by UI)
                    // But we must ensure other tiles are also available.
                    // Also, must ensure tiles are Unlocked.
                    const t = gameState.tiles[tidx];
                    if (!t.unlocked) return false;
                    if (t.type || t.finishTime) {
                        // If checking the origin tile itself, it's fine (we are building on it)
                        // But wait, if we are upgrading, this function is not called for size check usually.
                        // If new build, origin tile must be empty.
                        // The UI calls actBuild only on selectedTileIndex.
                        // We should ensure we don't overwrite existing stuff unless we mean to.
                        // For new build, all tiles must be empty.
                        return false;
                    }
                }
            }
            return true;
        }

        function setMultiTile(index, type, rot = 0) {
            const size = getBuildingSize(type);
            const w = (rot % 2 === 0) ? size.w : size.h;
            const h = (rot % 2 === 0) ? size.h : size.w;
            const origin = getGridPos(index);

            for (let dy = 0; dy < h; dy++) {
                for (let dx = 0; dx < w; dx++) {
                    const tidx = getIndexFromPos(origin.x + dx, origin.y + dy);
                    const t = gameState.tiles[tidx];
                    if (dx === 0 && dy === 0) {
                        // Master
                        t.type = type;
                        t.rotation = rot;
                        t.mas = true; // master flag
                    } else {
                        // Slave
                        t.type = type + '_part';
                        t.masterIndex = index;
                    }
                }
            }
        }

        function clearMultiTile(index) {
            const t = gameState.tiles[index];
            if (!t.type) return;

            // If slave, redirect to master
            if (t.type.endsWith('_part')) {
                // Should have been handled by caller, but safety check
                if (t.masterIndex !== undefined) clearMultiTile(t.masterIndex);
                return;
            }

            // Master: clear self and all parts
            // We need to know the size/rotation to find parts?
            // Or just scan? Scanning is slow.
            // Using currently stored rotation and type.
            const size = getBuildingSize(t.type);
            const rot = t.rotation || 0;
            const w = (rot % 2 === 0) ? size.w : size.h;
            const h = (rot % 2 === 0) ? size.h : size.w;
            const origin = getGridPos(index);

            for (let dy = 0; dy < h; dy++) {
                for (let dx = 0; dx < w; dx++) {
                    const tidx = getIndexFromPos(origin.x + dx, origin.y + dy);
                    if (tidx !== -1) {
                        const part = gameState.tiles[tidx];
                        part.type = null;
                        part.level = 0;
                        part.finishTime = null;
                        part.stored = {};
                        part.mas = undefined;
                        part.masterIndex = undefined;
                        part.rotation = 0;
                    }
                }
            }
        }

        window.actCancelBuild = function () {
            if (selectedTileIndex === null) return;
            const t = gameState.tiles[selectedTileIndex];
            if (!t.finishTime) return;

            if (!confirm("Â∑•‰∫ã„Çí‰∏≠Ê≠¢„Åó„Åæ„Åô„ÅãÔºü\nË≤ªÁî®„ÅÆ‰∏ÄÈÉ®(50%)„ÅåËøîÈÇÑ„Åï„Çå„Åæ„Åô„ÄÇ")) return;

            const c = getCost(t.type, t.level);
            let refundTxt = "";
            for (let r in c) {
                const amount = Math.floor(c[r] * 0.5);
                if (amount > 0) {
                    gameState.resources[r] += amount;
                    const icon = (r == 'money' ? 'üí∞' : r == 'food' ? 'üåæ' : r == 'wood' ? 'üå≤' : r == 'stone' ? 'ü™®' : r == 'iron' ? 'üî©' : 'üíß');
                    refundTxt += `${icon}+${amount.toLocaleString()} `;
                }
            }

            t.finishTime = null;
            if (t.level === 0) {
                clearMultiTile(selectedTileIndex);
            }
            SoundManager.playSE('cancel');

            saveGame();
            sync3DState();
            updatePanelUI();
            updateHeader();
            showToast(`Â∑•‰∫ã„Çí‰∏≠Ê≠¢„Åó„Åæ„Åó„Åü ${refundTxt}`);
        }

        window.actBuild = function (type) {
            if (selectedTileIndex === null) return;

            if (getActiveBuilders() >= gameState.maxBuilders) {
                showToast("‚ö†Ô∏è Â§ßÂ∑•„ÅåÂÖ®Âì°‰ΩúÊ•≠‰∏≠„Åß„Åô");
                return;
            }

            const t = gameState.tiles[selectedTileIndex];
            const lv = t.type === type ? t.level : 0;

            if (lv === 0) {
                if (!checkBuildingLimit(type)) {
                    showToast("‚ö†Ô∏è „Åì„ÅÆÊñΩË®≠„ÅØ„Åì„Çå‰ª•‰∏äÂª∫Ë®≠„Åß„Åç„Åæ„Åõ„Çì");
                    return;
                }

                // Forest unlock check
                if (type === 'forest' && gameState.rank < 20) {
                    showToast("‚ö†Ô∏è Ê£ÆÊûó„ÅØ„É©„É≥„ÇØ20„Åã„ÇâÂª∫Ë®≠ÂèØËÉΩ„Åß„Åô");
                    return;
                }

                // Check placement (assume rotation 0)
                if (!checkPlacement(selectedTileIndex, type, 0)) {
                    showToast("‚ö†Ô∏è ÈÖçÁΩÆ„Åß„Åç„Åæ„Åõ„Çì(„Çπ„Éö„Éº„Çπ‰∏çË∂≥/ÈöúÂÆ≥Áâ©)");
                    return;
                }
            }

            const c = getCost(type, lv);
            if (checkAfford(c)) {
                payCost(c);

                if (lv === 0) {
                    setMultiTile(selectedTileIndex, type, 0);
                }

                // Master tile properties
                t.finishTime = Date.now() + getBuildTime(type, lv);
                t.stored = {}; // Reset storage
                SoundManager.playSE('build');

                saveGame();
                sync3DState();
                updatePanelUI();
                updateHeader();
            }
        }

        window.actStore = function () {
            if (selectedTileIndex === null) return;
            const t = gameState.tiles[selectedTileIndex];
            if (!t.type) return;

            collectResource(selectedTileIndex);

            gameState.inventory.push({ type: t.type, level: t.level });

            clearMultiTile(selectedTileIndex);

            saveGame();
            sync3DState();
            updatePanelUI();
            updateHeader();
        };

        window.actRestore = function (invIndex) {
            if (selectedTileIndex === null) return;

            if (getActiveBuilders() >= gameState.maxBuilders) {
                showToast("‚ö†Ô∏è Â§ßÂ∑•„ÅåÂÖ®Âì°‰ΩúÊ•≠‰∏≠„Åß„Åô");
                return;
            }

            if (invIndex < 0 || invIndex >= gameState.inventory.length) return;

            const item = gameState.inventory[invIndex];

            if (!checkBuildingLimit(item.type)) {
                showToast("‚ö†Ô∏è „Åì„ÅÆÊñΩË®≠„ÅØ„Åì„Çå‰ª•‰∏äÈÖçÁΩÆ„Åß„Åç„Åæ„Åõ„Çì");
                return;
            }

            const t = gameState.tiles[selectedTileIndex];

            gameState.inventory.splice(invIndex, 1);

            t.type = item.type;
            t.level = Math.max(0, item.level - 1);
            t.finishTime = Date.now() + getBuildTime(item.type, t.level);
            t.stored = {};

            saveGame();
            sync3DState();
            updatePanelUI();
            updateHeader();
        };

        function getAdjacentTiles(index) {
            const size = gameState.gridSize;
            const row = Math.floor(index / size);
            const col = index % size;
            const adj = [];

            // ‰∏ä‰∏ãÂ∑¶Âè≥
            if (row > 0) adj.push(gameState.tiles[(row - 1) * size + col]);
            if (row < size - 1) adj.push(gameState.tiles[(row + 1) * size + col]);
            if (col > 0) adj.push(gameState.tiles[row * size + col - 1]);
            if (col < size - 1) adj.push(gameState.tiles[row * size + col + 1]);

            return adj;
        }

        window.actExpand = function () {
            if (selectedTileIndex === null) return;
            const c = getExpandCost(gameState.rank);
            if (checkAfford(c)) {
                payCost(c);
                gameState.tiles[selectedTileIndex].unlocked = true;
                saveGame();

                checkAndExpandWorld();

                sync3DState();
                updatePanelUI();
            }
        }

        window.openMenu = function () {
            const modal = document.getElementById('modal-menu');
            const content = document.getElementById('menu-content');

            const builderCost = getBuilderCost();
            const canBuyBuilder = gameState.resources.money >= builderCost;
            const currentUid = currentUser ? currentUser.uid : "Êú™Êé•Á∂ö(„Ç™„Éï„É©„Ç§„É≥)";

            const sharedUid = localStorage.getItem('kingdomBuilder_sharedId');
            const displayUid = sharedUid ? `${sharedUid} (ÈÄ£Êê∫‰∏≠)` : currentUid;

            content.innerHTML = `
            <div class="shop-item">
                <button class="action-btn" onclick="openBuildingList()" style="width:100%; margin-bottom:10px; background-color:#3498db;">
                    üìã ÊñΩË®≠‰∏ÄË¶ß (ÊâÄÊúâ)
                </button>
                <button class="action-btn" onclick="openCatalog()" style="width:100%; margin-bottom:10px; background-color:#9b59b6;">
                    üìñ Âª∫Ë®≠„Ç´„Çø„É≠„Ç∞
                </button>
            </div>

            <div class="shop-item">
                <button class="action-btn" onclick="startMoveMode()" style="width:100%; margin-bottom:10px; background-color:#f39c12;">
                    üèóÔ∏è ÊñΩË®≠„ÇíÁßªÂãï
                </button>
            </div>

            <div class="shop-item">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <div>
                        <strong>üë∑ Â§ßÂ∑•„ÅÆÂ¢óÂì°</strong><br>
                        <span style="font-size:0.9em; color:#666;">ÁèæÂú®„ÅÆ‰∫∫Êï∞: ${gameState.maxBuilders}‰∫∫</span>
                    </div>
                    <div style="text-align:right;">
                        <span style="font-size:1.1em; font-weight:bold; color:#e67e22;">üí∞${builderCost.toLocaleString()}</span>
                    </div>
                </div>
                <button class="action-btn" onclick="actBuyBuilder()" ${canBuyBuilder ? '' : 'disabled'}>
                    Ë≥ºÂÖ•„Åô„Çã
                </button>
            </div>
            
            <div class="shop-item">
                <strong>üîÑ IDÈÄ£Êê∫ (ÂêåÊúü„Éó„É¨„Ç§)</strong>
                <p style="font-size:0.8em; color:#666; margin:5px 0;">
                    ÁèæÂú®„ÅÆID („Åì„ÅÆID„ÇíÂà•Á´ØÊú´„Å´ÂÖ•Âäõ):<br>
                    <input type="text" value="${sharedUid || currentUid}" readonly style="width:100%; padding:5px; background:#eee; border:1px solid #ddd; border-radius:4px;" onclick="this.select();document.execCommand('copy');showToast('ID„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü')">
                </p>
                <div style="margin-top:10px; border-top:1px dashed #ccc; padding-top:10px;">
                    <p style="font-size:0.8em; color:#666; margin:0 0 5px 0;">Âà•Á´ØÊú´„ÅÆID„ÇíÂÖ•Âäõ„Åó„Å¶ÈÄ£Êê∫:</p>
                    <div style="display:flex; gap:5px;">
                        <input type="text" id="restore-uid-input" placeholder="ÈÄ£Êê∫„Åô„ÇãID„ÇíÂÖ•Âäõ" style="flex:1; padding:5px; border:1px solid #ddd; border-radius:4px;">
                        <button onclick="actLinkID()" style="padding:5px 10px; font-size:0.9em;">ÈÄ£Êê∫</button>
                    </div>
                    ${sharedUid ? '<div style="margin-top:5px;"><button onclick="actUnlinkID()" style="width:100%; background-color:#e74c3c;">ÈÄ£Êê∫„ÇíËß£Èô§„Åô„Çã</button></div>' : ''}
                </div>
            </div>

            <div class="shop-item">
                <strong>‚öôÔ∏è Ë®≠ÂÆö</strong>
                <div style="margin-top:5px;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;">
                        <span>üéµ BGM</span>
                        <span id="label-bgm-vol">${Math.floor(SoundManager.config.bgmVolume * 100)}%</span>
                    </div>
                    <input type="range" min="0" max="100" value="${SoundManager.config.bgmVolume * 100}" 
                        style="width:100%"
                        oninput="let v = this.value / 100; SoundManager.setBGMVolume(v); document.getElementById('label-bgm-vol').innerText = this.value + '%';">
                </div>
                <div style="margin-top:10px;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:2px;">
                        <span>üîä ÂäπÊûúÈü≥</span>
                        <span id="label-se-vol">${Math.floor(SoundManager.config.seVolume * 100)}%</span>
                    </div>
                    <input type="range" min="0" max="100" value="${SoundManager.config.seVolume * 100}" 
                        style="width:100%"
                        oninput="let v = this.value / 100; SoundManager.setSEVolume(v); document.getElementById('label-se-vol').innerText = this.value + '%';">
                </div>
            </div>

            <div class="shop-item">
                <strong>üìù „Ç≤„Éº„É†„Å´„Å§„ÅÑ„Å¶</strong>
                <p style="font-size:0.9em; color:#666;">
                    ÁèæÂú®„ÅÆ„Éû„ÉÉ„Éó„Çµ„Ç§„Ç∫: ${gameState.gridSize}x${gameState.gridSize}<br>
                    ÂÖ®„Å¶ÈñãÊãì„Åô„Çã„Å®‰∏ñÁïå„ÅåÂ∫É„Åå„Çä„Åæ„ÅôÔºÅ<br>
                    „Éá„Éº„Çø„ÅØ„ÇØ„É©„Ç¶„Éâ„Å´‰øùÂ≠ò„Åï„Çå„Å¶„ÅÑ„Åæ„Åô‚òÅÔ∏è
                </p>
            </div>
        `;

            modal.style.display = 'flex';
        };


        window.openCatalog = function () {
            closeModal('modal-menu');
            const modal = document.getElementById('modal-catalog');
            const content = document.getElementById('catalog-content');

            let html = '<div class="catalog-grid">';

            for (let k in BUILDINGS) {
                const b = BUILDINGS[k];
                html += `
                    <div class="catalog-item" onclick="showCatalogDetail('${k}')">
                        <div class="catalog-icon">${b.icon}</div>
                        <div class="catalog-name">${b.name}</div>
                    </div>
                `;
            }

            html += '</div>';
            html += `
                <div style="margin-top:15px; padding:10px; background:white; border-radius:8px; font-size:0.9em; color:#7f8c8d; text-align:center; border:1px dashed #ccc;">
                    ÊñΩË®≠„Ç¢„Ç§„Ç≥„É≥„Çí„Çø„ÉÉ„Éó„Åô„Çã„Å®<br>Ë©≥Á¥∞Ë™¨Êòé„ÇíÁ¢∫Ë™ç„Åß„Åç„Åæ„Åô
                </div>
            `;

            content.innerHTML = html;
            modal.style.display = 'flex';
        };

        window.showCatalogDetail = function (type) {
            const b = BUILDINGS[type];
            const content = document.getElementById('catalog-content');

            // Lv.1„Åß„ÅÆÂäπÊûú„ÇíË°®Á§∫
            const prodHtml = getBuildingEffectHtml(type, 1);

            const costStr = formatCostWithColor(b.cost);

            const typeIndex = BUILDING_KEYS.indexOf(type);
            const isStandardLimited = (typeIndex >= LIMIT_START_INDEX && typeIndex !== -1);
            const isSpecialLimited = ['well', 'inn', 'clocktower'].includes(type);

            let limitStr = 'ÁÑ°Âà∂Èôê (ÂúüÂú∞‰æùÂ≠ò)';
            if (isSpecialLimited) limitStr = '2„Å§„Åæ„Åß';
            else if (isStandardLimited) limitStr = '4„Å§„Åæ„Åß';

            content.innerHTML = `
                <button class="back-btn" onclick="openCatalog()">
                    <span>‚óÄ</span> ‰∏ÄË¶ß„Å´Êàª„Çã
                </button>
                
                <div class="detail-header">
                    <div class="detail-icon">${b.icon}</div>
                    <div class="detail-title">
                        <h4>${b.name}</h4>
                        <span class="detail-category">Âª∫Ë®≠ÂèØËÉΩÊñΩË®≠</span>
                    </div>
                </div>
                
                <div class="detail-desc">
                    ${b.desc}
                    <div style="margin-top:10px; font-size:0.85em; color:#a1887f; border-top:1px solid #f9e79f; padding-top:5px;">
                        üí° „Éí„É≥„Éà: „É¨„Éô„É´„Ç¢„ÉÉ„Éó„ÅßÁîüÁî£Âäõ„ÅåÂ§ßÂπÖ„Å´Âêë‰∏ä„Åó„Åæ„Åô„ÄÇ
                    </div>
                </div>
                
                <div class="detail-stats-grid">
                    <div class="stat-card">
                        <span class="stat-label">ÁîüÁî£ËÉΩÂäõ / ÂäπÊûú (Lv.1)</span>
                        <div class="stat-content">
                            ${prodHtml}
                        </div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-label">Âª∫Ë®≠„Ç≥„Çπ„Éà</span>
                        <div class="stat-content">
                            ${costStr || 'ÁÑ°Êñô'}
                        </div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-label">Âü∫Êú¨Âª∫Ë®≠ÊôÇÈñì</span>
                        <div class="stat-content">
                            ‚è≥ ${formatTime(b.baseTime / 1000)}
                        </div>
                    </div>
                    <div class="stat-card">
                        <span class="stat-label">ÊúÄÂ§ßË®≠ÁΩÆÊï∞</span>
                        <div class="stat-content">
                            ${limitStr}
                        </div>
                    </div>
                </div>
            `;
        };

        window.openBuildingList = function () {
            closeModal('modal-menu');
            const modal = document.getElementById('modal-building-list');
            const content = document.getElementById('building-list-content');

            let html = '<div style="font-weight:bold; margin-bottom:5px; color:#2c3e50;">üåç „Éû„ÉÉ„Éó‰∏ä„ÅÆÊñΩË®≠</div>';

            let mapBuildings = [];
            gameState.tiles.forEach((t, i) => {
                if (t.type) {
                    mapBuildings.push({ tile: t, index: i });
                }
            });

            const getResScore = (type) => {
                const b = BUILDINGS[type];
                if (b.prod.money) return 1;
                if (b.prod.food) return 2;
                if (b.prod.wood) return 3;
                if (b.prod.stone) return 4;
                if (b.prod.iron) return 5;
                return 6;
            };
            const sortFn = (a, b) => {
                const typeA = a.tile ? a.tile.type : a.type;
                const lvlA = a.tile ? a.tile.level : a.level;
                const typeB = b.tile ? b.tile.type : b.type;
                const lvlB = b.tile ? b.tile.level : b.level;

                const sA = getResScore(typeA);
                const sB = getResScore(typeB);

                if (sA !== sB) return sA - sB;
                return lvlB - lvlA;
            };

            mapBuildings.sort(sortFn);

            if (mapBuildings.length === 0) {
                html += '<p style="color:#999; font-size:0.9em;">ÊñΩË®≠„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì</p>';
            } else {
                mapBuildings.forEach(item => {
                    const b = BUILDINGS[item.tile.type];
                    const level = item.tile.level;

                    const prodStr = getBuildingEffectHtml(item.tile.type, level);

                    html += `
                    <div class="building-item" style="background:white; margin-bottom:5px;">
                        <div class="building-info">
                            <strong>${b.icon} ${b.name} (Lv.${level})</strong>
                            <span style="font-size:0.8em; color:#666;">${prodStr}</span>
                        </div>
                        <button onclick="focusTile(${item.index})" style="padding:5px 10px; font-size:0.8em;">Ë©≥Á¥∞</button>
                    </div>
                `;
                });
            }

            html += '<div style="font-weight:bold; margin-top:15px; margin-bottom:5px; color:#7f8c8d; border-top:1px dashed #ccc; padding-top:10px;">üì¶ ‰øùÁÆ°Â∫´„ÅÆÊñΩË®≠</div>';

            if (gameState.inventory.length === 0) {
                html += '<p style="color:#999; font-size:0.9em;">‰øùÁÆ°Â∫´„ÅØÁ©∫„Åß„Åô</p>';
            } else {
                let sortedInv = [...gameState.inventory];
                sortedInv.sort(sortFn);

                sortedInv.forEach(item => {
                    const b = BUILDINGS[item.type];
                    // Inventory items also show effect
                    const prodStr = getBuildingEffectHtml(item.type, item.level);

                    html += `
                    <div class="building-item" style="background:#f5f5f5; color:#666;">
                        <div class="building-info">
                            <strong>${b.icon} ${b.name} (Lv.${item.level})</strong>
                            <span style="font-size:0.8em;">${prodStr}</span>
                        </div>
                        <span style="font-size:0.8em; background:#eee; padding:3px 6px; border-radius:4px;">‰øùÁÆ°‰∏≠</span>
                    </div>
                `;
                });
            }

            content.innerHTML = html;
            modal.style.display = 'flex';
        };

        window.focusTile = function (index) {
            closeModal('modal-building-list');
            selectTile(index);

            const tObj = tileMeshes[index];
            if (tObj && camera) {
                const targetX = tObj.mesh.position.x;
                const targetZ = tObj.mesh.position.z;

                camera.position.x = targetX + 20;
                camera.position.z = targetZ + 20;
                camera.updateProjectionMatrix();
            }
        };

        window.actLinkID = function () {
            const input = document.getElementById('restore-uid-input');
            const targetUid = input.value.trim();
            if (!targetUid) return showToast("‚ö†Ô∏è ID„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ");

            if (!confirm("‚ö†Ô∏è IDÈÄ£Êê∫„É¢„Éº„Éâ\n\nÂÖ•Âäõ„Åó„ÅüID„ÅÆ„Éá„Éº„Çø„Çí„ÄéÂÖ±Êúâ„Äè„Åó„Å¶„Éó„É¨„Ç§„Åó„Åæ„Åô„ÄÇ\nË§áÊï∞„ÅÆÁ´ØÊú´„ÅßÂêå„Åò„Éá„Éº„Çø„ÇíÂêåÊúü„Åß„Åç„Åæ„Åô„ÄÇ\n(‚ÄªFirebase„ÅÆ„É´„Éº„É´Ë®≠ÂÆö„ÅåÂøÖË¶Å„Åß„Åô)\n\nÂàá„ÇäÊõø„Åà„Åæ„Åô„ÅãÔºü")) return;

            localStorage.setItem('kingdomBuilder_sharedId', targetUid);
            location.reload();
        };

        window.actUnlinkID = function () {
            if (!confirm("ÈÄ£Êê∫„ÇíËß£Èô§„Åó„ÄÅÊú¨Êù•„ÅÆËá™ÂàÜ„ÅÆID„Å´Êàª„Çä„Åæ„Åô„ÅãÔºü")) return;
            localStorage.removeItem('kingdomBuilder_sharedId');
            location.reload();
        }

        window.actBuyBuilder = function () {
            const cost = getBuilderCost();
            if (gameState.resources.money >= cost) {
                gameState.resources.money -= cost;
                gameState.maxBuilders++;
                saveGame();
                updateHeader();
                openMenu();
            }
        };

        function updateHeader() {
            for (let k in gameState.resources) document.getElementById('display-' + k).innerText = Math.floor(gameState.resources[k]).toLocaleString();
            document.getElementById('display-rank').innerText = gameState.rank;
            document.getElementById('display-next-xp').innerText = (getNextRankXP(gameState.rank) - gameState.xp).toLocaleString();
            document.getElementById('display-xp-bar').style.width = Math.min(100, (gameState.xp / getNextRankXP(gameState.rank)) * 100) + '%';

            const active = getActiveBuilders();
            const max = gameState.maxBuilders;
            const builderEl = document.getElementById('display-builders');
            builderEl.innerText = `${active}/${max}`;
            builderEl.style.color = active >= max ? 'red' : '#2c3e50';
        }

        function onWindowResize() {
            const c = document.getElementById('game-container');
            if (!c) return;
            const width = c.clientWidth || window.innerWidth;
            const height = c.clientHeight || window.innerHeight;
            const aspect = width / height;
            const d = 10;

            if (camera && renderer) {
                camera.left = -d * aspect;
                camera.right = d * aspect;
                camera.top = d;
                camera.bottom = -d;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
        }

        function processOfflineProgress() {
            try {
                const now = Date.now();
                const sec = (now - gameState.lastSaveTime) / 1000;
                if (sec > 10) {
                    let rep = ""; let built = 0; let earn = {};
                    gameState.tiles.forEach(t => {
                        if (t.finishTime && t.finishTime <= now) { t.level++; t.finishTime = null; built++; gameState.xp += Math.floor(getBuildTime(t.type, t.level - 1) / 1000); }
                        if (t.type && t.level > 0 && !t.finishTime) {
                            const b = BUILDINGS[t.type]; const caps = getStorageCapacity(t.type, t.level);
                            for (let r in b.prod) if (b.prod[r] > 0) {
                                if (!earn[r]) earn[r] = 0;
                                const add = Math.min(caps[r] - (t.stored[r] || 0), b.prod[r] * t.level * Math.pow(1.05, t.level - 1) * sec);
                                if (add > 0) { t.stored[r] = (t.stored[r] || 0) + add; earn[r] += add; }
                            }
                        }
                    });
                    if (built > 0) rep += `<div>üèóÔ∏è ${built}‰ª∂ÂÆå‰∫Ü</div>`;
                    for (let r in earn) if (earn[r] > 1) rep += `<div>+${Math.floor(earn[r]).toLocaleString()} ${r}</div>`;
                    if (rep) { document.getElementById('offline-report').innerHTML = rep; document.getElementById('modal-offline').style.display = 'flex'; }
                    addXP(0); // „É©„É≥„ÇØ„Ç¢„ÉÉ„Éó„ÉÅ„Çß„ÉÉ„ÇØ
                    gameState.lastSaveTime = now;
                    saveGame(); // „Ç™„Éï„É©„Ç§„É≥ÁµåÈÅéÂàÜ„Çí‰øùÂ≠ò
                }
            } catch (e) {
                console.error(e);
            }
        }

        window.closeModal = function (id) { document.getElementById(id).style.display = 'none'; }

    </script>
</body>

</html>
