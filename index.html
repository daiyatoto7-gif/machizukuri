<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kingdom Builder 3D (Rank Balance Fix)</title>
    
    <!-- ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¹ã‚¿ã‚¤ãƒ« -->
    <style>
        #debug-log {
            position: fixed; top: 0; left: 0; width: 100%; height: auto;
            max-height: 100px; overflow-y: scroll;
            background: rgba(0,0,0,0.7); color: lime;
            font-family: monospace; font-size: 10px;
            z-index: 9999; pointer-events: none;
            padding: 5px; box-sizing: border-box;
            display: none;
        }
        .error-msg { color: #ff5555; }
    </style>

    <!-- Three.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    
    <style>
        :root {
            --bg-color: #f0f2f5;
            --panel-bg: #ffffff;
            --accent-color: #3498db;
            --text-color: #2c3e50;
            --xp-color: #f1c40f;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            overflow: hidden;
            user-select: none;
            height: 100vh;
            width: 100vw;
        }

        /* ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚¿ãƒƒãƒã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ç„¡åŠ¹åŒ–ã—ã¦ãƒ–ãƒ©ã‚¦ã‚¶ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²ã */
        canvas {
            touch-action: none;
        }

        header {
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            padding: 5px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            position: fixed;
            top: 0;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
        }
        header > * { pointer-events: auto; }

        .status-bar {
            display: flex;
            gap: 20px;
            align-items: center;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .rank-badge {
            background: var(--accent-color);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.9em;
        }
        .xp-container {
            width: 150px;
            height: 10px;
            background: #eee;
            border-radius: 5px;
            overflow: hidden;
        }
        .xp-fill {
            height: 100%;
            background: var(--xp-color);
            width: 0%;
            transition: width 0.5s;
        }
        .resource-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            font-size: 0.85em;
            justify-content: center;
            padding: 0 10px;
            background: rgba(255,255,255,0.8);
            border-radius: 10px;
        }

        #game-container {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 1;
            background: radial-gradient(circle at center, #dcecf5 0%, #b0c4de 100%);
        }

        #ui-overlay-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            overflow: hidden;
        }

        .overlay-item {
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .tile-timer {
            font-size: 10px;
            font-weight: bold;
            color: white;
            background: rgba(0,0,0,0.6);
            padding: 2px 4px;
            border-radius: 4px;
            margin-bottom: 2px;
            white-space: nowrap;
        }
        .progress-bar-container {
            width: 40px; height: 4px; background: rgba(255,255,255,0.5); 
            border-radius: 2px; overflow: hidden;
        }
        .progress-fill { height: 100%; background: #2ecc71; width: 0%; transition: width 0.2s linear; }

        .harvest-bubble {
            background: white;
            border: 2px solid #f39c12;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            animation: bounce 1s infinite alternate;
            cursor: pointer;
        }
        @keyframes bounce { from { transform: translateY(0); } to { transform: translateY(-5px); } }

        .lock-icon {
            font-size: 24px;
            opacity: 0.6;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .float-text {
            position: absolute;
            color: #27ae60;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 0 #fff;
            animation: floatUp 1s ease-out forwards;
            pointer-events: none;
            z-index: 100;
        }
        @keyframes floatUp { 
            0% { transform: translate(-50%, -50%); opacity: 1; } 
            100% { transform: translate(-50%, -150%); opacity: 0; } 
        }

        #control-panel {
            position: absolute;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            width: 90%; max-width: 400px;
            max-height: 40vh;
            background: var(--panel-bg);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.2);
            z-index: 30;
            display: none;
            flex-direction: column;
        }
        #control-panel.active { display: flex; }

        #panel-header {
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 2px solid var(--bg-color);
            padding-bottom: 10px; margin-bottom: 10px;
        }
        #panel-title { margin: 0; font-size: 1.1em; color: var(--accent-color); }
        
        /* é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã®ã‚¿ãƒƒãƒ—é ˜åŸŸã‚’æ‹¡å¤§ */
        .close-btn { 
            cursor: pointer; 
            font-weight: bold; 
            padding: 10px 15px; 
            color: #999; 
            font-size: 1.2em; 
            margin: -10px -10px -10px 0;
        }
        .close-btn:hover { color: #666; }

        #panel-content { flex: 1; overflow-y: auto; padding-right: 5px; }

        .building-item {
            display: flex; justify-content: space-between; align-items: center;
            border: 1px solid #eee; padding: 8px; border-radius: 6px;
            margin-bottom: 8px; font-size: 0.9em;
        }
        .building-info { display: flex; flex-direction: column; gap: 2px; }
        .res-cost { font-size: 0.85em; color: #666; }

        button {
            padding: 8px 12px; border: none; border-radius: 4px;
            background-color: var(--accent-color); color: white;
            font-weight: bold; cursor: pointer; font-size: 0.9em;
        }
        button.action-btn { width: 100%; padding: 12px; font-size: 1em; margin-top: 5px; }
        button.store-btn { background-color: var(--text-color); margin-top: 10px; }
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }

        .inventory-section {
            margin-top: 15px;
            border-top: 2px dashed #eee;
            padding-top: 10px;
        }
        .inventory-title {
            font-size: 0.9em; font-weight: bold; color: #7f8c8d; margin-bottom: 5px;
        }

        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); justify-content: center; align-items: center; z-index: 100;
        }
        .modal-content {
            background: white; padding: 30px; border-radius: 10px; text-align: center;
            max-width: 400px; box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³: å›ºå®šé…ç½® (å³ä¸Šã«å¤‰æ›´) */
        #menu-btn {
            position: fixed;
            top: 15px;
            right: 15px; /* å³å´ã«é…ç½®ã—ã¦ãƒ©ãƒ³ã‚¯è¡¨ç¤ºã¨è¢«ã‚‰ãªã„ã‚ˆã†ã« */
            background: white;
            width: 40px; height: 40px;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex; 
            justify-content: center; align-items: center;
            font-size: 24px;
            cursor: pointer;
            z-index: 50;
            pointer-events: auto;
        }
        #menu-btn:hover { background: #f0f0f0; }

        /* ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚¹ã‚¿ã‚¤ãƒ« */
        .shop-item {
            background: #f9f9f9;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            text-align: left;
        }
        
        #toast-notification {
            position: fixed; top: 80px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white; padding: 10px 20px;
            border-radius: 20px; font-weight: bold; z-index: 100;
            display: none; pointer-events: none;
            animation: fadeInOut 3s forwards;
            white-space: nowrap;
        }
        @keyframes fadeInOut { 0% { opacity:0; top:90px; } 10% { opacity:1; top:80px; } 90% { opacity:1; top:80px; } 100% { opacity:0; top:70px; } }

        /* ãƒ­ãƒ¼ãƒ‰ç”»é¢ */
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #dcecf5 0%, #b0c4de 100%);
            z-index: 9999;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            transition: opacity 0.5s;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--accent-color);
            border-radius: 50%;
            width: 40px; height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

<div id="debug-log"></div>
<div id="toast-notification"></div>

<div id="loading-screen">
    <div class="loader"></div>
    <div id="loading-text" style="font-weight:bold; color:#2c3e50;">Connecting to Cloud...</div>
</div>

<div id="menu-btn" onclick="openMenu()">â‰¡</div>

<header>
    <div class="status-bar">
        <div class="rank-badge">RANK <span id="display-rank">1</span></div>
        <div class="xp-container">
            <div class="xp-fill" id="display-xp-bar"></div>
        </div>
        <div style="font-size:0.8em; color:#7f8c8d;">Next: <span id="display-next-xp">0</span> XP</div>
    </div>
    <div class="resource-bar">
        <div class="res-item">ğŸ’° <span id="display-money">0</span></div>
        <div class="res-item">ğŸŒ¾ <span id="display-food">0</span></div>
        <div class="res-item">ğŸŒ² <span id="display-wood">0</span></div>
        <div class="res-item">ğŸª¨ <span id="display-stone">0</span></div>
        <div class="res-item">ğŸ”© <span id="display-iron">0</span></div>
        <div class="res-item" style="border-left:1px solid #ddd; padding-left:10px; color:#e67e22;">ğŸ‘· <span id="display-builders">0/4</span></div>
    </div>
</header>

<div id="game-container"></div>
<div id="ui-overlay-layer"></div>

<div id="control-panel">
    <div id="panel-header">
        <h2 id="panel-title">ã‚¿ã‚¤ãƒ«é¸æŠ</h2>
        <div class="close-btn" onclick="closePanel()">âœ•</div>
    </div>
    <div id="panel-content"></div>
</div>

<div id="modal-offline" class="modal">
    <div class="modal-content">
        <h3>ãŠã‹ãˆã‚Šãªã•ã„ï¼</h3>
        <p>ä¸åœ¨ã®é–“ã«ç”Ÿç”£ã•ã‚ŒãŸè³‡æºãŒ<br>è²¯è”µåº«ã«ä¿ç®¡ã•ã‚Œã¾ã—ãŸã€‚</p>
        <div style="text-align:left; background:#f9f9f9; padding:10px; border-radius:5px; margin:10px 0;">
            <div id="offline-report"></div>
        </div>
        <button onclick="closeModal('modal-offline')" class="action-btn">å†é–‹ã™ã‚‹</button>
    </div>
</div>

<div id="modal-levelup" class="modal">
    <div class="modal-content">
        <h3 style="color:var(--accent-color);">ğŸ‰ ãƒ©ãƒ³ã‚¯ã‚¢ãƒƒãƒ—ï¼ ğŸ‰</h3>
        <p style="font-size:1.2em; font-weight:bold;">RANK <span id="levelup-rank"></span> ã«ãªã‚Šã¾ã—ãŸï¼</p>
        <button onclick="closeModal('modal-levelup')" class="action-btn">é–‰ã˜ã‚‹</button>
    </div>
</div>

<div id="modal-menu" class="modal">
    <div class="modal-content">
        <h3 style="margin-top:0;">ãƒ¡ãƒ‹ãƒ¥ãƒ¼</h3>
        <div id="menu-content" style="max-height:60vh; overflow-y:auto;"></div>
        <button onclick="closeModal('modal-menu')" class="action-btn" style="background-color:#95a5a6; margin-top:20px;">é–‰ã˜ã‚‹</button>
    </div>
</div>

<!-- æ–½è¨­ä¸€è¦§ç”¨ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div id="modal-building-list" class="modal">
    <div class="modal-content" style="max-width:500px; max-height:80vh; overflow:hidden; display:flex; flex-direction:column;">
        <h3 style="margin-top:0;">ğŸ“‹ æ–½è¨­ä¸€è¦§</h3>
        <div id="building-list-content" style="flex:1; overflow-y:auto; text-align:left;"></div>
        <button onclick="closeModal('modal-building-list')" class="action-btn" style="background-color:#95a5a6; margin-top:10px;">é–‰ã˜ã‚‹</button>
    </div>
</div>

<script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
    import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
    import { getFirestore, doc, setDoc, getDoc, collection } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';

    // Global Firebase Variables
    let firebaseConfig;
    let appId;
    let offlineMode = false; // ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ•ãƒ©ã‚°

    // ç’°å¢ƒåˆ¤å®šï¼šã“ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç’°å¢ƒ(Canvas)ã‹ã€å¤–éƒ¨ç’°å¢ƒ(GitHub Pagesç­‰)ã‹ã‚’åˆ¤å®šã—ã¦è¨­å®šã‚’åˆ‡ã‚Šæ›¿ãˆ
    if (typeof __firebase_config !== 'undefined') {
        // Canvasç’°å¢ƒ
        firebaseConfig = JSON.parse(__firebase_config);
        appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    } else {
        // å¤–éƒ¨ç’°å¢ƒ (GitHub Pagesç­‰): å…ƒã®ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰è¨­å®šã‚’ä½¿ç”¨
        firebaseConfig = {
            apiKey: "AIzaSyBzJkeWGrzm5pFKAuX_Vkk-w1w4tsKHsDo",
            authDomain: "kingdom-builder-cdfb9.firebaseapp.com",
            projectId: "kingdom-builder-cdfb9",
            storageBucket: "kingdom-builder-cdfb9.firebasestorage.app",
            messagingSenderId: "672874506084",
            appId: "1:672874506084:web:573a57495e5a350d4fbc71",
            measurementId: "G-F6JMJJR146"
        };
        appId = firebaseConfig.projectId;
    }

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    let currentUser = null;
    let userDocRef = null;
    let currentDocId = null; // å®Ÿéš›ã«èª­ã¿æ›¸ãã™ã‚‹IDï¼ˆå…±æœ‰IDã¾ãŸã¯è‡ªåˆ†ã®UIDï¼‰

    // --- Firebase Init ---
    async function initFirebase() {
        const loadingText = document.getElementById('loading-text');
        
        try {
            // Canvasç’°å¢ƒ: ã‚«ã‚¹ã‚¿ãƒ ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä½¿ç”¨ (æ¨å¥¨)
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                 await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                 // å¤–éƒ¨ç’°å¢ƒã¾ãŸã¯ãƒˆãƒ¼ã‚¯ãƒ³ãŒãªã„å ´åˆ: åŒ¿åèªè¨¼
                 await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Auth failed:", error);
            
            // ã‚¨ãƒ©ãƒ¼ã®ç¨®é¡ãŒãƒªãƒ•ã‚¡ãƒ©ãƒ¼åˆ¶é™ã®å ´åˆã€ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã§ç¶šè¡Œ
            if(error.code === 'auth/requests-from-referer-blocked' || error.message.includes('referer')) {
                console.warn("Domain restricted: Switching to Offline Mode.");
                offlineMode = true;
                loadingText.innerText = "Offline Mode (Cloud Disabled)";
                setTimeout(loadGameFromCloud, 1000); // ç›´æ¥ãƒ­ãƒ¼ãƒ‰ã¸
                return;
            }

            // ãã®ä»–ã®ã‚¨ãƒ©ãƒ¼ã§ã®ãƒªãƒˆãƒ©ã‚¤
            try {
                await signInAnonymously(auth);
            } catch(e) {
                // ã“ã“ã§ã‚‚ãƒ€ãƒ¡ãªã‚‰ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ã¸
                console.error("Retry Auth Failed, using offline", e);
                offlineMode = true;
                loadingText.innerText = "Offline Mode";
                setTimeout(loadGameFromCloud, 1000);
                return;
            }
        }

        // 2. Auth Listener (ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ™‚ã®ã¿ç™ºç«)
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                
                // å…±æœ‰è¨­å®š(IDé€£æº)ãŒã‚ã‚‹ã‹ç¢ºèª
                const sharedId = localStorage.getItem('kingdomBuilder_sharedId');
                if (sharedId) {
                    currentDocId = sharedId;
                    console.log("Using Shared ID:", currentDocId);
                } else {
                    currentDocId = user.uid;
                }

                // Rule: /artifacts/{appId}/users/{userId}/gameData/saveSlot1
                userDocRef = doc(db, 'artifacts', appId, 'users', currentDocId, 'gameData', 'saveSlot1');
                
                loadingText.innerText = "Loading Kingdom...";
                await loadGameFromCloud();
            }
        });
    }
    
    // --- Cloud Load & Save Logic ---
    async function loadGameFromCloud() {
        try {
            // ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ ã¾ãŸã¯ Cloudèª­è¾¼
            let data = null;
            let loadedFrom = "";

            if (!offlineMode && userDocRef) {
                try {
                    const snap = await getDoc(userDocRef);
                    if (snap.exists()) {
                        data = snap.data();
                        loadedFrom = "Cloud";
                    }
                } catch(e) {
                    console.warn("Cloud read failed, falling back to local:", e);
                    // Cloudèª­è¾¼å¤±æ•—æ™‚ã‚‚ãƒ­ãƒ¼ã‚«ãƒ«ã¸ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
                }
            }

            // ã‚¯ãƒ©ã‚¦ãƒ‰ã«ãªã‘ã‚Œã°ãƒ­ãƒ¼ã‚«ãƒ«(ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—)ã‚’ç¢ºèª
            if (!data) {
                const backup = localStorage.getItem('kingdomBuilderSave');
                if (backup) {
                    try {
                        data = JSON.parse(backup);
                        loadedFrom = "Local Backup";
                    } catch(e){}
                }
            }

            // ãã‚Œã§ã‚‚ãªã‘ã‚Œã°æ—§ãƒ‡ãƒ¼ã‚¿ã‚’ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ¢ç´¢
            if (!data) {
                const legacyKeys = ['kingdomBuilderSave', 'kb_save_data', 'gameState']; 
                for (const key of legacyKeys) {
                    const localRaw = localStorage.getItem(key);
                    if (localRaw) {
                        try {
                            const localData = JSON.parse(localRaw);
                            if (localData && (localData.resources || localData.tiles)) {
                                data = localData;
                                loadedFrom = "Legacy Migration";
                                showToast("ğŸ“¦ å¤ã„ãƒ‡ãƒ¼ã‚¿ã‚’å¼•ãç¶™ãã¾ã—ãŸï¼");
                                break; 
                            }
                        } catch (e) {}
                    }
                }
            }

            if (data) {
                gameState = { ...gameState, ...data };
                processOfflineProgress();
                console.log(`Loaded game from: ${loadedFrom}`);
                // åˆå›ãƒ­ãƒ¼ãƒ‰æˆåŠŸæ™‚ã«å³åº§ã«ä¿å­˜ã—ã¦æ•´åˆæ€§ã‚’ä¿ã¤
                saveGameToCloud(true);
            } else {
                console.log("New User: Creating initial state.");
                saveGameToCloud(true);
            }

        } catch (e) {
            console.error("Load failed:", e);
            showToast("ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ");
        }

        // ãƒ­ãƒ¼ãƒ‰å®Œäº†å¾Œã€ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹
        initGame();
        
        const loader = document.getElementById('loading-screen');
        if(loader) {
            loader.style.opacity = 0;
            setTimeout(() => loader.style.display = 'none', 500);
        }
    }

    async function saveGameToCloud(silent = false) {
        gameState.lastSaveTime = Date.now();
        
        try {
            // ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
            const dataToSave = JSON.parse(JSON.stringify(gameState));
            
            // 1. ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«å¸¸ã«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ— (ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ™‚ & æ¬¡å›é«˜é€Ÿãƒ­ãƒ¼ãƒ‰ç”¨)
            localStorage.setItem('kingdomBuilderSave', JSON.stringify(dataToSave));

            // 2. ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã‹ã¤èªè¨¼æ¸ˆã¿ãªã‚‰ã‚¯ãƒ©ã‚¦ãƒ‰ã¸ä¿å­˜
            if (!offlineMode && currentUser && userDocRef) {
                await setDoc(userDocRef, dataToSave);
                if (!silent) showToast("â˜ï¸ ä¿å­˜ã—ã¾ã—ãŸ");
            } else {
                if (!silent) showToast("ğŸ’¾ ä¿å­˜ã—ã¾ã—ãŸ (ã‚ªãƒ•ãƒ©ã‚¤ãƒ³)");
            }
        } catch (e) {
            console.error("Save failed:", e);
            // Cloudä¿å­˜å¤±æ•—æ™‚ã‚‚ãƒ­ãƒ¼ã‚«ãƒ«ã«ã¯ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ã®ã§è‡´å‘½çš„ã§ã¯ãªã„
            if (!silent && !offlineMode) showToast("âš ï¸ ã‚¯ãƒ©ã‚¦ãƒ‰ä¿å­˜å¤±æ•—(ãƒ­ãƒ¼ã‚«ãƒ«ã«ä¿å­˜)");
        }
    }

    window.saveGame = saveGameToCloud;

    window.onload = function() {
        try {
            initFirebase();
        } catch(e) {
            console.error("Firebase init crash:", e);
            document.getElementById('loading-text').innerText = "Offline Mode";
            offlineMode = true;
            setTimeout(() => {
                loadGameFromCloud();
            }, 1000);
        }
    };


    // --- Game Logic ---

    function log(msg, isError = false) {
        const el = document.getElementById('debug-log');
        if (!el) return;
        const line = document.createElement('div');
        line.textContent = `> ${msg}`;
        if (isError) {
            line.className = 'error-msg';
            el.style.display = 'block'; 
            console.error(msg);
        } else {
            console.log(msg);
        }
        el.appendChild(line);
        el.scrollTop = el.scrollHeight;
    }
    
    function showToast(msg) {
        const t = document.getElementById('toast-notification');
        t.innerText = msg;
        t.style.display = 'none';
        void t.offsetWidth; // trigger reflow
        t.style.display = 'block';
    }

    window.onerror = function(message, source, lineno, colno, error) {
        log(`Global Error: ${message} at line ${lineno}`, true);
        return false;
    };

    const CONFIG = {
        initialGridSize: 5, 
        fps: 30, 
        autoSaveInterval: 10000, 
        initialUnlocked: [6, 7, 8, 11, 12, 13],
        storageHours: 8,
        collectCooldown: 30000,
        initialMaxBuilders: 4
    };

    const BUILDINGS = {
        house: { name: "æ°‘å®¶", icon: "ğŸ ", desc: "ä½æ°‘ãŒä½ã‚€å®¶ã€‚ãŠé‡‘ã‚’ç”Ÿç”£ã—ã¾ã™ã€‚", prod: { money: 2 }, cost: { money: 20, food: 10 }, baseTime: 2000 },
        farm: { name: "ç•‘", icon: "ğŸŒ¾", desc: "ä½œç‰©ã‚’è‚²ã¦ã¾ã™ã€‚é£Ÿæ–™ã‚’ç”Ÿç”£ã—ã¾ã™ã€‚", prod: { food: 2 }, cost: { money: 30, wood: 10 }, baseTime: 2000 },
        lumber: { name: "ä¼æ¡æ‰€", icon: "ğŸŒ²", desc: "æœ¨ã‚’åˆ‡ã‚Šå‡ºã—ã¾ã™ã€‚æœ¨æã‚’ç”Ÿç”£ã—ã¾ã™ã€‚", prod: { wood: 1 }, cost: { money: 50, food: 20 }, baseTime: 3000 },
        quarry: { name: "æ¡çŸ³å ´", icon: "ğŸª¨", desc: "çŸ³ã‚’åˆ‡ã‚Šå‡ºã—ã¾ã™ã€‚çŸ³æã‚’ç”Ÿç”£ã—ã¾ã™ã€‚", prod: { stone: 1 }, cost: { money: 100, food: 50, wood: 50 }, baseTime: 4000 },
        mine: { name: "é‰±å±±", icon: "ğŸ”©", desc: "åœ°ä¸‹è³‡æºã‚’æ˜ã‚Šã¾ã™ã€‚é‰„ã‚’ç”Ÿç”£ã—ã¾ã™ã€‚", prod: { iron: 1 }, cost: { money: 200, food: 100, wood: 100, stone: 50 }, baseTime: 5000 },
        market: { name: "å¸‚å ´", icon: "âš–ï¸", desc: "äº¤æ˜“ã‚’è¡Œã„ã¾ã™ã€‚å¤§é‡ã®ãŠé‡‘ã‚’ç”Ÿç”£ã—ã¾ã™ã€‚", prod: { money: 10 }, cost: { money: 500, food: 200, wood: 200, stone: 50 }, baseTime: 6000 },
        blacksmith: { name: "é›å†¶å±‹", icon: "âš”ï¸", desc: "æ­¦å…·ã‚’ä½œã‚Šã¾ã™ã€‚ãŠé‡‘ã¨é‰„ã‚’ç”Ÿç”£ã—ã¾ã™ã€‚", prod: { money: 5, iron: 2 }, cost: { money: 800, food: 300, wood: 300, stone: 200, iron: 100 }, baseTime: 7000 }
    };
    
    // æ–½è¨­åˆ¶é™ã®ãŸã‚ã®ã‚­ãƒ¼é…åˆ—ã¨åˆ¶é™é–‹å§‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    const BUILDING_KEYS = Object.keys(BUILDINGS);
    const LIMIT_START_INDEX = BUILDING_KEYS.indexOf('market'); // marketä»¥é™ã¯åˆ¶é™å¯¾è±¡

    // ç‰¹å®šã®æ–½è¨­ã®æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆï¼ˆãƒãƒƒãƒ—ä¸Š + ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªï¼‰
    function getBuildingCount(type) {
        const onMap = gameState.tiles.filter(t => t.type === type).length;
        const inInventory = gameState.inventory.filter(i => i.type === type).length;
        return onMap + inInventory;
    }

    // å»ºè¨­åˆ¶é™ã®ãƒã‚§ãƒƒã‚¯
    function checkBuildingLimit(type) {
        const typeIndex = BUILDING_KEYS.indexOf(type);
        // å¸‚å ´ä»¥é™ã®æ–½è¨­ã€ã‹ã¤4ã¤ä»¥ä¸ŠæŒã£ã¦ã„ã‚‹å ´åˆã¯NG
        if (typeIndex >= LIMIT_START_INDEX && typeIndex !== -1) {
            if (getBuildingCount(type) >= 4) {
                return false;
            }
        }
        return true;
    }
    
    for(let k in BUILDINGS) {
        const b = BUILDINGS[k];
        for(let r of ['money','food','wood','stone','iron']) {
            if(!b.prod[r]) b.prod[r] = 0;
            if(!b.cost[r]) b.cost[r] = 0;
        }
    }

    let gameState = {
        rank: 1, xp: 0,
        resources: { money: 200, food: 100, wood: 50, stone: 0, iron: 0 },
        tiles: [],
        inventory: [],
        maxBuilders: CONFIG.initialMaxBuilders,
        gridSize: CONFIG.initialGridSize,
        lastSaveTime: Date.now()
    };

    let selectedTileIndex = null;

    let scene, camera, renderer;
    let raycaster, mouse;
    let tileMeshes = []; 
    let pedestrians = []; 
    
    // ã‚«ãƒ¡ãƒ©ç§»å‹•ç”¨å¤‰æ•°
    let pointerDownPos = new THREE.Vector2();
    let lastPointerPos = new THREE.Vector2();
    let isDragging = false;
    let isPanning = false;

    // Called after Firestore load
    function initGame() {
        log("Game initializing...");

        if (typeof THREE === 'undefined') {
            document.body.innerHTML = '<div style="padding:20px;text-align:center;color:red;"><h3>ã‚¨ãƒ©ãƒ¼: 3Dãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã‚ã¾ã›ã‚“ã€‚</h3><p>å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚</p></div>';
            return;
        }
        
        // çµŒé¨“å€¤ãƒ†ãƒ¼ãƒ–ãƒ«å¤‰æ›´ã«ä¼´ã†æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
        migrateXPSystem();

        if (!gameState.maxBuilders) gameState.maxBuilders = CONFIG.initialMaxBuilders;
        if (!gameState.gridSize) gameState.gridSize = CONFIG.initialGridSize;

        const totalTiles = gameState.gridSize * gameState.gridSize;
        if (gameState.tiles.length !== totalTiles) {
            if (gameState.tiles.length === 0) {
                gameState.tiles = Array(totalTiles).fill(null).map((_, i) => ({
                    type: null, level: 0, finishTime: null, 
                    unlocked: CONFIG.initialUnlocked.includes(i), 
                    stored: {},
                    lastCollectTime: 0
                }));
            } else {
                const currentLen = gameState.tiles.length;
                for(let i=currentLen; i<totalTiles; i++) {
                      gameState.tiles.push({
                         type: null, level: 0, finishTime: null, 
                         unlocked: false,
                         stored: {},
                         lastCollectTime: 0
                      });
                }
            }
        } else {
             gameState.tiles.forEach(t => { 
                 if(!t.stored) t.stored = {}; 
                 if(t.lastCollectTime === undefined) t.lastCollectTime = 0;
             });
        }
        if(!gameState.inventory) gameState.inventory = [];

        try {
            init3D();
        } catch (e) {
            log(`3D Init Error: ${e.message}`, true);
            showToast("3Dè¡¨ç¤ºã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
            return;
        }

        updateHeader();
        
        requestAnimationFrame(animate3D);
        setInterval(gameLogicLoop, 1000); 
        setInterval(() => window.saveGame(true), CONFIG.autoSaveInterval);
        setInterval(updatePanelUI, 500);

        log("Game loop started.");
    }

    // XPãƒãƒ©ãƒ³ã‚¹èª¿æ•´ã«ä¼´ã†ãƒã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
    function migrateXPSystem() {
        // ã™ã§ã«ç§»è¡Œæ¸ˆã¿ãªã‚‰ä½•ã‚‚ã—ãªã„
        if (gameState.xpMigrationDone) return;

        // ãƒ©ãƒ³ã‚¯12æœªæº€ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯å½±éŸ¿ã‚’å—ã‘ãªã„ã®ã§ãƒ•ãƒ©ã‚°ã ã‘ç«‹ã¦ã‚‹
        if (gameState.rank < 12) {
            gameState.xpMigrationDone = true;
            return; 
        }

        console.log("Migrating XP system for Rank 12+ user...");

        // ãƒ©ãƒ³ã‚¯12ä»¥ä¸Šã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å ´åˆ:
        // æ—§ãƒ­ã‚¸ãƒƒã‚¯ã§ã®ç´¯ç©çµŒé¨“å€¤ã‚’å¾©å…ƒã—ã€æ–°ãƒ­ã‚¸ãƒƒã‚¯ã§å†è¨ˆç®—ã™ã‚‹
        let totalXP = gameState.xp;
        
        // æ—§è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯ (ä¸€æ™‚çš„ã«å†ç¾)
        const getLegacyXP = (r) => {
             const base = r * 500;
             if(r >= 10) return base * 4;
             return base;
        };

        // ã“ã‚Œã¾ã§ã®ãƒ©ãƒ³ã‚¯åˆ†ã®XPã‚’åˆè¨ˆã—ã¦ç·ç²å¾—XPã‚’ç®—å‡º
        for (let r = 1; r < gameState.rank; r++) {
            totalXP += getLegacyXP(r);
        }

        // æ–°ãƒ­ã‚¸ãƒƒã‚¯ã§ãƒ©ãƒ³ã‚¯ã‚’å†è¨ˆç®—
        let newRank = 1;
        while(true) {
            const req = getNextRankXP(newRank);
            if (totalXP >= req) {
                totalXP -= req;
                newRank++;
            } else {
                break;
            }
        }

        if (newRank !== gameState.rank) {
            console.log(`Rank migrated: ${gameState.rank} -> ${newRank}`);
            showToast(`ãƒ©ãƒ³ã‚¯èª¿æ•´: ${gameState.rank}â†’${newRank}`);
            gameState.rank = newRank;
            gameState.xp = totalXP;
        }

        gameState.xpMigrationDone = true;
        saveGame(true);
    }

    function init3D() {
        const container = document.getElementById('game-container');
        if(!container) throw new Error("Game container not found");
        
        let width = container.clientWidth;
        let height = container.clientHeight;

        if (width === 0 || height === 0) {
            width = window.innerWidth;
            height = window.innerHeight;
        }

        scene = new THREE.Scene();
        
        const aspect = width / height;
        const d = 10;
        
        camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(20, 20, 20); 
        camera.lookAt(scene.position);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        
        const pixelRatio = Math.max(window.devicePixelRatio, 2.0);
        renderer.setPixelRatio(pixelRatio);
        
        renderer.setSize(width, height);
        renderer.shadowMap.enabled = true;
        renderer.setClearColor( 0x000000, 0 ); 
        container.innerHTML = ''; 
        container.appendChild(renderer.domElement);
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        
        createTiles();
        initPedestrians();

        window.addEventListener('resize', onWindowResize, false);
        
        renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
        renderer.domElement.addEventListener('pointerup', onPointerUp, false);
        renderer.domElement.addEventListener('pointermove', onPointerMove, false);

        renderer.domElement.addEventListener('wheel', onMouseWheel, { passive: false });
        renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
        renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
        renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
        
        setTimeout(onWindowResize, 100);
    }
    
    function createTiles() {
        tileMeshes.forEach(t => {
            scene.remove(t.mesh);
            scene.remove(t.groundMesh);
            t.overlayEl.remove();
        });
        tileMeshes = [];

        const geometry = new THREE.BoxGeometry(1.4, 0.5, 1.4);
        const unlockedMat = new THREE.MeshStandardMaterial({ color: 0xecf0f1 });
        const groundGeo = new THREE.PlaneGeometry(2.0, 2.0);
        const groundMatBase = new THREE.MeshStandardMaterial({ color: 0x555555 });

        const offset = 2; 
        const size = gameState.gridSize;
        const start = -offset * (size - 1) / 2;

        for (let i = 0; i < size * size; i++) {
            const row = Math.floor(i / size);
            const col = i % size;
            const x = start + col * offset;
            const z = start + row * offset;

            const ground = new THREE.Mesh(groundGeo, groundMatBase.clone());
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(x, -0.01, z);
            ground.receiveShadow = true;
            scene.add(ground);

            const mesh = new THREE.Mesh(geometry, unlockedMat.clone());
            mesh.position.set(x, 0, z);
            mesh.receiveShadow = true;
            mesh.userData = { index: i, type: 'tile' };
            scene.add(mesh);

            const bGroup = new THREE.Group();
            bGroup.position.set(0, 0.25, 0);
            mesh.add(bGroup);

            const overlay = document.createElement('div');
            overlay.className = 'overlay-item';
            document.getElementById('ui-overlay-layer').appendChild(overlay);

            const particles = new ParticleSystem(mesh.position, scene);

            tileMeshes.push({ 
                mesh: mesh, 
                groundMesh: ground,
                buildingGroup: bGroup,
                overlayEl: overlay,
                particles: particles,
                currentType: null 
            });
        }
        sync3DState();
    }

    class Person {
        constructor(scene) {
            this.scene = scene;
            this.mesh = new THREE.Group();
            const bodyColor = Math.random() * 0xffffff;
            const bodyGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.25, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.125;
            this.mesh.add(body);
            const headGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 0.35;
            this.mesh.add(head);
            this.mesh.castShadow = true;
            scene.add(this.mesh);
            this.active = false;
            this.mesh.visible = false;
            this.isStopped = false;
            this.stopTimer = 0;
            this.canTurn = true;
            this.reset();
        }
        getNearestRoadCoord(val) {
            const size = gameState.gridSize;
            const offset = 2; 
            const tileStart = -offset * (size - 1) / 2;
            const roadStart = tileStart + 1;
            const index = Math.round((val - roadStart) / offset);
            return roadStart + index * offset;
        }
        reset() {
            const isVertical = Math.random() < 0.5;
            const size = gameState.gridSize;
            const offset = 2; 
            const tileStart = -offset * (size - 1) / 2;
            const roadStart = tileStart + 1;
            const roadCount = Math.max(1, size - 1); 
            const roadIndex = Math.floor(Math.random() * roadCount);
            const laneCenter = roadStart + roadIndex * offset;
            const jitter = (Math.random() - 0.5) * 0.4;
            const lane = laneCenter + jitter;
            this.baseSpeed = (0.02 + Math.random() * 0.02) * 0.25;
            this.speed = this.baseSpeed;
            let sx, sz, dx, dz;
            const spawnDist = size + 5; 
            if (isVertical) {
                sx = lane;
                sz = (Math.random() < 0.5 ? -spawnDist : spawnDist);
                dx = 0; dz = sz > 0 ? -1 : 1;
            } else {
                sz = lane;
                sx = (Math.random() < 0.5 ? -spawnDist : spawnDist);
                dx = sx > 0 ? -1 : 1; dz = 0;
            }
            this.mesh.position.set(sx, 0, sz);
            this.direction = new THREE.Vector3(dx, 0, dz);
            this.active = true;
            this.isStopped = false;
            this.canTurn = true;
            this.updateVisibility();
        }
        isOnGreenRoad(x, z, isVertical) {
            const size = gameState.gridSize;
            const offset = 2;
            const start = -offset * (size - 1) / 2;
            const checkTile = (wx, wz) => {
                const col = Math.round((wx - start) / offset);
                const row = Math.round((wz - start) / offset);
                if (col < 0 || col >= size || row < 0 || row >= size) return false;
                const idx = row * size + col;
                return gameState.tiles[idx] && gameState.tiles[idx].unlocked;
            };
            let t1_unlocked = false;
            let t2_unlocked = false;
            if (isVertical) {
                t1_unlocked = checkTile(x - 1, Math.round(z));
                t2_unlocked = checkTile(x + 1, Math.round(z));
            } else {
                t1_unlocked = checkTile(Math.round(x), z - 1);
                t2_unlocked = checkTile(Math.round(x), z + 1);
            }
            return (!t1_unlocked && !t2_unlocked);
        }
        update() {
            if (!this.active) {
                if (Math.random() < 0.01) this.reset();
                return;
            }
            if (this.isStopped) {
                this.stopTimer--;
                if (this.stopTimer <= 0) {
                    this.isStopped = false;
                }
                this.updateVisibility();
                return;
            }
            if (Math.random() < 0.005) {
                this.isStopped = true;
                this.stopTimer = 30 + Math.random() * 60;
                return;
            }
            const nearestRoadX = this.getNearestRoadCoord(this.mesh.position.x);
            const nearestRoadZ = this.getNearestRoadCoord(this.mesh.position.z);
            const distX = Math.abs(this.mesh.position.x - nearestRoadX);
            const distZ = Math.abs(this.mesh.position.z - nearestRoadZ);
            const intersectionThreshold = 0.1; 
            const isAtIntersection = (distX < intersectionThreshold && distZ < intersectionThreshold);
            if (isAtIntersection) {
                if (this.canTurn) {
                    if(Math.random() < 0.5) {
                        const dirs = [
                            new THREE.Vector3(1, 0, 0),
                            new THREE.Vector3(-1, 0, 0),
                            new THREE.Vector3(0, 0, 1),
                            new THREE.Vector3(0, 0, -1)
                        ];
                        this.direction = dirs[Math.floor(Math.random() * dirs.length)];
                        this.mesh.position.x = nearestRoadX;
                        this.mesh.position.z = nearestRoadZ;
                    }
                    this.canTurn = false; 
                }
            } else {
                if (Math.max(distX, distZ) > 0.4) {
                    this.canTurn = true;
                }
            }
            this.mesh.position.addScaledVector(this.direction, this.speed);
            const limit = gameState.gridSize * 1.5 + 5;
            if (Math.abs(this.mesh.position.x) > limit || Math.abs(this.mesh.position.z) > limit) {
                this.reset();
                return;
            }
            this.updateVisibility();
            this.mesh.position.y = Math.abs(Math.sin(Date.now() * 0.005)) * 0.05;
        }
        updateVisibility() {
            const isVertical = (this.direction.z !== 0);
            if (this.isOnGreenRoad(this.mesh.position.x, this.mesh.position.z, isVertical)) {
                this.mesh.visible = false;
            } else {
                this.mesh.visible = true;
            }
        }
    }

    function initPedestrians() {
        if(pedestrians.length === 0) {
            for (let i = 0; i < 15; i++) { 
                pedestrians.push(new Person(scene));
            }
        } else {
            pedestrians.forEach(p => p.reset());
        }
    }

    class ParticleSystem {
        constructor(position, scene) {
            this.origin = position.clone().add(new THREE.Vector3(0, 1, 0));
            this.particles = [];
            this.scene = scene;
            this.active = false;
            this.geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            this.mat = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true });
        }
        update() {
            if (!this.active && this.particles.length === 0) return;
            if (this.active && Math.random() < 0.2) {
                const mesh = new THREE.Mesh(this.geo, this.mat.clone());
                const offset = new THREE.Vector3((Math.random()-0.5)*1.5, 0, (Math.random()-0.5)*1.5);
                mesh.position.copy(this.origin).add(offset);
                this.scene.add(mesh);
                this.particles.push({ 
                    mesh: mesh, 
                    vel: new THREE.Vector3(0, 0.05 + Math.random()*0.05, 0), 
                    life: 1.0 
                });
            }
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                p.mesh.position.add(p.vel);
                p.mesh.rotation.x += 0.1;
                p.mesh.rotation.y += 0.1;
                p.life -= 0.02;
                p.mesh.material.opacity = p.life;
                if (p.life <= 0) {
                    this.scene.remove(p.mesh);
                    this.particles.splice(i, 1);
                }
            }
        }
    }

    function createBuildingMesh(type, level) {
        const group = new THREE.Group();
        const scale = 1 + (level * 0.05);
        group.scale.set(scale, scale, scale);
        const matRoof = new THREE.MeshStandardMaterial({ color: 0xe74c3c }); 
        const matWall = new THREE.MeshStandardMaterial({ color: 0xf39c12 }); 
        const matLeaf = new THREE.MeshStandardMaterial({ color: 0x2ecc71 }); 
        const matStone = new THREE.MeshStandardMaterial({ color: 0x7f8c8d }); 
        const matDark = new THREE.MeshStandardMaterial({ color: 0x34495e }); 
        const matTent = new THREE.MeshStandardMaterial({ color: 0x3498db }); 
        const matGrass = new THREE.MeshStandardMaterial({ color: 0x27ae60 });
        switch(type) {
            case 'wild': // æœªé–‹æ‹“åœ°ã®è‰
                for(let i=0; i<8; i++) {
                    const grass = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.3, 4), matGrass);
                    grass.position.set((Math.random()-0.5)*1.4, 0.15, (Math.random()-0.5)*1.4);
                    grass.rotation.y = Math.random() * Math.PI;
                    group.add(grass);
                }
                if(Math.random() < 0.5) {
                    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.3), new THREE.MeshStandardMaterial({color:0x8B4513}));
                    trunk.position.y = 0.15;
                    group.add(trunk);
                    const leaves = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 8), matLeaf);
                    leaves.position.y = 0.4;
                    group.add(leaves);
                }
                break;
            case 'house':
                const wall = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.8), matWall);
                wall.position.y = 0.3;
                wall.castShadow = true;
                group.add(wall);
                const roof = new THREE.Mesh(new THREE.ConeGeometry(0.7, 0.5, 4), matRoof);
                roof.position.y = 0.85;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                group.add(roof);
                const chimney = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.4, 0.15), matStone);
                chimney.position.set(0.2, 0.8, 0.2);
                group.add(chimney);
                break;
            case 'farm':
                const soil = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.1, 1.0), new THREE.MeshStandardMaterial({color:0x8B4513}));
                soil.position.y = 0.05;
                soil.receiveShadow = true;
                group.add(soil);
                for(let i=0; i<4; i++) {
                    const crop = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.4, 0.2), matLeaf);
                    crop.position.set((i%2 ? 0.3 : -0.3), 0.25, (i<2 ? 0.3 : -0.3));
                    group.add(crop);
                }
                break;
            case 'lumber':
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.15, 0.4), new THREE.MeshStandardMaterial({color:0x8B4513}));
                trunk.position.y = 0.2;
                group.add(trunk);
                const leaves2 = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 8), matLeaf);
                leaves2.position.y = 0.7;
                group.add(leaves2);
                const stump = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.2), new THREE.MeshStandardMaterial({color:0x8B4513}));
                stump.position.set(0.4, 0.1, 0.4);
                group.add(stump);
                break;
            case 'quarry':
                const rock1 = new THREE.Mesh(new THREE.DodecahedronGeometry(0.4), matStone);
                rock1.position.y = 0.3;
                group.add(rock1);
                const rock2 = new THREE.Mesh(new THREE.DodecahedronGeometry(0.3), matStone);
                rock2.position.set(0.4, 0.2, 0.3);
                group.add(rock2);
                break;
            case 'mine':
                const frame = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.2), new THREE.MeshStandardMaterial({color:0x5d4037}));
                frame.position.set(0, 0.3, -0.2);
                group.add(frame);
                const hole = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.1), new THREE.MeshStandardMaterial({color:0x000000}));
                hole.position.set(0, 0.25, -0.1);
                group.add(hole);
                break;
            case 'market':
                const post = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.4, 0.8), new THREE.MeshStandardMaterial({color:0xecf0f1}));
                post.position.y = 0.2;
                group.add(post);
                const tent = new THREE.Mesh(new THREE.ConeGeometry(0.7, 0.5, 4), matTent);
                tent.position.y = 0.65;
                tent.rotation.y = Math.PI / 4;
                group.add(tent);
                break;
            case 'blacksmith':
                const houseB = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.5, 0.6), matDark);
                houseB.position.y = 0.25;
                group.add(houseB);
                const chimney2 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.8, 0.2), new THREE.MeshStandardMaterial({color:0x2c3e50}));
                chimney2.position.set(0.3, 0.4, 0.2);
                group.add(chimney2);
                break;
        }
        return group;
    }

    function animate3D() {
        requestAnimationFrame(animate3D);
        tileMeshes.forEach(t => t.particles.update());
        pedestrians.forEach(p => p.update()); 
        if(renderer && scene && camera) {
            renderer.render(scene, camera);
        }
        updateOverlayPositions();
    }

    function updateOverlayPositions() {
        if (!camera) return;
        const width = window.innerWidth;
        const height = window.innerHeight;
        const widthHalf = width / 2;
        const heightHalf = height / 2;

        tileMeshes.forEach((t, i) => {
            const pos = t.mesh.position.clone();
            
            // ä¿®æ­£: æœªé–‹æ‹“åœ°ã®å ´åˆã¯ã‚¢ã‚¤ã‚³ãƒ³ä½ç½®ã‚’ä½ãã™ã‚‹
            if (gameState.tiles[i] && !gameState.tiles[i].unlocked) {
                pos.y += 0.5;
            } else {
                pos.y += 1.5; 
            }

            pos.project(camera);

            const x = (pos.x * widthHalf) + widthHalf;
            const y = -(pos.y * heightHalf) + heightHalf;

            if (x < -100 || x > width + 100 || y < -100 || y > height + 100) {
                t.overlayEl.style.display = 'none';
            } else {
                t.overlayEl.style.display = 'flex';
                t.overlayEl.style.left = `${x}px`;
                t.overlayEl.style.top = `${y}px`;
            }
        });
    }

    function sync3DState() {
        const reqRank = getRequiredRankForExpansion();
        
        gameState.tiles.forEach((tile, i) => {
            const tObj = tileMeshes[i];
            const mesh = tObj.mesh;
            const overlay = tObj.overlayEl;
            const ground = tObj.groundMesh;

            if (!tile.unlocked) {
                // æœªé–‹æ‹“åœ°
                ground.material.color.setHex(0x27ae60);
                mesh.material.color.setHex(0x2ecc71);
                tObj.buildingGroup.visible = true; 
                tObj.particles.active = false;
                
                const stateKey = `wild`;
                if (tObj.currentType !== stateKey) {
                    while(tObj.buildingGroup.children.length > 0){ 
                        tObj.buildingGroup.remove(tObj.buildingGroup.children[0]); 
                    }
                    const newModel = createBuildingMesh('wild', 0);
                    tObj.buildingGroup.add(newModel);
                    tObj.currentType = stateKey;
                }

                const canUnlock = gameState.rank >= reqRank;
                if (canUnlock) {
                      overlay.innerHTML = `<div class="lock-icon">ğŸ”’</div>`;
                } else {
                    overlay.innerHTML = "";
                }
                return;
            } else {
                // é–‹æ‹“åœ°
                ground.material.color.setHex(0x555555);
                mesh.material.color.setHex(0xecf0f1);
            }
            
            if (selectedTileIndex === i) {
                mesh.material.emissive.setHex(0x3498db);
                mesh.material.emissiveIntensity = 0.3;
            } else {
                mesh.material.emissive.setHex(0x000000);
            }

            if (tile.type) {
                tObj.buildingGroup.visible = true;
                
                const stateKey = `${tile.type}_${tile.level}`;
                if (tObj.currentType !== stateKey) {
                    while(tObj.buildingGroup.children.length > 0){ 
                        tObj.buildingGroup.remove(tObj.buildingGroup.children[0]); 
                    }
                    const newModel = createBuildingMesh(tile.type, tile.level);
                    tObj.buildingGroup.add(newModel);
                    tObj.currentType = stateKey;
                }
                
                if (tile.finishTime) {
                    tObj.particles.active = true;
                    const remaining = Math.max(0, (tile.finishTime - Date.now()));
                    const total = getBuildTime(tile.type, tile.level); 
                    const percent = Math.min(100, Math.max(0, 100 - (remaining / total * 100)));
                    
                    overlay.innerHTML = `
                        <div class="tile-timer">${formatTimeShort(remaining/1000)}</div>
                        <div class="progress-bar-container"><div class="progress-fill" style="width:${percent}%"></div></div>
                    `;
                } else {
                    tObj.particles.active = false;
                    
                    let content = "";
                    let hasResource = false;
                    let maxRes = ""; let maxVal = 0;
                    const canCollect = (Date.now() - (tile.lastCollectTime || 0)) >= CONFIG.collectCooldown;

                    if(tile.stored && canCollect) {
                        for(let r in tile.stored) {
                            if(tile.stored[r] >= 1) {
                                hasResource = true;
                                if(tile.stored[r] > maxVal) { maxVal = tile.stored[r]; maxRes = r; }
                            }
                        }
                    }
                    if (hasResource) {
                        const icon = maxRes=='money'?'ğŸ’°':maxRes=='food'?'ğŸŒ¾':maxRes=='wood'?'ğŸŒ²':maxRes=='stone'?'ğŸª¨':'ğŸ”©';
                        content = `<div class="harvest-bubble" onclick="collectResourceUI(${i}, event)">${icon}</div>`;
                    }
                    overlay.innerHTML = content;
                }
            } else {
                tObj.buildingGroup.visible = false;
                tObj.particles.active = false;
                tObj.currentType = null;
                overlay.innerHTML = "";
            }
        });
    }
    
    function gameLogicLoop() {
        const now = Date.now();
        let dirty = false;

        gameState.tiles.forEach(tile => {
            if (tile.unlocked) {
                if (tile.finishTime && now >= tile.finishTime) {
                    tile.level++;
                    tile.finishTime = null;
                    const xp = Math.floor(getBuildTime(tile.type, tile.level-1) / 1000);
                    addXP(xp);
                    dirty = true;
                    if(selectedTileIndex !== null) updatePanelUI();
                }
                
                if (tile.type && tile.level > 0 && !tile.finishTime) {
                    const b = BUILDINGS[tile.type];
                    const caps = getStorageCapacity(tile.type, tile.level);
                    for (let r in b.prod) {
                        if (b.prod[r] > 0) {
                            const amount = (b.prod[r] * tile.level * Math.pow(1.05, tile.level - 1));
                            if (!tile.stored[r]) tile.stored[r] = 0;
                            if (tile.stored[r] < caps[r]) {
                                tile.stored[r] = Math.min(caps[r], tile.stored[r] + amount);
                                if(Math.floor(tile.stored[r]) >= 1) dirty = true;
                            }
                        }
                    }
                }
            }
        });

        if(dirty || (now % 1000 < 100)) { 
            sync3DState();
        }
        updateHeader();
    }

    function onPointerDown(event) {
        pointerDownPos.set(event.clientX, event.clientY);
        lastPointerPos.set(event.clientX, event.clientY); // ãƒ‘ãƒ³ãƒ‹ãƒ³ã‚°ç”¨
        isDragging = false;
        
        // å·¦ã‚¯ãƒªãƒƒã‚¯ã¾ãŸã¯ã‚¿ãƒƒãƒã®å ´åˆã®ã¿ç§»å‹•é–‹å§‹
        if (event.button === 0 || event.pointerType === 'touch') {
            isPanning = true;
        }
    }

    function onPointerMove(event) {
        // ãƒ‰ãƒ©ãƒƒã‚°åˆ¤å®šï¼ˆã‚¯ãƒªãƒƒã‚¯ã¨åŒºåˆ¥ã™ã‚‹ãŸã‚ï¼‰
        if (!isDragging && (Math.abs(event.clientX - pointerDownPos.x) > 5 || Math.abs(event.clientY - pointerDownPos.y) > 5)) {
            isDragging = true;
        }

        // ãƒ‘ãƒ³ãƒ‹ãƒ³ã‚°å‡¦ç†
        if (isPanning) {
            const deltaX = event.clientX - lastPointerPos.x;
            const deltaY = event.clientY - lastPointerPos.y;
            lastPointerPos.set(event.clientX, event.clientY);

            // ã‚ºãƒ¼ãƒ ä¸­ï¼ˆ2æœ¬æŒ‡ï¼‰ã¯ç§»å‹•ã•ã›ãªã„
            if (touchStartDist > 0) return; 

            moveCamera(deltaX, deltaY);
        }
    }

    function onPointerUp(event) {
        isPanning = false;
        
        if (isDragging) return;

        event.preventDefault();
        
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        
        // ãƒ’ãƒƒãƒˆåˆ¤å®šå¯¾è±¡ã‚’ã‚¿ã‚¤ãƒ«ã®ãƒ¡ãƒƒã‚·ãƒ¥ï¼ˆã¨ã£ãã®å­è¦ç´ ï¼‰ã«é™å®š
        // ã“ã‚Œã«ã‚ˆã‚Šã€æ­©è¡Œè€…ã‚„åœ°é¢ã®è£å´ãªã©ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã—ã¾ã†ã®ã‚’é˜²ã
        const targetObjects = tileMeshes.map(t => t.mesh);
        const intersects = raycaster.intersectObjects(targetObjects, true);

        if (intersects.length > 0) {
            let target = intersects[0].object;
            // è¦ªã‚’é¡ã£ã¦ã‚¿ã‚¤ãƒ«ãƒ«ãƒ¼ãƒˆ(userData.indexã‚’æŒã¤)ã‚’æ¢ã™
            while(target && target.userData.index === undefined && target.parent) {
                target = target.parent;
            }

            if (target && target.userData.index !== undefined) {
                const idx = target.userData.index;
                const collected = collectResource(idx);
                if (!collected) {
                      selectTile(idx);
                }
            }
        } else {
            closePanel();
        }
    }
    
    // ã‚«ãƒ¡ãƒ©ç§»å‹•é–¢æ•°
    function moveCamera(dx, dy) {
        if (!camera) return;
        
        // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ç§»å‹•é€Ÿåº¦ã‚’èª¿æ•´
        const speed = 0.05 / camera.zoom; 

        const vec = new THREE.Vector3();
        const quat = camera.quaternion.clone();
        
        // ç”»é¢å³æ–¹å‘ï¼ˆXè»¸ï¼‰
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(quat);
        right.y = 0; right.normalize();
        
        // ç”»é¢ä¸Šæ–¹å‘ï¼ˆYè»¸ï¼‰
        const up = new THREE.Vector3(0, 1, 0).applyQuaternion(quat);
        up.y = 0; up.normalize();

        // ã‚«ãƒ¡ãƒ©ä½ç½®æ›´æ–° (é€†æ–¹å‘ã«å‹•ã‹ã™ã¨åœ°é¢ã‚’ã¤ã‹ã‚“ã§å‹•ã‹ã™æ„Ÿè¦šã«ãªã‚‹)
        camera.position.addScaledVector(right, -dx * speed);
        camera.position.addScaledVector(up, dy * speed);
    }

    function setCameraZoom(val) {
        if (!camera) return;
        const minZoom = 0.5;
        const maxZoom = 2.5;
        camera.zoom = Math.max(minZoom, Math.min(maxZoom, val));
        camera.updateProjectionMatrix();
    }

    function onMouseWheel(event) {
        event.preventDefault();
        const zoomSpeed = 0.001;
        const newZoom = camera.zoom - event.deltaY * zoomSpeed;
        setCameraZoom(newZoom);
    }

    let touchStartDist = 0;
    let touchStartZoom = 1;

    function onTouchStart(event) {
        if (event.touches.length === 2) {
            isPanning = false; // ã‚ºãƒ¼ãƒ é–‹å§‹æ™‚ã¯ãƒ‘ãƒ³ãƒ‹ãƒ³ã‚°åœæ­¢
            const dx = event.touches[0].pageX - event.touches[1].pageX;
            const dy = event.touches[0].pageY - event.touches[1].pageY;
            touchStartDist = Math.sqrt(dx * dx + dy * dy);
            touchStartZoom = camera.zoom;
        }
    }

    function onTouchMove(event) {
        // ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã§ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢
        if(event.target === renderer.domElement) {
             event.preventDefault();
        }

        if (event.touches.length === 2) {
            const dx = event.touches[0].pageX - event.touches[1].pageX;
            const dy = event.touches[0].pageY - event.touches[1].pageY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (touchStartDist > 0) {
                const scale = dist / touchStartDist;
                setCameraZoom(touchStartZoom * scale);
            }
        }
    }
    
    function onTouchEnd(event) {
        if (event.touches.length < 2) {
            touchStartDist = 0;
        }
    }
    
    window.collectResourceUI = function(index, e) {
        e.stopPropagation();
        collectResource(index);
    };

    function selectTile(index) {
        selectedTileIndex = index;
        sync3DState(); 
        showPanel(index);
    }
    
    window.closePanel = function() {
        selectedTileIndex = null;
        document.getElementById('control-panel').classList.remove('active');
        sync3DState();
    };

    function formatTimeShort(s){ if(s<60)return`${Math.floor(s)}s`;if(s<3600)return`${Math.floor(s/60)}m`;return`${Math.floor(s/3600)}h`; }
    function formatTime(s){ if(s<60)return`${Math.floor(s)}ç§’`;if(s<3600)return`${Math.floor(s/60)}åˆ†${Math.floor(s%60)}ç§’`;return`${Math.floor(s/3600)}æ™‚é–“`; }
    
    function getNextRankXP(r){ 
        const base = r * 500;
        // ãƒ©ãƒ³ã‚¯12ä»¥ä¸Šã®å ´åˆã€å¾“æ¥ã®3å€ (base * 4 * 3)
        if(r >= 12) return base * 4 * 3;
        if(r >= 10) return base * 4;
        return base; 
    }
    
    function getBuildTime(t,l){ const tl=l+1; if(tl===1)return BUILDINGS[t].baseTime; return Math.floor(BUILDINGS[t].baseTime*Math.pow(tl, 2.8)); }
    
    function getCost(t,l){ 
        let m=Math.pow(1.6,l) * 1.5; 
        if(l >= 10) m *= 10; // Level 11+ Cost Increase
        const r={}; 
        for(let k in BUILDINGS[t].cost) r[k]=Math.floor(BUILDINGS[t].cost[k]*m); 
        return r; 
    }
    
    function getStorageCapacity(t,l){ const b=BUILDINGS[t], s=CONFIG.storageHours*3600, c={}; for(let r in b.prod) if(b.prod[r]>0) c[r]=b.prod[r]*l*Math.pow(1.05,l-1)*s; return c; }
    
    function getExpandCost(r){ 
        // ä¿®æ­£: å®Ÿéš›ã®ã‚¿ã‚¤ãƒ«æ•°(unlockedCount)ã§ã¯ãªãã€
        // ã€Œãã®ãƒ©ãƒ³ã‚¯ã§æœ¬æ¥åˆ°é”ã—ã¦ã„ã‚‹ã¯ãšã®é€²è¡Œåº¦ã€ã‚’åŸºæº–ã«ã‚³ã‚¹ãƒˆã‚’è¨ˆç®—ã™ã‚‹ã€‚
        // ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ©ãƒ³ã‚¯12ã§æ‹¡å¼µã™ã‚‹éš›ã®è²»ç”¨ã‚’ã€Œå…ƒã®ã‚³ãƒ¼ãƒ‰ã®ãƒ©ãƒ³ã‚¯12ã§ã®è²»ç”¨ã€ã¨ä¸€è‡´ã•ã›ã‚‹ã€‚
        const reqRank = getRequiredRankForExpansion();
        
        // å…ƒã®ä»•æ§˜ã§ã¯ Rank = Count - 2 ãªã®ã§ã€Count = Rank + 2 ã¨ãªã‚‹
        const virtualUnlockedCount = reqRank + 2;

        let b = 500 * Math.pow(1.5, virtualUnlockedCount - 4); 
        
        if(reqRank >= 6) b *= 20;
        
        let cost = {
            money: Math.floor(b),
            food: Math.floor(b*0.5),
            wood: Math.floor(b*0.3),
            stone: Math.floor(b*0.1),
            iron: 0
        };
        
        // ãƒ©ãƒ³ã‚¯12ä»¥ä¸Šã®å ´åˆã€ã•ã‚‰ã«ã‚³ã‚¹ãƒˆã‚’å¢—åŠ 
        if (reqRank >= 12) {
            cost.money *= 20;
            cost.food *= 20;
            cost.wood *= 5;
            cost.stone *= 5;
        }
        
        return cost; 
    }
    
    function getRequiredRankForExpansion(){ 
        const unlockedCount = gameState.tiles.filter(t=>t.unlocked).length;
        
        // å…ƒã®è¨ˆç®—å¼: åŸºæœ¬çš„ã«ã¯ ã‚¿ã‚¤ãƒ«æ•° - 2 ãŒå¿…è¦ãƒ©ãƒ³ã‚¯
        const baseReq = Math.max(2, unlockedCount - 2); 

        // ãƒ©ãƒ³ã‚¯10ã¾ã§ã¯ä»Šã¾ã§é€šã‚Š (1ãƒ©ãƒ³ã‚¯1æ‹¡å¼µ)
        if (baseReq <= 10) {
            return baseReq;
        } else {
            // ãƒ©ãƒ³ã‚¯10ä»¥é™ã¯ãƒšãƒ¼ã‚¹ã‚’è½ã¨ã™ (2ãƒ©ãƒ³ã‚¯1æ‹¡å¼µ)
            // baseReqãŒ11 (æœ¬æ¥ãƒ©ãƒ³ã‚¯11ã§è§£æ”¾) ã®å ´åˆ -> ãƒ©ãƒ³ã‚¯12ã§è§£æ”¾ã«ã™ã‚‹
            // è¨ˆç®—å¼: 10 + (è¶…éåˆ† * 2)
            return 10 + (baseReq - 10) * 2;
        }
    }

    function checkAfford(c){ for(let k in c) if((gameState.resources[k]||0)<c[k]) return false; return true; }
    function payCost(c){ for(let k in c) gameState.resources[k]-=c[k]; updateHeader(); }
    function addXP(a){ gameState.xp+=a; if(gameState.xp>=getNextRankXP(gameState.rank)){ gameState.xp-=getNextRankXP(gameState.rank); gameState.rank++; document.getElementById('levelup-rank').innerText=gameState.rank; document.getElementById('modal-levelup').style.display='flex'; } }

    function getActiveBuilders() {
        return gameState.tiles.filter(t => t.finishTime !== null).length;
    }

    function getBuilderCost() {
        const extra = Math.max(0, gameState.maxBuilders - CONFIG.initialMaxBuilders);
        return Math.floor(200000 * Math.pow(1.5, extra));
    }

    function collectResource(index) {
        const t = gameState.tiles[index];
        if(!t || !t.stored) return false;
        
        const now = Date.now();
        if ((now - (t.lastCollectTime || 0)) < CONFIG.collectCooldown) {
            return false;
        }

        let total = 0, txt = "";
        for(let r in t.stored) {
            const val = Math.floor(t.stored[r]);
            if(val > 0) {
                gameState.resources[r] += val;
                t.stored[r] = 0;
                total += val;
                const icon = r=='money'?'ğŸ’°':r=='food'?'ğŸŒ¾':r=='wood'?'ğŸŒ²':r=='stone'?'ğŸª¨':'ğŸ”©';
                txt += `${icon}+${val} `;
            }
        }
        if(total > 0) {
            t.lastCollectTime = now;
            updateHeader();
            sync3DState(); 
            const overlay = tileMeshes[index].overlayEl;
            const el = document.createElement('div');
            el.className = 'float-text';
            el.innerText = txt;
            overlay.appendChild(el);
            setTimeout(()=>el.remove(), 1000);
            return true;
        }
        return false;
    }
    
    // ä¸–ç•Œæ‹¡å¼µãƒã‚§ãƒƒã‚¯
    function checkAndExpandWorld() {
        const allUnlocked = gameState.tiles.every(t => t.unlocked);
        if (allUnlocked) {
            expandWorldSize();
        }
    }

    function expandWorldSize() {
        const oldSize = gameState.gridSize;
        const newSize = oldSize + 1;
        const newTiles = [];
        
        // æ–°ã—ã„ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦ãƒ‡ãƒ¼ã‚¿ã‚’å†æ§‹ç¯‰
        for(let i=0; i<newSize*newSize; i++) {
            const row = Math.floor(i / newSize);
            const col = i % newSize;
            
            // æ—¢å­˜ã‚¨ãƒªã‚¢ã®ç¯„å›²å†…ã§ã‚ã‚Œã°æ—§ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼
            if (row < oldSize && col < oldSize) {
                const oldIdx = row * oldSize + col;
                newTiles.push(gameState.tiles[oldIdx]);
            } else {
                // æ–°è¦ã‚¨ãƒªã‚¢
                newTiles.push({
                    type: null, level: 0, finishTime: null,
                    unlocked: false, 
                    stored: {},
                    lastCollectTime: 0
                });
            }
        }
        
        gameState.tiles = newTiles;
        gameState.gridSize = newSize;
        
        createTiles();
        updateMenuAnchor();
        showToast(`ğŸ‰ ä¸–ç•ŒãŒåºƒãŒã‚Šã¾ã—ãŸï¼ (${newSize}x${newSize})`);
        
        initPedestrians();
        saveGame();
    }

    function showPanel(index) {
        const tile = gameState.tiles[index];
        const p = document.getElementById('control-panel');
        const content = document.getElementById('panel-content');
        p.classList.add('active');
        updatePanelUI();
    }
    
    function updatePanelUI() {
        if(selectedTileIndex === null) return;
        const tile = gameState.tiles[selectedTileIndex];
        const content = document.getElementById('panel-content');
        if(!content) return;

        if (!tile.unlocked) {
            const req = getRequiredRankForExpansion();
            const cost = getExpandCost(gameState.rank);
            const ok = gameState.rank >= req;
            const afford = checkAfford(cost);
            content.innerHTML = `
                <div style="text-align:center;">
                    <p><strong>æœªé–‹æ‹“ã®åœŸåœ°</strong></p>
                    <div style="background:#eee; padding:10px; border-radius:5px; text-align:left; font-size:0.9em;">
                        æ¡ä»¶: ãƒ©ãƒ³ã‚¯${req} (${ok?'âœ…':'âŒ'})<br>
                        è²»ç”¨: ğŸ’°${cost.money.toLocaleString()} ğŸŒ¾${cost.food.toLocaleString()} ğŸŒ²${cost.wood.toLocaleString()} ğŸª¨${cost.stone.toLocaleString()}
                    </div>
                    <button class="action-btn" onclick="actExpand()" ${ok&&afford?'':'disabled'}>æ‹¡å¼µ</button>
                    ${!ok ? '<p style="color:red;font-size:0.8em">ãƒ©ãƒ³ã‚¯ä¸è¶³</p>' : ''}
                </div>`;
            return;
        }
        
        if (!tile.type) {
            let html = "";
            if (getActiveBuilders() >= gameState.maxBuilders) {
                html += `<div style="color:var(--danger-color); font-size:0.9em; font-weight:bold; margin-bottom:5px; text-align:center;">âš ï¸ å·¥äº‹ãŒã„ã£ã±ã„ã§ã™ï¼</div>`;
            }

            if (gameState.inventory && gameState.inventory.length > 0) {
                html += `<div class="inventory-section"><div class="inventory-title">ğŸ“¦ ä¿ç®¡åº«ã‹ã‚‰å†è¨­ç½®</div>`;
                gameState.inventory.forEach((item, idx) => {
                    const b = BUILDINGS[item.type];
                    const timeSec = getBuildTime(item.type, item.level - 1) / 1000;
                    
                    // åˆ¶é™ãƒã‚§ãƒƒã‚¯
                    const canRestore = checkBuildingLimit(item.type);
                    const disabledAttr = canRestore ? '' : 'disabled';
                    const warnText = canRestore ? '' : '<span style="color:red; font-size:0.8em;">(ä¸Šé™åˆ°é”)</span>';

                    html += `
                        <div class="building-item" style="background:#fff8e1;">
                            <div class="building-info">
                                <strong>${b.icon} ${b.name} (Lv.${item.level}) ${warnText}</strong>
                                <span class="res-cost">â³${formatTime(timeSec)}</span>
                            </div>
                            <button onclick="actRestore(${idx})" style="background-color:#f39c12;" ${disabledAttr}>é…ç½®</button>
                        </div>
                    `;
                });
                html += `</div><div class="inventory-title" style="margin-top:10px;">âœ¨ æ–°è¦å»ºè¨­</div>`;
            }

            for(let k in BUILDINGS) {
                const b = BUILDINGS[k];
                const c = getCost(k, 0);
                const afford = checkAfford(c);
                let cs = []; for(let r in c) if(c[r]>0) cs.push((r=='money'?'ğŸ’°':r=='food'?'ğŸŒ¾':r=='wood'?'ğŸŒ²':r=='stone'?'ğŸª¨':'ğŸ”©')+c[r].toLocaleString());
                
                // åˆ¶é™ãƒã‚§ãƒƒã‚¯
                const canBuild = checkBuildingLimit(k);
                const disabledAttr = (afford && canBuild) ? '' : 'disabled';
                const limitText = canBuild ? '' : '<br><span style="color:red; font-size:0.8em;">âš ï¸ ä¸Šé™(4ã¤)ã«é”ã—ã¦ã„ã¾ã™</span>';

                html += `
                    <div class="building-item">
                        <div class="building-info">
                            <strong>${b.icon} ${b.name}</strong>
                            <p style="font-size:0.8em; color:#666; margin:2px 0;">${b.desc}</p>
                            <span class="res-cost">${cs.join(' ')}</span>
                            <span class="res-cost">â³${formatTime(getBuildTime(k,0)/1000)}</span>
                            ${limitText}
                        </div>
                        <button onclick="actBuild('${k}')" ${disabledAttr}>å»ºè¨­</button>
                    </div>`;
            }
            content.innerHTML = html;
            return;
        }
        
        const b = BUILDINGS[tile.type];
        if (tile.finishTime) {
            const rem = Math.max(0, (tile.finishTime - Date.now()));
            
            let prodDiff = "";
            for(let r in b.prod) if(b.prod[r]>0) {
                const currentLevel = tile.level;
                const nextLevel = tile.level + 1;
                
                const getVal = (lvl) => {
                    if(lvl === 0) return 0;
                    return b.prod[r] * lvl * Math.pow(1.05, lvl - 1);
                };
                
                const currVal = getVal(currentLevel);
                const nextVal = getVal(nextLevel);
                const icon = (r=='money'?'ğŸ’°':r=='food'?'ğŸŒ¾':r=='wood'?'ğŸŒ²':r=='stone'?'ğŸª¨':'ğŸ”©');
                
                prodDiff += `<div>${icon} ${currVal.toFixed(1)}/s <span style="color:#2ecc71; font-weight:bold;">â ${nextVal.toFixed(1)}/s</span></div>`;
            }

            // Cancel Button Logic
            const c = getCost(tile.type, tile.level);
            let refund = [];
            for(let r in c) if(c[r]>0) refund.push(`${(r=='money'?'ğŸ’°':r=='food'?'ğŸŒ¾':r=='wood'?'ğŸŒ²':r=='stone'?'ğŸª¨':'ğŸ”©')}${Math.floor(c[r]*0.5).toLocaleString()}`);

            content.innerHTML = `
                <div style="text-align:center;">
                    <h3>${b.name} (Lv.${tile.level} â ${tile.level+1})</h3>
                    <div style="background:#f9f9f9; padding:5px; border-radius:5px; margin:5px 0; font-size:0.9em;">
                        <strong>å·¥äº‹å¾Œã®æ€§èƒ½:</strong>
                        ${prodDiff}
                    </div>
                    <h2 style="color:var(--accent-color)">${formatTime(rem/1000)}</h2>
                    <p>å·¥äº‹ä¸­...</p>
                    <button class="action-btn store-btn" onclick="actStore()">ğŸ“¦ å›åï¼ˆä¿ç®¡åº«ã¸ï¼‰</button>
                    <button class="action-btn" style="background-color:var(--danger-color); margin-top:5px;" onclick="actCancelBuild()">ğŸš« å·¥äº‹ä¸­æ­¢ (è¿”é‚„: ${refund.join(' ')})</button>
                </div>`;
        } else {
            const next = tile.level+1;
            const c = getCost(tile.type, tile.level);
            const afford = checkAfford(c);
            const caps = getStorageCapacity(tile.type, tile.level);
            let cs = []; for(let r in c) if(c[r]>0) cs.push((r=='money'?'ğŸ’°':r=='food'?'ğŸŒ¾':r=='wood'?'ğŸŒ²':r=='stone'?'ğŸª¨':'ğŸ”©')+c[r].toLocaleString());
            
            let prodInfo = ""; let storeInfo = "";
            for(let r in b.prod) if(b.prod[r]>0) {
                const val = b.prod[r]*tile.level*Math.pow(1.05, tile.level-1);
                prodInfo += `${(r=='money'?'ğŸ’°':r=='food'?'ğŸŒ¾':r=='wood'?'ğŸŒ²':r=='stone'?'ğŸª¨':'ğŸ”©')}${val.toFixed(1)}/s `;
                storeInfo += `<div>${(r=='money'?'ğŸ’°':r=='food'?'ğŸŒ¾':r=='wood'?'ğŸŒ²':r=='stone'?'ğŸª¨':'ğŸ”©')} ${Math.floor(tile.stored[r])}/${Math.floor(caps[r])}</div>`;
            }
            
            const buildersBusy = getActiveBuilders() >= gameState.maxBuilders;

            content.innerHTML = `
                <div style="text-align:center;">
                    <h3>${b.name} (Lv.${tile.level})</h3>
                    <p style="font-size:0.85em; color:#666; margin:0 0 10px 0;">${b.desc}</p>
                    <div style="background:#f0f0f0; padding:5px; border-radius:5px; margin-bottom:5px;">
                        <strong>ç”Ÿç”£åŠ›:</strong><br>${prodInfo}
                    </div>
                    <div style="background:#e8f4f8; padding:5px; border-radius:5px; margin-bottom:10px;">
                        <strong>è²¯è”µåº«:</strong><br>${storeInfo}
                    </div>
                    <div style="text-align:left; font-size:0.9em; margin-bottom:5px;">
                         <strong>LvUPè²»ç”¨:</strong> ${cs.join(' ')}<br>
                         <strong>æ™‚é–“:</strong> ${formatTime(getBuildTime(tile.type, tile.level)/1000)}
                    </div>
                    ${buildersBusy ? '<p style="color:red; font-size:0.9em;">âš ï¸ å·¥äº‹æ ãŒã„ã£ã±ã„ã§ã™</p>' : ''}
                    <button class="action-btn" onclick="actBuild('${tile.type}')" ${afford && !buildersBusy ?'':'disabled'}>ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—</button>
                    <button class="action-btn store-btn" onclick="actStore()">ğŸ“¦ å›åï¼ˆä¿ç®¡åº«ã¸ï¼‰</button>
                </div>`;
        }
    }

    window.actCancelBuild = function() {
        if(selectedTileIndex===null) return;
        const t = gameState.tiles[selectedTileIndex];
        if(!t.finishTime) return;
        
        if(!confirm("å·¥äº‹ã‚’ä¸­æ­¢ã—ã¾ã™ã‹ï¼Ÿ\nè²»ç”¨ã®ä¸€éƒ¨(50%)ãŒè¿”é‚„ã•ã‚Œã¾ã™ã€‚")) return;

        const c = getCost(t.type, t.level);
        let refundTxt = "";
        for(let r in c) {
            const amount = Math.floor(c[r] * 0.5);
            if(amount > 0) {
                gameState.resources[r] += amount;
                const icon = (r=='money'?'ğŸ’°':r=='food'?'ğŸŒ¾':r=='wood'?'ğŸŒ²':r=='stone'?'ğŸª¨':'ğŸ”©');
                refundTxt += `${icon}+${amount.toLocaleString()} `;
            }
        }
        
        t.finishTime = null;
        if(t.level === 0) {
            t.type = null;
            t.stored = {};
        }
        
        saveGame();
        sync3DState();
        updatePanelUI();
        updateHeader();
        showToast(`å·¥äº‹ã‚’ä¸­æ­¢ã—ã¾ã—ãŸ ${refundTxt}`);
    }

    window.actBuild = function(type) {
        if(selectedTileIndex===null) return;
        
        if (getActiveBuilders() >= gameState.maxBuilders) {
            showToast("âš ï¸ å¤§å·¥ãŒå…¨å“¡ä½œæ¥­ä¸­ã§ã™");
            return;
        }

        const t = gameState.tiles[selectedTileIndex];
        const lv = t.type===type ? t.level : 0;
        
        // æ–°è¦å»ºè¨­ã®å ´åˆã®ã¿æ•°åˆ¶é™ãƒã‚§ãƒƒã‚¯
        if(lv === 0 && !checkBuildingLimit(type)) {
            showToast("âš ï¸ ã“ã®æ–½è¨­ã¯ã“ã‚Œä»¥ä¸Šå»ºè¨­ã§ãã¾ã›ã‚“");
            return;
        }

        const c = getCost(type, lv);
        if(checkAfford(c)) {
            payCost(c);
            t.type = type;
            t.finishTime = Date.now() + getBuildTime(type, lv);
            t.stored = {};
            saveGame();
            sync3DState();
            updatePanelUI();
            updateHeader();
        }
    }
    
    window.actStore = function() {
        if(selectedTileIndex===null) return;
        const t = gameState.tiles[selectedTileIndex];
        if(!t.type) return;

        collectResource(selectedTileIndex);

        gameState.inventory.push({ type: t.type, level: t.level });

        t.type = null;
        t.level = 0;
        t.finishTime = null;
        t.stored = {};
        
        saveGame();
        sync3DState();
        updatePanelUI();
        updateHeader(); 
    };

    window.actRestore = function(invIndex) {
        if(selectedTileIndex===null) return;
        
        if (getActiveBuilders() >= gameState.maxBuilders) {
            showToast("âš ï¸ å¤§å·¥ãŒå…¨å“¡ä½œæ¥­ä¸­ã§ã™");
            return;
        }

        if(invIndex < 0 || invIndex >= gameState.inventory.length) return;

        const item = gameState.inventory[invIndex];
        
        // å¾©å…ƒæ™‚ã‚‚æ•°åˆ¶é™ãƒã‚§ãƒƒã‚¯
        if (!checkBuildingLimit(item.type)) {
            showToast("âš ï¸ ã“ã®æ–½è¨­ã¯ã“ã‚Œä»¥ä¸Šé…ç½®ã§ãã¾ã›ã‚“");
            return;
        }

        const t = gameState.tiles[selectedTileIndex];

        gameState.inventory.splice(invIndex, 1);

        t.type = item.type;
        t.level = Math.max(0, item.level - 1); 
        t.finishTime = Date.now() + getBuildTime(item.type, t.level);
        t.stored = {};

        saveGame();
        sync3DState();
        updatePanelUI();
        updateHeader();
    };
    
    window.actExpand = function() {
        if(selectedTileIndex===null) return;
        const c = getExpandCost(gameState.rank);
        if(checkAfford(c)) {
            payCost(c);
            gameState.tiles[selectedTileIndex].unlocked = true;
            saveGame();
            
            // æ‹¡å¼µå¾Œã®ãƒã‚§ãƒƒã‚¯
            checkAndExpandWorld();
            
            sync3DState();
            updatePanelUI();
        }
    }

    window.openMenu = function() {
        const modal = document.getElementById('modal-menu');
        const content = document.getElementById('menu-content');
        
        const builderCost = getBuilderCost();
        const canBuyBuilder = gameState.resources.money >= builderCost;
        const currentUid = currentUser ? currentUser.uid : "æœªæ¥ç¶š(ã‚ªãƒ•ãƒ©ã‚¤ãƒ³)";
        
        // å…±æœ‰IDè¨­å®šãŒã‚ã‚Œã°ãã¡ã‚‰ã‚’è¡¨ç¤º
        const sharedUid = localStorage.getItem('kingdomBuilder_sharedId');
        const displayUid = sharedUid ? `${sharedUid} (é€£æºä¸­)` : currentUid;

        content.innerHTML = `
            <div class="shop-item">
                <button class="action-btn" onclick="openBuildingList()" style="width:100%; margin-bottom:10px; background-color:#3498db;">
                    ğŸ“‹ æ–½è¨­ä¸€è¦§
                </button>
            </div>

            <div class="shop-item">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <div>
                        <strong>ğŸ‘· å¤§å·¥ã®å¢—å“¡</strong><br>
                        <span style="font-size:0.9em; color:#666;">ç¾åœ¨ã®äººæ•°: ${gameState.maxBuilders}äºº</span>
                    </div>
                    <div style="text-align:right;">
                        <span style="font-size:1.1em; font-weight:bold; color:#e67e22;">ğŸ’°${builderCost.toLocaleString()}</span>
                    </div>
                </div>
                <button class="action-btn" onclick="actBuyBuilder()" ${canBuyBuilder ? '' : 'disabled'}>
                    è³¼å…¥ã™ã‚‹
                </button>
            </div>
            
            <div class="shop-item">
                <strong>ğŸ”„ IDé€£æº (åŒæœŸãƒ—ãƒ¬ã‚¤)</strong>
                <p style="font-size:0.8em; color:#666; margin:5px 0;">
                    ç¾åœ¨ã®ID (ã“ã®IDã‚’åˆ¥ç«¯æœ«ã«å…¥åŠ›):<br>
                    <input type="text" value="${sharedUid || currentUid}" readonly style="width:100%; padding:5px; background:#eee; border:1px solid #ddd; border-radius:4px;" onclick="this.select();document.execCommand('copy');showToast('IDã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ')">
                </p>
                <div style="margin-top:10px; border-top:1px dashed #ccc; padding-top:10px;">
                    <p style="font-size:0.8em; color:#666; margin:0 0 5px 0;">åˆ¥ç«¯æœ«ã®IDã‚’å…¥åŠ›ã—ã¦é€£æº:</p>
                    <div style="display:flex; gap:5px;">
                        <input type="text" id="restore-uid-input" placeholder="é€£æºã™ã‚‹IDã‚’å…¥åŠ›" style="flex:1; padding:5px; border:1px solid #ddd; border-radius:4px;">
                        <button onclick="actLinkID()" style="padding:5px 10px; font-size:0.9em;">é€£æº</button>
                    </div>
                    ${sharedUid ? '<div style="margin-top:5px;"><button onclick="actUnlinkID()" style="width:100%; background-color:#e74c3c;">é€£æºã‚’è§£é™¤ã™ã‚‹</button></div>' : ''}
                </div>
            </div>

            <div class="shop-item">
                <strong>ğŸ“ ã‚²ãƒ¼ãƒ ã«ã¤ã„ã¦</strong>
                <p style="font-size:0.9em; color:#666;">
                    ç¾åœ¨ã®ãƒãƒƒãƒ—ã‚µã‚¤ã‚º: ${gameState.gridSize}x${gameState.gridSize}<br>
                    å…¨ã¦é–‹æ‹“ã™ã‚‹ã¨ä¸–ç•ŒãŒåºƒãŒã‚Šã¾ã™ï¼<br>
                    ãƒ‡ãƒ¼ã‚¿ã¯ã‚¯ãƒ©ã‚¦ãƒ‰ã«ä¿å­˜ã•ã‚Œã¦ã„ã¾ã™â˜ï¸
                </p>
            </div>
        `;
        
        modal.style.display = 'flex';
    };

    window.openBuildingList = function() {
        closeModal('modal-menu');
        const modal = document.getElementById('modal-building-list');
        const content = document.getElementById('building-list-content');
        
        let html = '<div style="font-weight:bold; margin-bottom:5px; color:#2c3e50;">ğŸŒ ãƒãƒƒãƒ—ä¸Šã®æ–½è¨­</div>';
        
        let mapBuildings = [];
        gameState.tiles.forEach((t, i) => {
            if(t.type) {
                mapBuildings.push({ tile: t, index: i });
            }
        });
        
        const getResScore = (type) => {
             const b = BUILDINGS[type];
             if(b.prod.money) return 1;
             if(b.prod.food) return 2;
             if(b.prod.wood) return 3;
             if(b.prod.stone) return 4;
             if(b.prod.iron) return 5;
             return 6;
        };
        const sortFn = (a, b) => {
             const typeA = a.tile ? a.tile.type : a.type;
             const lvlA = a.tile ? a.tile.level : a.level;
             const typeB = b.tile ? b.tile.type : b.type;
             const lvlB = b.tile ? b.tile.level : b.level;
             
             const sA = getResScore(typeA);
             const sB = getResScore(typeB);
             
             if(sA !== sB) return sA - sB;
             return lvlB - lvlA;
        };

        mapBuildings.sort(sortFn);
        
        if(mapBuildings.length === 0) {
            html += '<p style="color:#999; font-size:0.9em;">æ–½è¨­ã¯ã‚ã‚Šã¾ã›ã‚“</p>';
        } else {
            mapBuildings.forEach(item => {
                const b = BUILDINGS[item.tile.type];
                const level = item.tile.level;
                
                let prodStr = "";
                for(let r in b.prod) if(b.prod[r]>0) {
                    const val = b.prod[r] * level * Math.pow(1.05, level - 1);
                    const icon = (r=='money'?'ğŸ’°':r=='food'?'ğŸŒ¾':r=='wood'?'ğŸŒ²':r=='stone'?'ğŸª¨':'ğŸ”©');
                    prodStr += `${icon}${val.toFixed(1)}/s `;
                }
                
                html += `
                    <div class="building-item" style="background:white; margin-bottom:5px;">
                        <div class="building-info">
                            <strong>${b.icon} ${b.name} (Lv.${level})</strong>
                            <span style="font-size:0.8em; color:#666;">${prodStr}</span>
                        </div>
                        <button onclick="focusTile(${item.index})" style="padding:5px 10px; font-size:0.8em;">è©³ç´°</button>
                    </div>
                `;
            });
        }
        
        html += '<div style="font-weight:bold; margin-top:15px; margin-bottom:5px; color:#7f8c8d; border-top:1px dashed #ccc; padding-top:10px;">ğŸ“¦ ä¿ç®¡åº«ã®æ–½è¨­</div>';
        
        if(gameState.inventory.length === 0) {
            html += '<p style="color:#999; font-size:0.9em;">ä¿ç®¡åº«ã¯ç©ºã§ã™</p>';
        } else {
            // è¡¨ç¤ºç”¨ã«ã‚½ãƒ¼ãƒˆã—ãŸã‚³ãƒ”ãƒ¼ã‚’ä½œæˆï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä¿æŒã—ãªã„ã¨ãƒªã‚¹ãƒˆã‚¢ã§ãƒã‚°ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€è¡¨ç¤ºã®ã¿ï¼‰
            // æ³¨: ä»Šå›ã®å®Ÿè£…ã§ã¯ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªä¸€è¦§ã«æ“ä½œãƒœã‚¿ãƒ³ãŒãªã„ãŸã‚ã€è¡¨ç¤ºé †åºã‚’å¤‰ãˆã¦ã‚‚å•é¡Œãªã„
            let sortedInv = [...gameState.inventory];
            sortedInv.sort(sortFn);

            sortedInv.forEach(item => {
                const b = BUILDINGS[item.type];
                html += `
                    <div class="building-item" style="background:#f5f5f5; color:#666;">
                        <div class="building-info">
                            <strong>${b.icon} ${b.name} (Lv.${item.level})</strong>
                            <span style="font-size:0.8em;">å†è¨­ç½®å¾…ã¡</span>
                        </div>
                        <span style="font-size:0.8em; background:#eee; padding:3px 6px; border-radius:4px;">ä¿ç®¡ä¸­</span>
                    </div>
                `;
            });
        }
        
        content.innerHTML = html;
        modal.style.display = 'flex';
    };

    window.focusTile = function(index) {
        closeModal('modal-building-list');
        selectTile(index);
        
        // ã‚«ãƒ¡ãƒ©ç§»å‹•
        const tObj = tileMeshes[index];
        if(tObj && camera) {
            const targetX = tObj.mesh.position.x;
            const targetZ = tObj.mesh.position.z;
            
            // ç¾åœ¨ã®Y, Zoom, Rotationã‚’ç¶­æŒã—ã¤ã¤X,Zã ã‘ç§»å‹•
            // OrthographicCameraãªã®ã§ã€X,Zç§»å‹•ã ã‘ã§OKï¼ˆsetCameraZoomç­‰ã¯ç¶­æŒï¼‰
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãªã—ã§å³ç§»å‹•ã•ã›ã‚‹
            const offset = 20; // åˆæœŸä½ç½®ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ (20, 20, 20) ã‚’è€ƒæ…®
            // ã‚«ãƒ¡ãƒ©ã¯ (20, 20, 20) ã‹ã‚‰ (0,0,0) ã‚’è¦‹ã¦ã„ã‚‹ã€‚
            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ç”»é¢ä¸­å¤®ã«ã™ã‚‹ã«ã¯ã€ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆåº§æ¨™åˆ†ãšã‚‰ã›ã°ã‚ˆã„ï¼Ÿ
            // OrthographicCameraã§ã®ãƒ‘ãƒ³ãƒ‹ãƒ³ã‚°ã¯ camera.position ã‚’å‹•ã‹ã™ã“ã¨ã§å®Ÿç¾ã—ã¦ã„ã‚‹ã€‚
            // moveCameraé–¢æ•°ã¯ç›¸å¯¾ç§»å‹•ã ãŒã€ã“ã“ã§ã¯çµ¶å¯¾ä½ç½®ã¸è¡ŒããŸã„ã€‚
            
            // ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©ä½ç½®ã‹ã‚‰ã€LookAtä¸­å¿ƒï¼ˆã¨ä»®å®šã•ã‚Œã‚‹ç‚¹ï¼‰ã¸ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ç¶­æŒã—ã¦ç§»å‹•ã—ãŸã„ãŒã€
            // ç°¡æ˜“çš„ã«ã€ã‚¿ã‚¤ãƒ«ã®çœŸä¸Šã«ã‚«ãƒ¡ãƒ©ã‚’æŒã£ã¦ãã‚‹ã‚ˆã†ãªç§»å‹•ã‚’ã™ã‚‹ã€‚
            // åˆæœŸã‚«ãƒ¡ãƒ©: pos(20,20,20), lookAt(0,0,0) -> æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«(1,1,1)
            
            // æ—¢å­˜ã®ãƒ‘ãƒ³ãƒ‹ãƒ³ã‚°ãƒ­ã‚¸ãƒƒã‚¯ã«åˆã‚ã›ã‚‹ãŸã‚ã€ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ç›´æ¥æ“ä½œ
            // Xã¨Zã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«åˆã‚ã›ã¦ç§»å‹•
            // ãŸã ã—æ–œã‚è¦–ç‚¹ãªã®ã§ã€å˜ç´”ã« x=targetX ã§ã¯ãšã‚Œã‚‹ã€‚
            // æ—¢å­˜ã®moveCameraã®é€†ç®—ã¯è¤‡é›‘ãªã®ã§ã€ãƒ‘ãƒ³ãƒ‹ãƒ³ã‚°ä½ç½®å¤‰æ•°ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦å†è¨ˆç®—ãªã©ãŒç†æƒ³ã ãŒ...
            
            // ã‚·ãƒ³ãƒ—ãƒ«ã«: ã‚«ãƒ¡ãƒ©ã®X,Zã‚’ã€ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®X,Zã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’åŠ ãˆãŸã‚‚ã®ã«ã™ã‚‹
            camera.position.x = targetX + 20;
            camera.position.z = targetZ + 20;
            // Yã¯å¤‰ãˆãªã„
            camera.updateProjectionMatrix();
        }
    };

    window.actLinkID = function() {
        const input = document.getElementById('restore-uid-input');
        const targetUid = input.value.trim();
        if(!targetUid) return showToast("âš ï¸ IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        
        if(!confirm("âš ï¸ IDé€£æºãƒ¢ãƒ¼ãƒ‰\n\nå…¥åŠ›ã—ãŸIDã®ãƒ‡ãƒ¼ã‚¿ã‚’ã€å…±æœ‰ã€ã—ã¦ãƒ—ãƒ¬ã‚¤ã—ã¾ã™ã€‚\nè¤‡æ•°ã®ç«¯æœ«ã§åŒã˜ãƒ‡ãƒ¼ã‚¿ã‚’åŒæœŸã§ãã¾ã™ã€‚\n(â€»Firebaseã®ãƒ«ãƒ¼ãƒ«è¨­å®šãŒå¿…è¦ã§ã™)\n\nåˆ‡ã‚Šæ›¿ãˆã¾ã™ã‹ï¼Ÿ")) return;
        
        localStorage.setItem('kingdomBuilder_sharedId', targetUid);
        location.reload();
    };
    
    window.actUnlinkID = function() {
        if(!confirm("é€£æºã‚’è§£é™¤ã—ã€æœ¬æ¥ã®è‡ªåˆ†ã®IDã«æˆ»ã‚Šã¾ã™ã‹ï¼Ÿ")) return;
        localStorage.removeItem('kingdomBuilder_sharedId');
        location.reload();
    }

    window.actBuyBuilder = function() {
        const cost = getBuilderCost();
        if (gameState.resources.money >= cost) {
            gameState.resources.money -= cost;
            gameState.maxBuilders++;
            saveGame();
            updateHeader();
            openMenu();
        }
    };

    function updateHeader() {
        for(let k in gameState.resources) document.getElementById('display-'+k).innerText = Math.floor(gameState.resources[k]).toLocaleString();
        document.getElementById('display-rank').innerText = gameState.rank;
        document.getElementById('display-next-xp').innerText = (getNextRankXP(gameState.rank)-gameState.xp).toLocaleString();
        document.getElementById('display-xp-bar').style.width = Math.min(100, (gameState.xp/getNextRankXP(gameState.rank))*100)+'%';
        
        const active = getActiveBuilders();
        const max = gameState.maxBuilders;
        const builderEl = document.getElementById('display-builders');
        builderEl.innerText = `${active}/${max}`;
        builderEl.style.color = active >= max ? 'red' : '#2c3e50';
    }

    function onWindowResize() {
        const c = document.getElementById('game-container');
        if (!c) return;
        const width = c.clientWidth || window.innerWidth;
        const height = c.clientHeight || window.innerHeight;
        const aspect = width / height;
        const d = 10;
        
        if (camera && renderer) {
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }
    }

    // Process Offline Income after Cloud Load
    function processOfflineProgress() {
        try {
            const now = Date.now();
            const sec = (now - gameState.lastSaveTime)/1000;
            if(sec > 10) {
                let rep = ""; let built = 0; let earn = {};
                gameState.tiles.forEach(t => {
                    if(t.finishTime && t.finishTime <= now) { t.level++; t.finishTime=null; built++; gameState.xp+=Math.floor(getBuildTime(t.type,t.level-1)/1000); }
                    if(t.type && t.level>0 && !t.finishTime) {
                        const b=BUILDINGS[t.type]; const caps=getStorageCapacity(t.type,t.level);
                        for(let r in b.prod) if(b.prod[r]>0) {
                            if(!earn[r]) earn[r]=0;
                            const add = Math.min(caps[r]-(t.stored[r]||0), b.prod[r]*t.level*Math.pow(1.05,t.level-1)*sec);
                            if(add>0) { t.stored[r]=(t.stored[r]||0)+add; earn[r]+=add; }
                        }
                    }
                });
                if(built>0) rep+=`<div>ğŸ—ï¸ ${built}ä»¶å®Œäº†</div>`;
                for(let r in earn) if(earn[r]>1) rep+=`<div>+${Math.floor(earn[r]).toLocaleString()} ${r}</div>`;
                if(rep) { document.getElementById('offline-report').innerHTML=rep; document.getElementById('modal-offline').style.display='flex'; }
            }
            gameState.lastSaveTime = now;
        } catch (e) {
            console.error(e);
        }
    }
    
    window.closeModal = function(id) { document.getElementById(id).style.display='none'; }

</script>
</body>
</html>
